(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('substance'), require('katex')) :
  typeof define === 'function' && define.amd ? define(['exports', 'substance', 'katex'], factory) :
  (factory((global.texture = {}),global.substance,global.katex));
}(this, (function (exports,substance,katex) { 'use strict';

  katex = katex && katex.hasOwnProperty('default') ? katex['default'] : katex;

  function getText (rootEl, selector) {
    let el = rootEl.find(selector);
    if (el) {
      return el.textContent
    } else {
      return ''
    }
  }

  function getSeparatedText (rootEl, selector) {
    let el = rootEl.findAll(selector);
    if (el) {
      return el.map(m => { return m.textContent }).join('; ')
    } else {
      return ''
    }
  }

  function getAttr (rootEl, selector, attr) {
    let el = rootEl.find(selector);
    if (el) {
      return el.attr(attr)
    } else {
      return ''
    }
  }

  function findChild (el, cssSelector) {
    const children = el.getChildren();
    for (let i = 0; i < children.length; i++) {
      const child = children[i];
      if (child.is(cssSelector)) return child
    }
  }

  function findAllChildren (el, cssSelector) {
    const children = el.getChildren();
    let result = [];
    for (let i = 0; i < children.length; i++) {
      const child = children[i];
      if (child.is(cssSelector)) {
        result.push(child);
      }
    }
    return result
  }

  function isMixed (el) {
    let childNodes = el.childNodes;
    const L = childNodes.length;
    for (var i = 0; i < L; i++) {
      const childNode = childNodes[i];
      if (childNode.isTextNode() && !/^\s*$/.exec(childNode.textContent)) {
        return true
      }
    }
    return false
  }

  function printElement (el, options = {}) {
    let maxLevel = options.maxLevel || 1000;
    let res = _printElement(el, 1, maxLevel);
    return res
  }

  function _printElement (el, level, maxLevel) {
    let INDENT = new Array(level - 1);
    INDENT.fill('  ');
    INDENT = INDENT.join('');

    if (el.isElementNode()) {
      if (level <= maxLevel) {
        let res = [];
        res.push(INDENT + _openTag(el));
        res = res.concat(
          el.childNodes.map((child) => {
            return _printElement(child, level + 1, maxLevel)
          }).filter(Boolean)
        );
        res.push(INDENT + _closeTag(el));
        return res.join('\n')
      } else {
        return INDENT + _openTag(el) + '...' + _closeTag(el)
      }
    } else if (el.isTextNode()) {
      let textContent = el.textContent;
      if (/^\s*$/.exec(textContent)) {
        return ''
      } else {
        return INDENT + JSON.stringify(el.textContent)
      }
    } else {
      // TODO: render other node types and consider maxLevel
      return INDENT + el.serialize()
    }
  }

  function _openTag (el) {
    let attribStr = substance.DomUtils.formatAttribs(el);
    if (attribStr) {
      return `<${el.tagName} ${attribStr}>`
    } else {
      return `<${el.tagName}>`
    }
  }

  function _closeTag (el) {
    return `</${el.tagName}>`
  }

  class JATSImportDialog extends substance.Component {
    render ($$) {
      const errors = this.props.errors;
      let el = $$('div').addClass('sc-jats-import-dialog');
      el.append($$('h1').addClass('se-title').text('Importing JATS'));
      errors.forEach((error) => {
        el.append($$(ImportStage, {
          stage: error.name,
          errors: error.errors
        }));
      });
      return el
    }
  }

  class ImportStage extends substance.Component {
    render ($$) {
      const errors = this.props.errors;
      let el = $$('div').addClass('sc-import-stage');
      el.append($$('h2').addClass('se-title').text(_getTitle(this.props.stage)));

      if (this.props.errors.length > 0) {
        let errorsEl = $$('div').addClass('se-errors');
        errors.forEach((err) => {
          errorsEl.append(this._renderError($$, err));
        });
        el.append(errorsEl);
      }
      return el
    }

    _renderError ($$, err) {
      let el = $$('div').addClass('se-error');
      // TODO: maybe we will have more structured errors
      el.append(
        $$('div').addClass('se-message').text(err.msg)
      );
      if (err.el) {
        el.append(
          $$('pre').addClass('se-element').text(printElement(err.el, {maxLevel: 1}))
        );
      }
      return el
    }
  }

  const TITLES = {
    'parse': 'Parse XML',
    'validate-jats': 'Validate JATS',
    'validate-texture-article': 'Validate Texture Article',
    'j2r': 'Transform JATS -> TextureArticle',
    'r2t': 'Transform TextureArticle -> InternalArticle'
  };

  function _getTitle (stage) {
    return TITLES[stage]
  }

  // TODO: this should go into SubstanceLand

  function createSchema (XMLSchemaData, name, version, DocumentClass, docTypeParams) {
    let xmlSchema = substance.XMLSchema.fromJSON(XMLSchemaData);
    const tagNames = xmlSchema.getTagNames();
    let nodeClasses = [];
    // add node definitions and converters
    tagNames.forEach((tagName) => {
      const elementSchema = xmlSchema.getElementSchema(tagName);
      let targetTypes = [];
      if (elementSchema.expr._allowedChildren) {
        targetTypes = Object.keys(elementSchema.expr._allowedChildren);
      }
      let NodeClass;
      const elementType = elementSchema.type;
      const type = elementSchema.name;
      switch (elementType) {
        case 'element': {
          NodeClass = class _XMLElementNode extends substance.XMLElementNode {};
          NodeClass.schema = {
            _childNodes: { type: ['array', 'id'], default: [], owned: true, targetTypes }
          };
          break
        }
        case 'hybrid': {
          throw new Error('Mixed element types are not supported yet.')
        }
        case 'text': {
          NodeClass = class _XMLTextElement extends substance.XMLTextElement {};
          NodeClass.schema = {
            content: { type: 'text', targetTypes }
          };
          break
        }
        case 'annotation': {
          NodeClass = class _XMLAnnotationElement extends substance.XMLAnnotationNode {};
          break
        }
        case 'anchor': {
          NodeClass = class _XMLAnchorNode extends substance.XMLAnchorNode {};
          break
        }
        case 'inline-element': {
          NodeClass = class _XMLInlineElementNode extends substance.XMLInlineElementNode {};
          NodeClass.schema = {
            _childNodes: { type: ['array', 'id'], default: [], owned: true, targetTypes }
          };
          break
        }
        case 'external':
        case 'not-implemented': {
          NodeClass = class _XMLExternalNode extends substance.XMLExternalNode {};
          break
        }
        case 'container': {
          NodeClass = class _XMLContainerNode extends substance.XMLContainerNode {};
          NodeClass.schema = {
            _childNodes: { type: ['array', 'id'], default: [], owned: true, targetTypes }
          };
          break
        }
        default:
          throw new Error('Illegal state')
      }
      NodeClass.type = type;
      NodeClass._elementSchema = elementSchema;

      nodeClasses.push(NodeClass);
    });

    let schema = new substance.DocumentSchema({
      name,
      version,
      DocumentClass,
      // TODO: try to get rid of this
      defaultTextType: 'p'
    });
    schema.addNodes(nodeClasses)
    // HACK: add legacy API (Formerly XMLSchema)
    ;['getStartElement', 'validateElement', 'getElementSchema'].forEach(methodName => {
      schema[methodName] = (...args) => {
        return xmlSchema[methodName](...args)
      };
    });
    // other legacy functions that we had add manually
    schema.getName = () => { return name };
    schema.getDocTypeParams = () => { return docTypeParams };
    schema.xmlSchema = xmlSchema;

    return schema
  }

  function createXMLConverters (xmlSchema, tagNames) {
    const converters = [];
    if (!tagNames) tagNames = xmlSchema.getTagNames();
    tagNames.forEach((tagName) => {
      const elementSchema = xmlSchema.getElementSchema(tagName);
      const name = elementSchema.name;
      let ConverterClass;
      switch (elementSchema.type) {
        case 'element': {
          ConverterClass = substance.XMLElementNodeConverter;
          break
        }
        case 'hybrid': {
          throw new Error('Mixed element types are not supported yet.')
        }
        case 'text': {
          ConverterClass = substance.XMLTextElementConverter;
          break
        }
        case 'annotation': {
          ConverterClass = substance.XMLNodeConverter;
          break
        }
        case 'anchor': {
          ConverterClass = substance.XMLNodeConverter;
          break
        }
        case 'inline-element': {
          // NOTE: Inline nodes can have children too
          ConverterClass = substance.XMLElementNodeConverter;
          break
        }
        case 'external':
        case 'not-implemented': {
          ConverterClass = substance.XMLExternalNodeConverter;
          break
        }
        case 'container': {
          ConverterClass = substance.XMLElementNodeConverter;
          break
        }
        default:
          throw new Error('Illegal state')
      }
      let converter = new ConverterClass(name);
      converters.push(converter);
    });
    return converters
  }

  var JATSArchivingData = {"start":"article","elements":{"abbrev":{"name":"abbrev","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"alt":{"name":"alt"},"xml:lang":{"name":"xml:lang"},"xlink:type":{"name":"xlink:type"},"xlink:href":{"name":"xlink:href"},"xlink:role":{"name":"xlink:role"},"xlink:title":{"name":"xlink:title"},"xlink:show":{"name":"xlink:show"},"xlink:actuate":{"name":"xlink:actuate"}},"elements":{"name":"abbrev","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","def"]}}}},"abbrev-journal-title":{"name":"abbrev-journal-title","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"abbrev-type":{"name":"abbrev-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"abbrev-journal-title","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x"]}}}},"abstract":{"name":"abstract","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"abstract-type":{"name":"abstract-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"abstract","content":{"type":",","blocks":[{"type":"*","block":"object-id"},{"type":"?","block":"sec-meta"},{"type":"?","block":"label"},{"type":"?","block":"title"},{"type":"*","block":{"type":"|","blocks":["address","alternatives","array","boxed-text","chem-struct-wrap","code","fig","fig-group","graphic","media","preformat","supplementary-material","table-wrap","table-wrap-group","disp-formula","disp-formula-group","def-list","list","tex-math","mml:math","p","related-article","related-object","ack","disp-quote","speech","statement","verse-group","x"]}},{"type":"*","block":"sec"},{"type":"*","block":{"type":"|","blocks":["notes","fn-group","glossary","ref-list"]}}]}}},"access-date":{"name":"access-date","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"iso-8601-date":{"name":"iso-8601-date"},"calendar":{"name":"calendar"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"}},"elements":{"name":"access-date","content":{"type":"*","block":{"type":"|","blocks":["TEXT","day","era","month","season","year","x"]}}}},"ack":{"name":"ack","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"specific-use":{"name":"specific-use"},"content-type":{"name":"content-type"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"ack","content":{"type":",","blocks":[{"type":"?","block":"sec-meta"},{"type":"?","block":"label"},{"type":"?","block":"title"},{"type":"*","block":{"type":"|","blocks":["address","alternatives","array","boxed-text","chem-struct-wrap","code","fig","fig-group","graphic","media","preformat","supplementary-material","table-wrap","table-wrap-group","disp-formula","disp-formula-group","def-list","list","tex-math","mml:math","p","related-article","related-object","ack","disp-quote","speech","statement","verse-group","x"]}},{"type":"*","block":"sec"},{"type":"*","block":{"type":"|","blocks":["notes","fn-group","glossary","ref-list"]}}]}}},"addr-line":{"name":"addr-line","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"addr-line","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","city","country","fax","institution","institution-wrap","phone","postal-code","state"]}}}},"address":{"name":"address","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"address","content":{"type":"*","block":{"type":"|","blocks":["addr-line","city","country","fax","institution","institution-wrap","phone","postal-code","state","email","ext-link","uri","label","x"]}}}},"aff":{"name":"aff","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"rid":{"name":"rid"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"aff","content":{"type":"*","block":{"type":"|","blocks":["TEXT","addr-line","city","country","fax","institution","institution-wrap","phone","postal-code","state","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","break","label"]}}}},"aff-alternatives":{"name":"aff-alternatives","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"}},"elements":{"name":"aff-alternatives","content":{"type":"+","block":"aff"}}},"ali:free_to_read":{"name":"ali:free_to_read","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"end_date":{"name":"end_date"},"start_date":{"name":"start_date"}},"elements":{"name":"ali:free_to_read","content":{"type":",","blocks":[]}}},"ali:license_ref":{"name":"ali:license_ref","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"start_date":{"name":"start_date"}},"elements":{"name":"ali:license_ref","content":"TEXT"}},"alt-text":{"name":"alt-text","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"alt-text","content":"TEXT"}},"alt-title":{"name":"alt-title","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"alt-title-type":{"name":"alt-title-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"alt-title","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","break"]}}}},"alternatives":{"name":"alternatives","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"}},"elements":{"name":"alternatives","content":{"type":"+","block":{"type":"|","blocks":["array","chem-struct","code","graphic","inline-graphic","inline-supplementary-material","media","preformat","private-char","supplementary-material","table","oasis:table","textual-form","tex-math","mml:math"]}}}},"annotation":{"name":"annotation","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"annotation","content":{"type":"+","block":"p"}}},"anonymous":{"name":"anonymous","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"anonymous","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x"]}}}},"app":{"name":"app","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"app","content":{"type":",","blocks":[{"type":"?","block":"sec-meta"},{"type":"?","block":"label"},{"type":"?","block":"title"},{"type":"*","block":{"type":"|","blocks":["address","alternatives","array","boxed-text","chem-struct-wrap","code","fig","fig-group","graphic","media","preformat","supplementary-material","table-wrap","table-wrap-group","disp-formula","disp-formula-group","def-list","list","tex-math","mml:math","p","related-article","related-object","ack","disp-quote","speech","statement","verse-group","x"]}},{"type":"*","block":"sec"},{"type":"*","block":{"type":"|","blocks":["notes","fn-group","glossary","ref-list"]}},{"type":"?","block":"permissions"}]}}},"app-group":{"name":"app-group","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"app-group","content":{"type":",","blocks":[{"type":"?","block":"label"},{"type":"?","block":"title"},{"type":"*","block":"abstract"},{"type":"*","block":"kwd-group"},{"type":"*","block":{"type":"|","blocks":["address","alternatives","array","boxed-text","chem-struct-wrap","code","fig","fig-group","graphic","media","preformat","supplementary-material","table-wrap","table-wrap-group","disp-formula","disp-formula-group","def-list","list","tex-math","mml:math","p","related-article","related-object","ack","disp-quote","speech","statement","verse-group","x"]}},{"type":"*","block":{"type":"|","blocks":["app","ref-list"]}}]}}},"array":{"name":"array","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"orientation":{"name":"orientation"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"array","content":{"type":",","blocks":[{"type":"?","block":"label"},{"type":"*","block":{"type":"|","blocks":["alt-text","long-desc","email","ext-link","uri"]}},{"type":"|","blocks":[{"type":"*","block":{"type":"|","blocks":["alternatives","graphic","media"]}},"tbody","oasis:tbody"]},{"type":"*","block":{"type":"|","blocks":["attrib","permissions"]}}]}}},"article":{"name":"article","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"article-type":{"name":"article-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"dtd-version":{"name":"dtd-version"}},"elements":{"name":"article","content":{"type":",","blocks":["front",{"type":"?","block":"body"},{"type":"?","block":"back"},{"type":"?","block":"floats-group"},{"type":"|","blocks":[{"type":"*","block":"sub-article"},{"type":"*","block":"response"}]}]}}},"article-categories":{"name":"article-categories","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"}},"elements":{"name":"article-categories","content":{"type":",","blocks":[{"type":"*","block":"subj-group"},{"type":"*","block":"series-title"},{"type":"*","block":"series-text"}]}}},"article-id":{"name":"article-id","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"pub-id-type":{"name":"pub-id-type"},"specific-use":{"name":"specific-use"}},"elements":{"name":"article-id","content":"TEXT"}},"article-meta":{"name":"article-meta","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"}},"elements":{"name":"article-meta","content":{"type":",","blocks":[{"type":"*","block":"article-id"},{"type":"?","block":"article-categories"},{"type":"?","block":"title-group"},{"type":"*","block":{"type":"|","blocks":["contrib-group","aff","aff-alternatives","x"]}},{"type":"?","block":"author-notes"},{"type":"*","block":"pub-date"},{"type":"*","block":"volume"},{"type":"*","block":"volume-id"},{"type":"?","block":"volume-series"},{"type":"*","block":"issue"},{"type":"*","block":"issue-id"},{"type":"*","block":"issue-title"},{"type":"*","block":"issue-sponsor"},{"type":"?","block":"issue-part"},{"type":"*","block":"volume-issue-group"},{"type":"*","block":"isbn"},{"type":"?","block":"supplement"},{"type":"?","block":{"type":"|","blocks":[{"type":",","blocks":[{"type":"?","block":{"type":",","blocks":["fpage",{"type":"?","block":"lpage"}]}},{"type":"?","block":"page-range"}]},"elocation-id"]}},{"type":"*","block":{"type":"|","blocks":["email","ext-link","uri","product","supplementary-material"]}},{"type":"?","block":"history"},{"type":"?","block":"permissions"},{"type":"*","block":"self-uri"},{"type":"*","block":{"type":"|","blocks":["related-article","related-object"]}},{"type":"*","block":"abstract"},{"type":"*","block":"trans-abstract"},{"type":"*","block":"kwd-group"},{"type":"*","block":"funding-group"},{"type":"*","block":"conference"},{"type":"?","block":"counts"},{"type":"?","block":"custom-meta-group"}]}}},"article-title":{"name":"article-title","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"article-title","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","break"]}}}},"attrib":{"name":"attrib","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"attrib","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","break"]}}}},"author-comment":{"name":"author-comment","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"author-comment","content":{"type":",","blocks":[{"type":"?","block":"title"},{"type":"+","block":"p"}]}}},"author-notes":{"name":"author-notes","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"rid":{"name":"rid"},"specific-use":{"name":"specific-use"}},"elements":{"name":"author-notes","content":{"type":",","blocks":[{"type":"?","block":"label"},{"type":"?","block":"title"},{"type":"+","block":{"type":"|","blocks":["corresp","fn","p","x"]}}]}}},"award-group":{"name":"award-group","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"rid":{"name":"rid"},"award-type":{"name":"award-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"xlink:type":{"name":"xlink:type"},"xlink:href":{"name":"xlink:href"},"xlink:role":{"name":"xlink:role"},"xlink:title":{"name":"xlink:title"},"xlink:show":{"name":"xlink:show"},"xlink:actuate":{"name":"xlink:actuate"}},"elements":{"name":"award-group","content":{"type":",","blocks":[{"type":"*","block":"funding-source"},{"type":"*","block":"award-id"},{"type":"*","block":"principal-award-recipient"},{"type":"*","block":"principal-investigator"}]}}},"award-id":{"name":"award-id","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"rid":{"name":"rid"},"award-type":{"name":"award-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"xlink:type":{"name":"xlink:type"},"xlink:href":{"name":"xlink:href"},"xlink:role":{"name":"xlink:role"},"xlink:title":{"name":"xlink:title"},"xlink:show":{"name":"xlink:show"},"xlink:actuate":{"name":"xlink:actuate"}},"elements":{"name":"award-id","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x"]}}}},"back":{"name":"back","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"}},"elements":{"name":"back","content":{"type":",","blocks":[{"type":"?","block":"label"},{"type":"*","block":"title"},{"type":"*","block":{"type":"|","blocks":["ack","app-group","bio","fn-group","glossary","ref-list","notes","sec"]}}]}}},"bio":{"name":"bio","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"rid":{"name":"rid"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"xlink:type":{"name":"xlink:type"},"xlink:href":{"name":"xlink:href"},"xlink:role":{"name":"xlink:role"},"xlink:title":{"name":"xlink:title"},"xlink:show":{"name":"xlink:show"},"xlink:actuate":{"name":"xlink:actuate"}},"elements":{"name":"bio","content":{"type":",","blocks":[{"type":"?","block":"sec-meta"},{"type":"?","block":"label"},{"type":"?","block":"title"},{"type":"*","block":{"type":"|","blocks":["address","alternatives","array","boxed-text","chem-struct-wrap","code","fig","fig-group","graphic","media","preformat","supplementary-material","table-wrap","table-wrap-group","disp-formula","disp-formula-group","def-list","list","tex-math","mml:math","p","related-article","related-object","ack","disp-quote","speech","statement","verse-group","x"]}},{"type":"*","block":"sec"},{"type":"*","block":{"type":"|","blocks":["notes","fn-group","glossary","ref-list"]}}]}}},"body":{"name":"body","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"specific-use":{"name":"specific-use"}},"elements":{"name":"body","content":{"type":",","blocks":[{"type":"*","block":{"type":"|","blocks":["address","alternatives","array","boxed-text","chem-struct-wrap","code","fig","fig-group","graphic","media","preformat","supplementary-material","table-wrap","table-wrap-group","disp-formula","disp-formula-group","def-list","list","tex-math","mml:math","p","related-article","related-object","ack","disp-quote","speech","statement","verse-group","x"]}},{"type":"*","block":"sec"},{"type":"?","block":"sig-block"}]}}},"bold":{"name":"bold","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"toggle":{"name":"toggle"},"specific-use":{"name":"specific-use"}},"elements":{"name":"bold","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","break"]}}}},"boxed-text":{"name":"boxed-text","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"position":{"name":"position"},"orientation":{"name":"orientation"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"content-type":{"name":"content-type"}},"elements":{"name":"boxed-text","content":{"type":",","blocks":[{"type":"*","block":"object-id"},{"type":"?","block":"sec-meta"},{"type":"?","block":"label"},{"type":"?","block":"caption"},{"type":"*","block":{"type":"|","blocks":["address","alternatives","array","boxed-text","chem-struct-wrap","code","fig","fig-group","graphic","media","preformat","supplementary-material","table-wrap","table-wrap-group","disp-formula","disp-formula-group","def-list","list","tex-math","mml:math","p","related-article","related-object","ack","disp-quote","speech","statement","verse-group","x"]}},{"type":"*","block":"sec"},{"type":"*","block":{"type":"|","blocks":["notes","fn-group","glossary","ref-list"]}},{"type":"*","block":{"type":"|","blocks":["attrib","permissions"]}}]}}},"break":{"name":"break","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"}},"elements":{"name":"break","content":{"type":",","blocks":[]}}},"caption":{"name":"caption","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"style":{"name":"style"}},"elements":{"name":"caption","content":{"type":",","blocks":[{"type":"?","block":"title"},{"type":"*","block":"p"}]}}},"chapter-title":{"name":"chapter-title","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"chapter-title","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","break"]}}}},"chem-struct":{"name":"chem-struct","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"xlink:type":{"name":"xlink:type"},"xlink:href":{"name":"xlink:href"},"xlink:role":{"name":"xlink:role"},"xlink:title":{"name":"xlink:title"},"xlink:show":{"name":"xlink:show"},"xlink:actuate":{"name":"xlink:actuate"}},"elements":{"name":"chem-struct","content":{"type":"*","block":{"type":"|","blocks":["TEXT","alt-text","long-desc","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","break","object-id","label","def-list","list","array","code","graphic","media","preformat"]}}}},"chem-struct-wrap":{"name":"chem-struct-wrap","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"position":{"name":"position"},"orientation":{"name":"orientation"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"content-type":{"name":"content-type"}},"elements":{"name":"chem-struct-wrap","content":{"type":",","blocks":[{"type":"*","block":"object-id"},{"type":"?","block":"label"},{"type":"?","block":"caption"},{"type":"*","block":"abstract"},{"type":"*","block":"kwd-group"},{"type":"*","block":{"type":"|","blocks":["alt-text","long-desc","email","ext-link","uri"]}},{"type":"+","block":{"type":"|","blocks":["alternatives","chem-struct","code","graphic","media","preformat","textual-form"]}},{"type":"*","block":{"type":"|","blocks":["attrib","permissions"]}}]}}},"citation-alternatives":{"name":"citation-alternatives","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"}},"elements":{"name":"citation-alternatives","content":{"type":"+","block":{"type":"|","blocks":["element-citation","mixed-citation","nlm-citation"]}}}},"city":{"name":"city","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"city","content":"TEXT"}},"code":{"name":"code","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"code-type":{"name":"code-type"},"code-version":{"name":"code-version"},"executable":{"name":"executable"},"language":{"name":"language"},"language-version":{"name":"language-version"},"platforms":{"name":"platforms"},"position":{"name":"position"},"orientation":{"name":"orientation"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"}},"elements":{"name":"code","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup"]}}}},"col":{"name":"col","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"style":{"name":"style"},"span":{"name":"span"},"width":{"name":"width"},"align":{"name":"align"},"char":{"name":"char"},"charoff":{"name":"charoff"},"valign":{"name":"valign"}},"elements":{"name":"col","content":{"type":",","blocks":[]}}},"colgroup":{"name":"colgroup","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"style":{"name":"style"},"span":{"name":"span"},"width":{"name":"width"},"align":{"name":"align"},"char":{"name":"char"},"charoff":{"name":"charoff"},"valign":{"name":"valign"}},"elements":{"name":"colgroup","content":{"type":"*","block":"col"}}},"collab":{"name":"collab","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"collab-type":{"name":"collab-type"},"symbol":{"name":"symbol"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"xlink:type":{"name":"xlink:type"},"xlink:href":{"name":"xlink:href"},"xlink:role":{"name":"xlink:role"},"xlink:title":{"name":"xlink:title"},"xlink:show":{"name":"xlink:show"},"xlink:actuate":{"name":"xlink:actuate"}},"elements":{"name":"collab","content":{"type":"*","block":{"type":"|","blocks":["TEXT","inline-supplementary-material","related-article","related-object","addr-line","city","country","fax","institution","institution-wrap","phone","postal-code","state","hr","break","contrib-group","address","aff","aff-alternatives","author-comment","bio","email","etal","ext-link","fn","on-behalf-of","role","uri","xref","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","sub","sup","x"]}}}},"collab-alternatives":{"name":"collab-alternatives","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"}},"elements":{"name":"collab-alternatives","content":{"type":"+","block":"collab"}}},"comment":{"name":"comment","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"comment","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x"]}}}},"compound-kwd":{"name":"compound-kwd","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"}},"elements":{"name":"compound-kwd","content":{"type":"+","block":"compound-kwd-part"}}},"compound-kwd-part":{"name":"compound-kwd-part","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"}},"elements":{"name":"compound-kwd-part","content":{"type":"*","block":{"type":"|","blocks":["TEXT","break","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x"]}}}},"compound-subject":{"name":"compound-subject","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"}},"elements":{"name":"compound-subject","content":{"type":"+","block":"compound-subject-part"}}},"compound-subject-part":{"name":"compound-subject-part","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"}},"elements":{"name":"compound-subject-part","content":{"type":"*","block":{"type":"|","blocks":["TEXT","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","named-content","styled-content","sub","sup"]}}}},"conf-acronym":{"name":"conf-acronym","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"conf-acronym","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x"]}}}},"conf-date":{"name":"conf-date","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"iso-8601-date":{"name":"iso-8601-date"},"calendar":{"name":"calendar"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"conf-date","content":{"type":"*","block":{"type":"|","blocks":["TEXT","day","era","month","season","year","x"]}}}},"conf-loc":{"name":"conf-loc","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"conf-loc","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","addr-line","city","country","fax","institution","institution-wrap","phone","postal-code","state"]}}}},"conf-name":{"name":"conf-name","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"conf-name","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x"]}}}},"conf-num":{"name":"conf-num","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"conf-num","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x"]}}}},"conf-sponsor":{"name":"conf-sponsor","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"conf-sponsor","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","institution","institution-wrap"]}}}},"conf-theme":{"name":"conf-theme","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"conf-theme","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x"]}}}},"conference":{"name":"conference","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"xlink:type":{"name":"xlink:type"},"xlink:href":{"name":"xlink:href"},"xlink:role":{"name":"xlink:role"},"xlink:title":{"name":"xlink:title"},"xlink:show":{"name":"xlink:show"},"xlink:actuate":{"name":"xlink:actuate"}},"elements":{"name":"conference","content":{"type":"*","block":{"type":"|","blocks":["conf-date","conf-name","conf-num","conf-loc","conf-sponsor","conf-theme","conf-acronym","string-conf","x"]}}}},"contrib":{"name":"contrib","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"contrib-type":{"name":"contrib-type"},"corresp":{"name":"corresp"},"equal-contrib":{"name":"equal-contrib"},"deceased":{"name":"deceased"},"rid":{"name":"rid"},"specific-use":{"name":"specific-use"},"xlink:type":{"name":"xlink:type"},"xlink:href":{"name":"xlink:href"},"xlink:role":{"name":"xlink:role"},"xlink:title":{"name":"xlink:title"},"xlink:show":{"name":"xlink:show"},"xlink:actuate":{"name":"xlink:actuate"}},"elements":{"name":"contrib","content":{"type":"*","block":{"type":"|","blocks":["contrib-id","anonymous","collab","collab-alternatives","name","name-alternatives","string-name","degrees","address","aff","aff-alternatives","author-comment","bio","email","etal","ext-link","fn","on-behalf-of","role","uri","xref","x"]}}}},"contrib-group":{"name":"contrib-group","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"}},"elements":{"name":"contrib-group","content":{"type":"+","block":{"type":"|","blocks":["contrib","address","aff","aff-alternatives","author-comment","bio","email","etal","ext-link","fn","on-behalf-of","role","uri","xref","x"]}}}},"contrib-id":{"name":"contrib-id","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"contrib-id-type":{"name":"contrib-id-type"},"authenticated":{"name":"authenticated"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"contrib-id","content":"TEXT"}},"copyright-holder":{"name":"copyright-holder","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"copyright-holder","content":{"type":"*","block":{"type":"|","blocks":["TEXT","institution","institution-wrap","sub","sup","x"]}}}},"copyright-statement":{"name":"copyright-statement","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"copyright-statement","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x"]}}}},"copyright-year":{"name":"copyright-year","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"}},"elements":{"name":"copyright-year","content":"TEXT"}},"corresp":{"name":"corresp","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"corresp","content":{"type":"*","block":{"type":"|","blocks":["TEXT","addr-line","city","country","fax","institution","institution-wrap","phone","postal-code","state","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","break","label"]}}}},"count":{"name":"count","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"count-type":{"name":"count-type"},"count":{"name":"count"}},"elements":{"name":"count","content":{"type":",","blocks":[]}}},"country":{"name":"country","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"country":{"name":"country"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"country","content":{"type":"*","block":{"type":"|","blocks":["TEXT","x"]}}}},"counts":{"name":"counts","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"}},"elements":{"name":"counts","content":{"type":",","blocks":[{"type":"*","block":"count"},{"type":"?","block":"fig-count"},{"type":"?","block":"table-count"},{"type":"?","block":"equation-count"},{"type":"?","block":"ref-count"},{"type":"?","block":"page-count"},{"type":"?","block":"word-count"}]}}},"custom-meta":{"name":"custom-meta","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"xlink:type":{"name":"xlink:type"},"xlink:href":{"name":"xlink:href"},"xlink:role":{"name":"xlink:role"},"xlink:title":{"name":"xlink:title"},"xlink:show":{"name":"xlink:show"},"xlink:actuate":{"name":"xlink:actuate"}},"elements":{"name":"custom-meta","content":{"type":",","blocks":["meta-name","meta-value"]}}},"custom-meta-group":{"name":"custom-meta-group","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"}},"elements":{"name":"custom-meta-group","content":{"type":"+","block":"custom-meta"}}},"data-title":{"name":"data-title","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"data-title","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","named-content","styled-content","sub","sup"]}}}},"date":{"name":"date","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"date-type":{"name":"date-type"},"publication-format":{"name":"publication-format"},"iso-8601-date":{"name":"iso-8601-date"},"calendar":{"name":"calendar"},"specific-use":{"name":"specific-use"}},"elements":{"name":"date","content":{"type":",","blocks":[{"type":"?","block":{"type":"|","blocks":[{"type":",","blocks":[{"type":"?","block":"day"},{"type":"?","block":"month"}]},"season"]}},{"type":"?","block":"year"},{"type":"?","block":"era"},{"type":"?","block":"string-date"}]}}},"date-in-citation":{"name":"date-in-citation","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"iso-8601-date":{"name":"iso-8601-date"},"calendar":{"name":"calendar"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"date-in-citation","content":{"type":"*","block":{"type":"|","blocks":["TEXT","day","era","month","season","year","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","x"]}}}},"day":{"name":"day","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"day","content":"TEXT"}},"def":{"name":"def","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"rid":{"name":"rid"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"def","content":{"type":"+","block":"p"}}},"def-head":{"name":"def-head","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"}},"elements":{"name":"def-head","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x"]}}}},"def-item":{"name":"def-item","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"def-item","content":{"type":",","blocks":[{"type":"?","block":"label"},{"type":"*","block":"term"},{"type":"*","block":{"type":"|","blocks":["def","x"]}}]}}},"def-list":{"name":"def-list","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"list-type":{"name":"list-type"},"prefix-word":{"name":"prefix-word"},"list-content":{"name":"list-content"},"continued-from":{"name":"continued-from"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"def-list","content":{"type":",","blocks":[{"type":"?","block":"label"},{"type":"?","block":"title"},{"type":"?","block":"term-head"},{"type":"?","block":"def-head"},{"type":"*","block":{"type":"|","blocks":["def-item","x"]}},{"type":"*","block":"def-list"}]}}},"degrees":{"name":"degrees","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"degrees","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x"]}}}},"disp-formula":{"name":"disp-formula","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"disp-formula","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","abstract","alt-text","long-desc","break","attrib","permissions","kwd-group","label","array","code","graphic","media","preformat"]}}}},"disp-formula-group":{"name":"disp-formula-group","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"disp-formula-group","content":{"type":",","blocks":[{"type":"?","block":"label"},{"type":"?","block":"caption"},{"type":"*","block":"abstract"},{"type":"*","block":"kwd-group"},{"type":"*","block":{"type":"|","blocks":["alt-text","long-desc","email","ext-link","uri"]}},{"type":"*","block":{"type":"|","blocks":["disp-formula","disp-formula-group"]}}]}}},"disp-quote":{"name":"disp-quote","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"disp-quote","content":{"type":",","blocks":[{"type":"?","block":"label"},{"type":"?","block":"title"},{"type":"*","block":{"type":"|","blocks":["address","alternatives","array","boxed-text","chem-struct-wrap","code","fig","fig-group","graphic","media","preformat","supplementary-material","table-wrap","table-wrap-group","disp-formula","disp-formula-group","def-list","list","tex-math","mml:math","p","related-article","related-object","ack","disp-quote","speech","statement","verse-group","x"]}},{"type":"*","block":{"type":"|","blocks":["attrib","permissions"]}}]}}},"edition":{"name":"edition","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"designator":{"name":"designator"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"edition","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x"]}}}},"element-citation":{"name":"element-citation","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"publication-type":{"name":"publication-type"},"publisher-type":{"name":"publisher-type"},"publication-format":{"name":"publication-format"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"xlink:type":{"name":"xlink:type"},"xlink:href":{"name":"xlink:href"},"xlink:role":{"name":"xlink:role"},"xlink:title":{"name":"xlink:title"},"xlink:show":{"name":"xlink:show"},"xlink:actuate":{"name":"xlink:actuate"}},"elements":{"name":"element-citation","content":{"type":"+","block":{"type":"|","blocks":["inline-supplementary-material","related-article","related-object","hr","string-date","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","label","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","annotation","article-title","chapter-title","collab","collab-alternatives","comment","conf-acronym","conf-date","conf-loc","conf-name","conf-sponsor","data-title","date","date-in-citation","day","edition","email","elocation-id","etal","ext-link","fpage","gov","institution","institution-wrap","isbn","issn","issn-l","issue","issue-id","issue-part","issue-title","lpage","month","name","name-alternatives","object-id","page-range","part-title","patent","person-group","pub-id","publisher-loc","publisher-name","role","season","series","size","source","std","string-name","supplement","trans-source","trans-title","uri","version","volume","volume-id","volume-series","year","fn","target","xref","sub","sup","x"]}}}},"elocation-id":{"name":"elocation-id","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"seq":{"name":"seq"},"specific-use":{"name":"specific-use"}},"elements":{"name":"elocation-id","content":"TEXT"}},"email":{"name":"email","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"xlink:type":{"name":"xlink:type"},"xlink:href":{"name":"xlink:href"},"xlink:role":{"name":"xlink:role"},"xlink:title":{"name":"xlink:title"},"xlink:show":{"name":"xlink:show"},"xlink:actuate":{"name":"xlink:actuate"}},"elements":{"name":"email","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x"]}}}},"equation-count":{"name":"equation-count","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"count":{"name":"count"}},"elements":{"name":"equation-count","content":{"type":",","blocks":[]}}},"era":{"name":"era","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"era","content":"TEXT"}},"etal":{"name":"etal","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"etal","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x"]}}}},"ext-link":{"name":"ext-link","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"ext-link-type":{"name":"ext-link-type"},"assigning-authority":{"name":"assigning-authority"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"xlink:type":{"name":"xlink:type"},"xlink:href":{"name":"xlink:href"},"xlink:role":{"name":"xlink:role"},"xlink:title":{"name":"xlink:title"},"xlink:show":{"name":"xlink:show"},"xlink:actuate":{"name":"xlink:actuate"}},"elements":{"name":"ext-link","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x"]}}}},"fax":{"name":"fax","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"}},"elements":{"name":"fax","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x"]}}}},"fig":{"name":"fig","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"position":{"name":"position"},"orientation":{"name":"orientation"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"fig-type":{"name":"fig-type"}},"elements":{"name":"fig","content":{"type":",","blocks":[{"type":"*","block":"object-id"},{"type":"?","block":"label"},{"type":"*","block":"caption"},{"type":"*","block":"abstract"},{"type":"*","block":"kwd-group"},{"type":"*","block":{"type":"|","blocks":["alt-text","long-desc","email","ext-link","uri"]}},{"type":"*","block":{"type":"|","blocks":["disp-formula","disp-formula-group","chem-struct-wrap","disp-quote","speech","statement","verse-group","table-wrap","p","def-list","list","alternatives","array","code","graphic","media","preformat"]}},{"type":"*","block":{"type":"|","blocks":["attrib","permissions"]}}]}}},"fig-count":{"name":"fig-count","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"count":{"name":"count"}},"elements":{"name":"fig-count","content":{"type":",","blocks":[]}}},"fig-group":{"name":"fig-group","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"position":{"name":"position"},"orientation":{"name":"orientation"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"content-type":{"name":"content-type"}},"elements":{"name":"fig-group","content":{"type":",","blocks":[{"type":"?","block":"label"},{"type":"?","block":"caption"},{"type":"*","block":"abstract"},{"type":"*","block":"kwd-group"},{"type":"*","block":{"type":"|","blocks":["alt-text","long-desc","email","ext-link","uri"]}},{"type":"*","block":{"type":"|","blocks":["fig","alternatives","graphic","media"]}}]}}},"fixed-case":{"name":"fixed-case","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"}},"elements":{"name":"fixed-case","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","break"]}}}},"floats-group":{"name":"floats-group","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"}},"elements":{"name":"floats-group","content":{"type":"*","block":{"type":"|","blocks":["alternatives","boxed-text","chem-struct-wrap","code","fig","fig-group","graphic","media","preformat","supplementary-material","table-wrap","table-wrap-group"]}}}},"fn":{"name":"fn","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"symbol":{"name":"symbol"},"fn-type":{"name":"fn-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"fn","content":{"type":",","blocks":[{"type":"?","block":"label"},{"type":"+","block":"p"}]}}},"fn-group":{"name":"fn-group","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"fn-group","content":{"type":",","blocks":[{"type":"?","block":"label"},{"type":"?","block":"title"},{"type":"+","block":{"type":"|","blocks":["fn","x"]}}]}}},"fpage":{"name":"fpage","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"seq":{"name":"seq"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"fpage","content":"TEXT"}},"front":{"name":"front","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"}},"elements":{"name":"front","content":{"type":",","blocks":[{"type":"?","block":"journal-meta"},"article-meta",{"type":"*","block":{"type":"|","blocks":["def-list","list","ack","bio","fn-group","glossary","notes"]}}]}}},"front-stub":{"name":"front-stub","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"}},"elements":{"name":"front-stub","content":{"type":",","blocks":[{"type":"*","block":"article-id"},{"type":"?","block":"article-categories"},{"type":"?","block":"title-group"},{"type":"*","block":{"type":"|","blocks":["contrib-group","aff","aff-alternatives","x"]}},{"type":"?","block":"author-notes"},{"type":"*","block":"pub-date"},{"type":"*","block":"volume"},{"type":"*","block":"volume-id"},{"type":"?","block":"volume-series"},{"type":"*","block":"issue"},{"type":"*","block":"issue-id"},{"type":"*","block":"issue-title"},{"type":"*","block":"issue-sponsor"},{"type":"?","block":"issue-part"},{"type":"*","block":"volume-issue-group"},{"type":"*","block":"isbn"},{"type":"?","block":"supplement"},{"type":"?","block":{"type":"|","blocks":[{"type":",","blocks":[{"type":"?","block":{"type":",","blocks":["fpage",{"type":"?","block":"lpage"}]}},{"type":"?","block":"page-range"}]},"elocation-id"]}},{"type":"*","block":{"type":"|","blocks":["email","ext-link","uri","product","supplementary-material"]}},{"type":"?","block":"history"},{"type":"?","block":"permissions"},{"type":"*","block":"self-uri"},{"type":"*","block":{"type":"|","blocks":["related-article","related-object"]}},{"type":"*","block":"abstract"},{"type":"*","block":"trans-abstract"},{"type":"*","block":"kwd-group"},{"type":"*","block":"funding-group"},{"type":"*","block":"conference"},{"type":"?","block":"counts"},{"type":"?","block":"custom-meta-group"}]}}},"funding-group":{"name":"funding-group","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"funding-group","content":{"type":",","blocks":[{"type":"*","block":"award-group"},{"type":"*","block":"funding-statement"},{"type":"*","block":"open-access"}]}}},"funding-source":{"name":"funding-source","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"rid":{"name":"rid"},"source-type":{"name":"source-type"},"country":{"name":"country"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"xlink:type":{"name":"xlink:type"},"xlink:href":{"name":"xlink:href"},"xlink:role":{"name":"xlink:role"},"xlink:title":{"name":"xlink:title"},"xlink:show":{"name":"xlink:show"},"xlink:actuate":{"name":"xlink:actuate"}},"elements":{"name":"funding-source","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","institution","institution-wrap"]}}}},"funding-statement":{"name":"funding-statement","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"rid":{"name":"rid"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"xlink:type":{"name":"xlink:type"},"xlink:href":{"name":"xlink:href"},"xlink:role":{"name":"xlink:role"},"xlink:title":{"name":"xlink:title"},"xlink:show":{"name":"xlink:show"},"xlink:actuate":{"name":"xlink:actuate"}},"elements":{"name":"funding-statement","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","award-id","funding-source","open-access"]}}}},"given-names":{"name":"given-names","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"initials":{"name":"initials"}},"elements":{"name":"given-names","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x"]}}}},"glossary":{"name":"glossary","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"glossary","content":{"type":",","blocks":[{"type":"?","block":"label"},{"type":"?","block":"title"},{"type":"*","block":{"type":"|","blocks":["address","alternatives","array","boxed-text","chem-struct-wrap","code","fig","fig-group","graphic","media","preformat","supplementary-material","table-wrap","table-wrap-group","disp-formula","disp-formula-group","def-list","list","tex-math","mml:math","p","related-article","related-object","ack","disp-quote","speech","statement","verse-group","x"]}},{"type":"*","block":"glossary"}]}}},"glyph-data":{"name":"glyph-data","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"fontchar":{"name":"fontchar"},"fontname":{"name":"fontname"},"format":{"name":"format"},"resolution":{"name":"resolution"},"xml:space":{"name":"xml:space"},"x-size":{"name":"x-size"},"y-size":{"name":"y-size"}},"elements":{"name":"glyph-data","content":"TEXT"}},"glyph-ref":{"name":"glyph-ref","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"glyph-data":{"name":"glyph-data"}},"elements":{"name":"glyph-ref","content":{"type":",","blocks":[]}}},"gov":{"name":"gov","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"gov","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x"]}}}},"graphic":{"name":"graphic","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"position":{"name":"position"},"orientation":{"name":"orientation"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"content-type":{"name":"content-type"},"mime-subtype":{"name":"mime-subtype"},"mimetype":{"name":"mimetype"},"xlink:type":{"name":"xlink:type"},"xlink:href":{"name":"xlink:href"},"xlink:role":{"name":"xlink:role"},"xlink:title":{"name":"xlink:title"},"xlink:show":{"name":"xlink:show"},"xlink:actuate":{"name":"xlink:actuate"}},"elements":{"name":"graphic","content":{"type":"*","block":{"type":"|","blocks":["alt-text","long-desc","abstract","email","ext-link","uri","caption","object-id","kwd-group","label","attrib","permissions"]}}}},"history":{"name":"history","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"}},"elements":{"name":"history","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","break","date","string-date"]}}}},"hr":{"name":"hr","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"}},"elements":{"name":"hr","content":{"type":",","blocks":[]}}},"inline-formula":{"name":"inline-formula","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"inline-formula","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x"]}}}},"inline-graphic":{"name":"inline-graphic","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"baseline-shift":{"name":"baseline-shift"},"mimetype":{"name":"mimetype"},"mime-subtype":{"name":"mime-subtype"},"xml:lang":{"name":"xml:lang"},"xlink:type":{"name":"xlink:type"},"xlink:href":{"name":"xlink:href"},"xlink:role":{"name":"xlink:role"},"xlink:title":{"name":"xlink:title"},"xlink:show":{"name":"xlink:show"},"xlink:actuate":{"name":"xlink:actuate"}},"elements":{"name":"inline-graphic","content":{"type":"?","block":"alt-text"}}},"inline-supplementary-material":{"name":"inline-supplementary-material","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"mimetype":{"name":"mimetype"},"mime-subtype":{"name":"mime-subtype"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"xlink:type":{"name":"xlink:type"},"xlink:href":{"name":"xlink:href"},"xlink:role":{"name":"xlink:role"},"xlink:title":{"name":"xlink:title"},"xlink:show":{"name":"xlink:show"},"xlink:actuate":{"name":"xlink:actuate"}},"elements":{"name":"inline-supplementary-material","content":{"type":"*","block":{"type":"|","blocks":["TEXT","alt-text","long-desc","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x"]}}}},"institution":{"name":"institution","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"xlink:type":{"name":"xlink:type"},"xlink:href":{"name":"xlink:href"},"xlink:role":{"name":"xlink:role"},"xlink:title":{"name":"xlink:title"},"xlink:show":{"name":"xlink:show"},"xlink:actuate":{"name":"xlink:actuate"}},"elements":{"name":"institution","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","break"]}}}},"institution-id":{"name":"institution-id","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"institution-id-type":{"name":"institution-id-type"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"institution-id","content":"TEXT"}},"institution-wrap":{"name":"institution-wrap","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"}},"elements":{"name":"institution-wrap","content":{"type":"*","block":{"type":"|","blocks":["institution","institution-id"]}}}},"isbn":{"name":"isbn","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"publication-format":{"name":"publication-format"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"}},"elements":{"name":"isbn","content":{"type":"*","block":{"type":"|","blocks":["TEXT","x"]}}}},"issn":{"name":"issn","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"pub-type":{"name":"pub-type"},"publication-format":{"name":"publication-format"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"}},"elements":{"name":"issn","content":{"type":"*","block":{"type":"|","blocks":["TEXT","x"]}}}},"issn-l":{"name":"issn-l","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"specific-use":{"name":"specific-use"}},"elements":{"name":"issn-l","content":{"type":"*","block":{"type":"|","blocks":["TEXT","x"]}}}},"issue":{"name":"issue","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"seq":{"name":"seq"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"issue","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x"]}}}},"issue-id":{"name":"issue-id","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"pub-id-type":{"name":"pub-id-type"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"xlink:type":{"name":"xlink:type"},"xlink:href":{"name":"xlink:href"},"xlink:role":{"name":"xlink:role"},"xlink:title":{"name":"xlink:title"},"xlink:show":{"name":"xlink:show"},"xlink:actuate":{"name":"xlink:actuate"}},"elements":{"name":"issue-id","content":"TEXT"}},"issue-part":{"name":"issue-part","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"issue-part","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x"]}}}},"issue-sponsor":{"name":"issue-sponsor","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"issue-sponsor","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x"]}}}},"issue-title":{"name":"issue-title","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"issue-title","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x"]}}}},"italic":{"name":"italic","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"toggle":{"name":"toggle"},"specific-use":{"name":"specific-use"}},"elements":{"name":"italic","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","break"]}}}},"journal-id":{"name":"journal-id","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"journal-id-type":{"name":"journal-id-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"journal-id","content":"TEXT"}},"journal-meta":{"name":"journal-meta","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"}},"elements":{"name":"journal-meta","content":{"type":",","blocks":[{"type":"*","block":"journal-id"},{"type":"*","block":"journal-title-group"},{"type":"*","block":{"type":"|","blocks":["contrib-group","aff","aff-alternatives"]}},{"type":"*","block":"issn"},{"type":"?","block":"issn-l"},{"type":"*","block":"isbn"},{"type":"?","block":"publisher"},{"type":"*","block":"notes"},{"type":"*","block":"self-uri"},{"type":"?","block":"custom-meta-group"}]}}},"journal-subtitle":{"name":"journal-subtitle","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"journal-subtitle","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x"]}}}},"journal-title":{"name":"journal-title","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"journal-title","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x"]}}}},"journal-title-group":{"name":"journal-title-group","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"}},"elements":{"name":"journal-title-group","content":{"type":",","blocks":[{"type":"*","block":"journal-title"},{"type":"*","block":"journal-subtitle"},{"type":"*","block":"trans-title-group"},{"type":"*","block":"abbrev-journal-title"}]}}},"kwd":{"name":"kwd","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"}},"elements":{"name":"kwd","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","break"]}}}},"kwd-group":{"name":"kwd-group","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"kwd-group-type":{"name":"kwd-group-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"kwd-group","content":{"type":",","blocks":[{"type":"?","block":"label"},{"type":"?","block":"title"},{"type":"|","blocks":[{"type":"+","block":{"type":"|","blocks":["kwd","compound-kwd","nested-kwd","x"]}},{"type":"*","block":"unstructured-kwd-group"}]}]}}},"label":{"name":"label","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"alt":{"name":"alt"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"label","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","break"]}}}},"license":{"name":"license","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"license-type":{"name":"license-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"xlink:type":{"name":"xlink:type"},"xlink:href":{"name":"xlink:href"},"xlink:role":{"name":"xlink:role"},"xlink:title":{"name":"xlink:title"},"xlink:show":{"name":"xlink:show"},"xlink:actuate":{"name":"xlink:actuate"}},"elements":{"name":"license","content":{"type":"+","block":{"type":"|","blocks":["ali:license_ref","license-p"]}}}},"license-p":{"name":"license-p","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"}},"elements":{"name":"license-p","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","address","array","boxed-text","chem-struct-wrap","code","fig","fig-group","graphic","media","preformat","supplementary-material","table-wrap","table-wrap-group","disp-formula","disp-formula-group","citation-alternatives","element-citation","mixed-citation","nlm-citation","award-id","funding-source","open-access","def-list","list","ack","disp-quote","speech","statement","verse-group","price"]}}}},"list":{"name":"list","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"list-type":{"name":"list-type"},"prefix-word":{"name":"prefix-word"},"list-content":{"name":"list-content"},"continued-from":{"name":"continued-from"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"list","content":{"type":",","blocks":[{"type":"?","block":"label"},{"type":"?","block":"title"},{"type":"+","block":{"type":"|","blocks":["list-item","x"]}}]}}},"list-item":{"name":"list-item","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"list-item","content":{"type":",","blocks":[{"type":"?","block":"label"},{"type":"?","block":"title"},{"type":"+","block":{"type":"|","blocks":["p","def-list","list"]}}]}}},"long-desc":{"name":"long-desc","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"xlink:type":{"name":"xlink:type"},"xlink:href":{"name":"xlink:href"},"xlink:role":{"name":"xlink:role"},"xlink:title":{"name":"xlink:title"},"xlink:show":{"name":"xlink:show"},"xlink:actuate":{"name":"xlink:actuate"}},"elements":{"name":"long-desc","content":{"type":"*","block":{"type":"|","blocks":["TEXT","x"]}}}},"lpage":{"name":"lpage","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"lpage","content":"TEXT"}},"media":{"name":"media","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"position":{"name":"position"},"orientation":{"name":"orientation"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"content-type":{"name":"content-type"},"mimetype":{"name":"mimetype"},"mime-subtype":{"name":"mime-subtype"},"xlink:type":{"name":"xlink:type"},"xlink:href":{"name":"xlink:href"},"xlink:role":{"name":"xlink:role"},"xlink:title":{"name":"xlink:title"},"xlink:show":{"name":"xlink:show"},"xlink:actuate":{"name":"xlink:actuate"}},"elements":{"name":"media","content":{"type":"*","block":{"type":"|","blocks":["alt-text","long-desc","abstract","email","ext-link","uri","caption","object-id","kwd-group","label","attrib","permissions"]}}}},"meta-name":{"name":"meta-name","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"}},"elements":{"name":"meta-name","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x"]}}}},"meta-value":{"name":"meta-value","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"}},"elements":{"name":"meta-value","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x"]}}}},"milestone-end":{"name":"milestone-end","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"rid":{"name":"rid"},"content-type":{"name":"content-type"},"rationale":{"name":"rationale"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"milestone-end","content":{"type":",","blocks":[]}}},"milestone-start":{"name":"milestone-start","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"rid":{"name":"rid"},"content-type":{"name":"content-type"},"rationale":{"name":"rationale"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"milestone-start","content":{"type":",","blocks":[]}}},"mixed-citation":{"name":"mixed-citation","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"publication-type":{"name":"publication-type"},"publisher-type":{"name":"publisher-type"},"publication-format":{"name":"publication-format"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"xlink:type":{"name":"xlink:type"},"xlink:href":{"name":"xlink:href"},"xlink:role":{"name":"xlink:role"},"xlink:title":{"name":"xlink:title"},"xlink:show":{"name":"xlink:show"},"xlink:actuate":{"name":"xlink:actuate"}},"elements":{"name":"mixed-citation","content":{"type":"*","block":{"type":"|","blocks":["TEXT","inline-supplementary-material","related-article","related-object","hr","string-date","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","label","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","annotation","article-title","chapter-title","collab","collab-alternatives","comment","conf-acronym","conf-date","conf-loc","conf-name","conf-sponsor","data-title","date","date-in-citation","day","edition","email","elocation-id","etal","ext-link","fpage","gov","institution","institution-wrap","isbn","issn","issn-l","issue","issue-id","issue-part","issue-title","lpage","month","name","name-alternatives","object-id","page-range","part-title","patent","person-group","pub-id","publisher-loc","publisher-name","role","season","series","size","source","std","string-name","supplement","trans-source","trans-title","uri","version","volume","volume-id","volume-series","year","fn","target","xref","sub","sup","x"]}}}},"mml:abs":{"name":"mml:abs","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:abs","content":{"type":",","blocks":[]}}},"mml:and":{"name":"mml:and","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:and","content":{"type":",","blocks":[]}}},"mml:annotation":{"name":"mml:annotation","type":"text","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"cd":{"name":"cd"},"name":{"name":"name"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"},"src":{"name":"src"}},"elements":{"name":"mml:annotation","content":"TEXT"}},"mml:annotation-xml":{"name":"mml:annotation-xml","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"cd":{"name":"cd"},"name":{"name":"name"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"},"src":{"name":"src"}},"elements":{"name":"mml:annotation-xml","content":{"type":"+","block":"p"}}},"mml:apply":{"name":"mml:apply","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"}},"elements":{"name":"mml:apply","content":{"type":",","blocks":[{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs"]},{"type":"*","block":"mml:bvar"},{"type":"*","block":{"type":"|","blocks":[{"type":"*","block":{"type":"|","blocks":["mml:domainofapplication","mml:condition",{"type":",","blocks":["mml:lowlimit",{"type":"?","block":"mml:uplimit"}]}]}},"mml:degree","mml:momentabout","mml:logbase"]}},{"type":"*","block":{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs"]}}]}}},"mml:approx":{"name":"mml:approx","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:approx","content":{"type":",","blocks":[]}}},"mml:arccos":{"name":"mml:arccos","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:arccos","content":{"type":",","blocks":[]}}},"mml:arccosh":{"name":"mml:arccosh","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:arccosh","content":{"type":",","blocks":[]}}},"mml:arccot":{"name":"mml:arccot","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:arccot","content":{"type":",","blocks":[]}}},"mml:arccoth":{"name":"mml:arccoth","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:arccoth","content":{"type":",","blocks":[]}}},"mml:arccsc":{"name":"mml:arccsc","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:arccsc","content":{"type":",","blocks":[]}}},"mml:arccsch":{"name":"mml:arccsch","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:arccsch","content":{"type":",","blocks":[]}}},"mml:arcsec":{"name":"mml:arcsec","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:arcsec","content":{"type":",","blocks":[]}}},"mml:arcsech":{"name":"mml:arcsech","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:arcsech","content":{"type":",","blocks":[]}}},"mml:arcsin":{"name":"mml:arcsin","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:arcsin","content":{"type":",","blocks":[]}}},"mml:arcsinh":{"name":"mml:arcsinh","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:arcsinh","content":{"type":",","blocks":[]}}},"mml:arctan":{"name":"mml:arctan","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:arctan","content":{"type":",","blocks":[]}}},"mml:arctanh":{"name":"mml:arctanh","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:arctanh","content":{"type":",","blocks":[]}}},"mml:arg":{"name":"mml:arg","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:arg","content":{"type":",","blocks":[]}}},"mml:bind":{"name":"mml:bind","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"}},"elements":{"name":"mml:bind","content":{"type":",","blocks":[{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs"]},{"type":"*","block":"mml:bvar"},{"type":"*","block":{"type":"|","blocks":[{"type":"*","block":{"type":"|","blocks":["mml:domainofapplication","mml:condition",{"type":",","blocks":["mml:lowlimit",{"type":"?","block":"mml:uplimit"}]}]}},"mml:degree","mml:momentabout","mml:logbase"]}},{"type":"*","block":{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs"]}}]}}},"mml:bvar":{"name":"mml:bvar","type":"element","attributes":{},"elements":{"name":"mml:bvar","content":{"type":"|","blocks":[{"type":",","blocks":["mml:degree",{"type":"|","blocks":["mml:ci","mml:semantics"]}]},{"type":",","blocks":[{"type":"|","blocks":["mml:ci","mml:semantics"]},{"type":"?","block":"mml:degree"}]}]}}},"mml:card":{"name":"mml:card","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:card","content":{"type":",","blocks":[]}}},"mml:cartesianproduct":{"name":"mml:cartesianproduct","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:cartesianproduct","content":{"type":",","blocks":[]}}},"mml:cbytes":{"name":"mml:cbytes","type":"text","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:cbytes","content":"TEXT"}},"mml:ceiling":{"name":"mml:ceiling","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:ceiling","content":{"type":",","blocks":[]}}},"mml:cerror":{"name":"mml:cerror","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"}},"elements":{"name":"mml:cerror","content":{"type":",","blocks":["mml:csymbol",{"type":"*","block":{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs"]}}]}}},"mml:ci":{"name":"mml:ci","type":"text","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"},"type":{"name":"type"}},"elements":{"name":"mml:ci","content":{"type":"*","block":{"type":"|","blocks":["TEXT","mml:mglyph","mml:mi","mml:mn","mml:mo","mml:mtext","mml:mspace","mml:ms","mml:maligngroup","mml:malignmark","mml:mrow","mml:mfrac","mml:msqrt","mml:mroot","mml:mstyle","mml:merror","mml:mpadded","mml:mphantom","mml:mfenced","mml:menclose","mml:msub","mml:msup","mml:msubsup","mml:munder","mml:mover","mml:munderover","mml:mmultiscripts","mml:mtable","mml:mstack","mml:mlongdiv","mml:maction"]}}}},"mml:cn":{"name":"mml:cn","type":"text","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"},"type":{"name":"type"},"base":{"name":"base"}},"elements":{"name":"mml:cn","content":{"type":"*","block":{"type":"|","blocks":["TEXT","mml:mglyph","mml:sep","mml:mi","mml:mn","mml:mo","mml:mtext","mml:mspace","mml:ms","mml:maligngroup","mml:malignmark","mml:mrow","mml:mfrac","mml:msqrt","mml:mroot","mml:mstyle","mml:merror","mml:mpadded","mml:mphantom","mml:mfenced","mml:menclose","mml:msub","mml:msup","mml:msubsup","mml:munder","mml:mover","mml:munderover","mml:mmultiscripts","mml:mtable","mml:mstack","mml:mlongdiv","mml:maction"]}}}},"mml:codomain":{"name":"mml:codomain","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:codomain","content":{"type":",","blocks":[]}}},"mml:complexes":{"name":"mml:complexes","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:complexes","content":{"type":",","blocks":[]}}},"mml:compose":{"name":"mml:compose","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:compose","content":{"type":",","blocks":[]}}},"mml:condition":{"name":"mml:condition","type":"element","attributes":{},"elements":{"name":"mml:condition","content":{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs"]}}},"mml:conjugate":{"name":"mml:conjugate","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:conjugate","content":{"type":",","blocks":[]}}},"mml:cos":{"name":"mml:cos","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:cos","content":{"type":",","blocks":[]}}},"mml:cosh":{"name":"mml:cosh","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:cosh","content":{"type":",","blocks":[]}}},"mml:cot":{"name":"mml:cot","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:cot","content":{"type":",","blocks":[]}}},"mml:coth":{"name":"mml:coth","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:coth","content":{"type":",","blocks":[]}}},"mml:cs":{"name":"mml:cs","type":"text","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:cs","content":"TEXT"}},"mml:csc":{"name":"mml:csc","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:csc","content":{"type":",","blocks":[]}}},"mml:csch":{"name":"mml:csch","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:csch","content":{"type":",","blocks":[]}}},"mml:csymbol":{"name":"mml:csymbol","type":"text","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"},"type":{"name":"type"},"cd":{"name":"cd"}},"elements":{"name":"mml:csymbol","content":{"type":"*","block":{"type":"|","blocks":["TEXT","mml:mglyph","mml:mi","mml:mn","mml:mo","mml:mtext","mml:mspace","mml:ms","mml:maligngroup","mml:malignmark","mml:mrow","mml:mfrac","mml:msqrt","mml:mroot","mml:mstyle","mml:merror","mml:mpadded","mml:mphantom","mml:mfenced","mml:menclose","mml:msub","mml:msup","mml:msubsup","mml:munder","mml:mover","mml:munderover","mml:mmultiscripts","mml:mtable","mml:mstack","mml:mlongdiv","mml:maction"]}}}},"mml:curl":{"name":"mml:curl","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:curl","content":{"type":",","blocks":[]}}},"mml:declare":{"name":"mml:declare","type":"element","attributes":{"type":{"name":"type"},"scope":{"name":"scope"},"nargs":{"name":"nargs"},"occurrence":{"name":"occurrence"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:declare","content":{"type":"+","block":{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs"]}}}},"mml:degree":{"name":"mml:degree","type":"element","attributes":{},"elements":{"name":"mml:degree","content":{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs"]}}},"mml:determinant":{"name":"mml:determinant","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:determinant","content":{"type":",","blocks":[]}}},"mml:diff":{"name":"mml:diff","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:diff","content":{"type":",","blocks":[]}}},"mml:divergence":{"name":"mml:divergence","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:divergence","content":{"type":",","blocks":[]}}},"mml:divide":{"name":"mml:divide","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:divide","content":{"type":",","blocks":[]}}},"mml:domain":{"name":"mml:domain","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:domain","content":{"type":",","blocks":[]}}},"mml:domainofapplication":{"name":"mml:domainofapplication","type":"element","attributes":{},"elements":{"name":"mml:domainofapplication","content":{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs"]}}},"mml:emptyset":{"name":"mml:emptyset","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:emptyset","content":{"type":",","blocks":[]}}},"mml:eq":{"name":"mml:eq","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:eq","content":{"type":",","blocks":[]}}},"mml:equivalent":{"name":"mml:equivalent","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:equivalent","content":{"type":",","blocks":[]}}},"mml:eulergamma":{"name":"mml:eulergamma","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:eulergamma","content":{"type":",","blocks":[]}}},"mml:exists":{"name":"mml:exists","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:exists","content":{"type":",","blocks":[]}}},"mml:exp":{"name":"mml:exp","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:exp","content":{"type":",","blocks":[]}}},"mml:exponentiale":{"name":"mml:exponentiale","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:exponentiale","content":{"type":",","blocks":[]}}},"mml:factorial":{"name":"mml:factorial","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:factorial","content":{"type":",","blocks":[]}}},"mml:factorof":{"name":"mml:factorof","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:factorof","content":{"type":",","blocks":[]}}},"mml:false":{"name":"mml:false","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:false","content":{"type":",","blocks":[]}}},"mml:floor":{"name":"mml:floor","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:floor","content":{"type":",","blocks":[]}}},"mml:fn":{"name":"mml:fn","type":"element","attributes":{},"elements":{"name":"mml:fn","content":{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs"]}}},"mml:forall":{"name":"mml:forall","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:forall","content":{"type":",","blocks":[]}}},"mml:gcd":{"name":"mml:gcd","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:gcd","content":{"type":",","blocks":[]}}},"mml:geq":{"name":"mml:geq","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:geq","content":{"type":",","blocks":[]}}},"mml:grad":{"name":"mml:grad","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:grad","content":{"type":",","blocks":[]}}},"mml:gt":{"name":"mml:gt","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:gt","content":{"type":",","blocks":[]}}},"mml:ident":{"name":"mml:ident","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:ident","content":{"type":",","blocks":[]}}},"mml:image":{"name":"mml:image","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:image","content":{"type":",","blocks":[]}}},"mml:imaginary":{"name":"mml:imaginary","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:imaginary","content":{"type":",","blocks":[]}}},"mml:imaginaryi":{"name":"mml:imaginaryi","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:imaginaryi","content":{"type":",","blocks":[]}}},"mml:implies":{"name":"mml:implies","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:implies","content":{"type":",","blocks":[]}}},"mml:in":{"name":"mml:in","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:in","content":{"type":",","blocks":[]}}},"mml:infinity":{"name":"mml:infinity","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:infinity","content":{"type":",","blocks":[]}}},"mml:int":{"name":"mml:int","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:int","content":{"type":",","blocks":[]}}},"mml:integers":{"name":"mml:integers","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:integers","content":{"type":",","blocks":[]}}},"mml:intersect":{"name":"mml:intersect","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:intersect","content":{"type":",","blocks":[]}}},"mml:interval":{"name":"mml:interval","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"},"closure":{"name":"closure"}},"elements":{"name":"mml:interval","content":{"type":",","blocks":[{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs"]},{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs"]}]}}},"mml:inverse":{"name":"mml:inverse","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:inverse","content":{"type":",","blocks":[]}}},"mml:lambda":{"name":"mml:lambda","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:lambda","content":{"type":",","blocks":[{"type":"*","block":"mml:bvar"},{"type":"*","block":{"type":"|","blocks":["mml:domainofapplication","mml:condition",{"type":",","blocks":["mml:lowlimit",{"type":"?","block":"mml:uplimit"}]}]}},{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs"]}]}}},"mml:laplacian":{"name":"mml:laplacian","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:laplacian","content":{"type":",","blocks":[]}}},"mml:lcm":{"name":"mml:lcm","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:lcm","content":{"type":",","blocks":[]}}},"mml:leq":{"name":"mml:leq","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:leq","content":{"type":",","blocks":[]}}},"mml:limit":{"name":"mml:limit","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:limit","content":{"type":",","blocks":[]}}},"mml:list":{"name":"mml:list","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"},"order":{"name":"order"}},"elements":{"name":"mml:list","content":{"type":",","blocks":[{"type":"*","block":{"type":"*","block":"mml:bvar"}},{"type":"*","block":{"type":"*","block":{"type":"|","blocks":["mml:domainofapplication","mml:condition",{"type":",","blocks":["mml:lowlimit",{"type":"?","block":"mml:uplimit"}]}]}}},{"type":"*","block":{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs"]}}]}}},"mml:ln":{"name":"mml:ln","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:ln","content":{"type":",","blocks":[]}}},"mml:log":{"name":"mml:log","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:log","content":{"type":",","blocks":[]}}},"mml:logbase":{"name":"mml:logbase","type":"element","attributes":{},"elements":{"name":"mml:logbase","content":{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs"]}}},"mml:lowlimit":{"name":"mml:lowlimit","type":"element","attributes":{},"elements":{"name":"mml:lowlimit","content":{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs"]}}},"mml:lt":{"name":"mml:lt","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:lt","content":{"type":",","blocks":[]}}},"mml:maction":{"name":"mml:maction","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"mathcolor":{"name":"mathcolor"},"mathbackground":{"name":"mathbackground"},"actiontype":{"name":"actiontype"},"selection":{"name":"selection"}},"elements":{"name":"mml:maction","content":{"type":"+","block":{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs","mml:mi","mml:mn","mml:mo","mml:mtext","mml:mspace","mml:ms","mml:maligngroup","mml:malignmark","mml:mrow","mml:mfrac","mml:msqrt","mml:mroot","mml:mstyle","mml:merror","mml:mpadded","mml:mphantom","mml:mfenced","mml:menclose","mml:msub","mml:msup","mml:msubsup","mml:munder","mml:mover","mml:munderover","mml:mmultiscripts","mml:mtable","mml:mstack","mml:mlongdiv","mml:maction"]}}}},"mml:maligngroup":{"name":"mml:maligngroup","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"mathcolor":{"name":"mathcolor"},"mathbackground":{"name":"mathbackground"},"groupalign":{"name":"groupalign"}},"elements":{"name":"mml:maligngroup","content":{"type":",","blocks":[]}}},"mml:malignmark":{"name":"mml:malignmark","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"mathcolor":{"name":"mathcolor"},"mathbackground":{"name":"mathbackground"},"edge":{"name":"edge"}},"elements":{"name":"mml:malignmark","content":{"type":",","blocks":[]}}},"mml:math":{"name":"mml:math","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"display":{"name":"display"},"maxwidth":{"name":"maxwidth"},"overflow":{"name":"overflow"},"altimg":{"name":"altimg"},"altimg-width":{"name":"altimg-width"},"altimg-height":{"name":"altimg-height"},"altimg-valign":{"name":"altimg-valign"},"alttext":{"name":"alttext"},"cdgroup":{"name":"cdgroup"},"mode":{"name":"mode"},"macros":{"name":"macros"},"mathcolor":{"name":"mathcolor"},"mathbackground":{"name":"mathbackground"},"scriptlevel":{"name":"scriptlevel"},"displaystyle":{"name":"displaystyle"},"scriptsizemultiplier":{"name":"scriptsizemultiplier"},"scriptminsize":{"name":"scriptminsize"},"infixlinebreakstyle":{"name":"infixlinebreakstyle"},"decimalpoint":{"name":"decimalpoint"},"accent":{"name":"accent"},"accentunder":{"name":"accentunder"},"align":{"name":"align"},"alignmentscope":{"name":"alignmentscope"},"bevelled":{"name":"bevelled"},"charalign":{"name":"charalign"},"charspacing":{"name":"charspacing"},"close":{"name":"close"},"columnalign":{"name":"columnalign"},"columnlines":{"name":"columnlines"},"columnspacing":{"name":"columnspacing"},"columnspan":{"name":"columnspan"},"columnwidth":{"name":"columnwidth"},"crossout":{"name":"crossout"},"denomalign":{"name":"denomalign"},"depth":{"name":"depth"},"dir":{"name":"dir"},"edge":{"name":"edge"},"equalcolumns":{"name":"equalcolumns"},"equalrows":{"name":"equalrows"},"fence":{"name":"fence"},"form":{"name":"form"},"frame":{"name":"frame"},"framespacing":{"name":"framespacing"},"groupalign":{"name":"groupalign"},"height":{"name":"height"},"indentalign":{"name":"indentalign"},"indentalignfirst":{"name":"indentalignfirst"},"indentalignlast":{"name":"indentalignlast"},"indentshift":{"name":"indentshift"},"indentshiftfirst":{"name":"indentshiftfirst"},"indentshiftlast":{"name":"indentshiftlast"},"indenttarget":{"name":"indenttarget"},"largeop":{"name":"largeop"},"leftoverhang":{"name":"leftoverhang"},"length":{"name":"length"},"linebreak":{"name":"linebreak"},"linebreakmultchar":{"name":"linebreakmultchar"},"linebreakstyle":{"name":"linebreakstyle"},"lineleading":{"name":"lineleading"},"linethickness":{"name":"linethickness"},"location":{"name":"location"},"longdivstyle":{"name":"longdivstyle"},"lquote":{"name":"lquote"},"lspace":{"name":"lspace"},"mathsize":{"name":"mathsize"},"mathvariant":{"name":"mathvariant"},"maxsize":{"name":"maxsize"},"minlabelspacing":{"name":"minlabelspacing"},"minsize":{"name":"minsize"},"movablelimits":{"name":"movablelimits"},"mslinethickness":{"name":"mslinethickness"},"notation":{"name":"notation"},"numalign":{"name":"numalign"},"open":{"name":"open"},"position":{"name":"position"},"rightoverhang":{"name":"rightoverhang"},"rowalign":{"name":"rowalign"},"rowlines":{"name":"rowlines"},"rowspacing":{"name":"rowspacing"},"rowspan":{"name":"rowspan"},"rquote":{"name":"rquote"},"rspace":{"name":"rspace"},"selection":{"name":"selection"},"separator":{"name":"separator"},"separators":{"name":"separators"},"shift":{"name":"shift"},"side":{"name":"side"},"stackalign":{"name":"stackalign"},"stretchy":{"name":"stretchy"},"subscriptshift":{"name":"subscriptshift"},"superscriptshift":{"name":"superscriptshift"},"symmetric":{"name":"symmetric"},"valign":{"name":"valign"},"width":{"name":"width"}},"elements":{"name":"mml:math","content":{"type":"*","block":{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs","mml:mi","mml:mn","mml:mo","mml:mtext","mml:mspace","mml:ms","mml:maligngroup","mml:malignmark","mml:mrow","mml:mfrac","mml:msqrt","mml:mroot","mml:mstyle","mml:merror","mml:mpadded","mml:mphantom","mml:mfenced","mml:menclose","mml:msub","mml:msup","mml:msubsup","mml:munder","mml:mover","mml:munderover","mml:mmultiscripts","mml:mtable","mml:mstack","mml:mlongdiv","mml:maction"]}}}},"mml:matrix":{"name":"mml:matrix","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:matrix","content":{"type":",","blocks":[{"type":"*","block":"mml:bvar"},{"type":"*","block":{"type":"|","blocks":["mml:domainofapplication","mml:condition",{"type":",","blocks":["mml:lowlimit",{"type":"?","block":"mml:uplimit"}]}]}},{"type":"*","block":{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs"]}}]}}},"mml:matrixrow":{"name":"mml:matrixrow","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:matrixrow","content":{"type":",","blocks":[{"type":"*","block":"mml:bvar"},{"type":"*","block":{"type":"|","blocks":["mml:domainofapplication","mml:condition",{"type":",","blocks":["mml:lowlimit",{"type":"?","block":"mml:uplimit"}]}]}},{"type":"*","block":{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs"]}}]}}},"mml:max":{"name":"mml:max","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:max","content":{"type":",","blocks":[]}}},"mml:mean":{"name":"mml:mean","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:mean","content":{"type":",","blocks":[]}}},"mml:median":{"name":"mml:median","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:median","content":{"type":",","blocks":[]}}},"mml:menclose":{"name":"mml:menclose","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"mathcolor":{"name":"mathcolor"},"mathbackground":{"name":"mathbackground"},"notation":{"name":"notation"}},"elements":{"name":"mml:menclose","content":{"type":"*","block":{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs","mml:mi","mml:mn","mml:mo","mml:mtext","mml:mspace","mml:ms","mml:maligngroup","mml:malignmark","mml:mrow","mml:mfrac","mml:msqrt","mml:mroot","mml:mstyle","mml:merror","mml:mpadded","mml:mphantom","mml:mfenced","mml:menclose","mml:msub","mml:msup","mml:msubsup","mml:munder","mml:mover","mml:munderover","mml:mmultiscripts","mml:mtable","mml:mstack","mml:mlongdiv","mml:maction"]}}}},"mml:merror":{"name":"mml:merror","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"mathcolor":{"name":"mathcolor"},"mathbackground":{"name":"mathbackground"}},"elements":{"name":"mml:merror","content":{"type":"*","block":{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs","mml:mi","mml:mn","mml:mo","mml:mtext","mml:mspace","mml:ms","mml:maligngroup","mml:malignmark","mml:mrow","mml:mfrac","mml:msqrt","mml:mroot","mml:mstyle","mml:merror","mml:mpadded","mml:mphantom","mml:mfenced","mml:menclose","mml:msub","mml:msup","mml:msubsup","mml:munder","mml:mover","mml:munderover","mml:mmultiscripts","mml:mtable","mml:mstack","mml:mlongdiv","mml:maction"]}}}},"mml:mfenced":{"name":"mml:mfenced","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"mathcolor":{"name":"mathcolor"},"mathbackground":{"name":"mathbackground"},"open":{"name":"open"},"close":{"name":"close"},"separators":{"name":"separators"}},"elements":{"name":"mml:mfenced","content":{"type":"*","block":{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs","mml:mi","mml:mn","mml:mo","mml:mtext","mml:mspace","mml:ms","mml:maligngroup","mml:malignmark","mml:mrow","mml:mfrac","mml:msqrt","mml:mroot","mml:mstyle","mml:merror","mml:mpadded","mml:mphantom","mml:mfenced","mml:menclose","mml:msub","mml:msup","mml:msubsup","mml:munder","mml:mover","mml:munderover","mml:mmultiscripts","mml:mtable","mml:mstack","mml:mlongdiv","mml:maction"]}}}},"mml:mfrac":{"name":"mml:mfrac","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"mathcolor":{"name":"mathcolor"},"mathbackground":{"name":"mathbackground"},"linethickness":{"name":"linethickness"},"numalign":{"name":"numalign"},"denomalign":{"name":"denomalign"},"bevelled":{"name":"bevelled"}},"elements":{"name":"mml:mfrac","content":{"type":",","blocks":[{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs","mml:mi","mml:mn","mml:mo","mml:mtext","mml:mspace","mml:ms","mml:maligngroup","mml:malignmark","mml:mrow","mml:mfrac","mml:msqrt","mml:mroot","mml:mstyle","mml:merror","mml:mpadded","mml:mphantom","mml:mfenced","mml:menclose","mml:msub","mml:msup","mml:msubsup","mml:munder","mml:mover","mml:munderover","mml:mmultiscripts","mml:mtable","mml:mstack","mml:mlongdiv","mml:maction"]},{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs","mml:mi","mml:mn","mml:mo","mml:mtext","mml:mspace","mml:ms","mml:maligngroup","mml:malignmark","mml:mrow","mml:mfrac","mml:msqrt","mml:mroot","mml:mstyle","mml:merror","mml:mpadded","mml:mphantom","mml:mfenced","mml:menclose","mml:msub","mml:msup","mml:msubsup","mml:munder","mml:mover","mml:munderover","mml:mmultiscripts","mml:mtable","mml:mstack","mml:mlongdiv","mml:maction"]}]}}},"mml:mglyph":{"name":"mml:mglyph","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"mathcolor":{"name":"mathcolor"},"mathbackground":{"name":"mathbackground"},"src":{"name":"src"},"width":{"name":"width"},"height":{"name":"height"},"valign":{"name":"valign"},"alt":{"name":"alt"},"index":{"name":"index"},"mathvariant":{"name":"mathvariant"},"mathsize":{"name":"mathsize"},"fontfamily":{"name":"fontfamily"},"fontweight":{"name":"fontweight"},"fontstyle":{"name":"fontstyle"},"fontsize":{"name":"fontsize"},"color":{"name":"color"},"background":{"name":"background"}},"elements":{"name":"mml:mglyph","content":{"type":",","blocks":[]}}},"mml:mi":{"name":"mml:mi","type":"text","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"mathcolor":{"name":"mathcolor"},"mathbackground":{"name":"mathbackground"},"mathvariant":{"name":"mathvariant"},"mathsize":{"name":"mathsize"},"dir":{"name":"dir"},"fontfamily":{"name":"fontfamily"},"fontweight":{"name":"fontweight"},"fontstyle":{"name":"fontstyle"},"fontsize":{"name":"fontsize"},"color":{"name":"color"},"background":{"name":"background"}},"elements":{"name":"mml:mi","content":{"type":"*","block":{"type":"|","blocks":["TEXT","mml:mglyph","mml:malignmark"]}}}},"mml:min":{"name":"mml:min","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:min","content":{"type":",","blocks":[]}}},"mml:minus":{"name":"mml:minus","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:minus","content":{"type":",","blocks":[]}}},"mml:mlabeledtr":{"name":"mml:mlabeledtr","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"mathcolor":{"name":"mathcolor"},"mathbackground":{"name":"mathbackground"},"rowalign":{"name":"rowalign"},"columnalign":{"name":"columnalign"},"groupalign":{"name":"groupalign"}},"elements":{"name":"mml:mlabeledtr","content":{"type":"+","block":"mml:mtd"}}},"mml:mlongdiv":{"name":"mml:mlongdiv","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"mathcolor":{"name":"mathcolor"},"mathbackground":{"name":"mathbackground"},"position":{"name":"position"},"shift":{"name":"shift"},"longdivstyle":{"name":"longdivstyle"}},"elements":{"name":"mml:mlongdiv","content":{"type":",","blocks":[{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs","mml:mi","mml:mn","mml:mo","mml:mtext","mml:mspace","mml:ms","mml:maligngroup","mml:malignmark","mml:mrow","mml:mfrac","mml:msqrt","mml:mroot","mml:mstyle","mml:merror","mml:mpadded","mml:mphantom","mml:mfenced","mml:menclose","mml:msub","mml:msup","mml:msubsup","mml:munder","mml:mover","mml:munderover","mml:mmultiscripts","mml:mtable","mml:mstack","mml:mlongdiv","mml:maction","mml:mscarries","mml:msline","mml:msrow","mml:msgroup"]},{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs","mml:mi","mml:mn","mml:mo","mml:mtext","mml:mspace","mml:ms","mml:maligngroup","mml:malignmark","mml:mrow","mml:mfrac","mml:msqrt","mml:mroot","mml:mstyle","mml:merror","mml:mpadded","mml:mphantom","mml:mfenced","mml:menclose","mml:msub","mml:msup","mml:msubsup","mml:munder","mml:mover","mml:munderover","mml:mmultiscripts","mml:mtable","mml:mstack","mml:mlongdiv","mml:maction","mml:mscarries","mml:msline","mml:msrow","mml:msgroup"]},{"type":"+","block":{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs","mml:mi","mml:mn","mml:mo","mml:mtext","mml:mspace","mml:ms","mml:maligngroup","mml:malignmark","mml:mrow","mml:mfrac","mml:msqrt","mml:mroot","mml:mstyle","mml:merror","mml:mpadded","mml:mphantom","mml:mfenced","mml:menclose","mml:msub","mml:msup","mml:msubsup","mml:munder","mml:mover","mml:munderover","mml:mmultiscripts","mml:mtable","mml:mstack","mml:mlongdiv","mml:maction","mml:mscarries","mml:msline","mml:msrow","mml:msgroup"]}}]}}},"mml:mmultiscripts":{"name":"mml:mmultiscripts","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"mathcolor":{"name":"mathcolor"},"mathbackground":{"name":"mathbackground"},"subscriptshift":{"name":"subscriptshift"},"superscriptshift":{"name":"superscriptshift"}},"elements":{"name":"mml:mmultiscripts","content":{"type":",","blocks":[{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs","mml:mi","mml:mn","mml:mo","mml:mtext","mml:mspace","mml:ms","mml:maligngroup","mml:malignmark","mml:mrow","mml:mfrac","mml:msqrt","mml:mroot","mml:mstyle","mml:merror","mml:mpadded","mml:mphantom","mml:mfenced","mml:menclose","mml:msub","mml:msup","mml:msubsup","mml:munder","mml:mover","mml:munderover","mml:mmultiscripts","mml:mtable","mml:mstack","mml:mlongdiv","mml:maction"]},{"type":"*","block":{"type":",","blocks":[{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs","mml:mi","mml:mn","mml:mo","mml:mtext","mml:mspace","mml:ms","mml:maligngroup","mml:malignmark","mml:mrow","mml:mfrac","mml:msqrt","mml:mroot","mml:mstyle","mml:merror","mml:mpadded","mml:mphantom","mml:mfenced","mml:menclose","mml:msub","mml:msup","mml:msubsup","mml:munder","mml:mover","mml:munderover","mml:mmultiscripts","mml:mtable","mml:mstack","mml:mlongdiv","mml:maction","mml:none"]},{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs","mml:mi","mml:mn","mml:mo","mml:mtext","mml:mspace","mml:ms","mml:maligngroup","mml:malignmark","mml:mrow","mml:mfrac","mml:msqrt","mml:mroot","mml:mstyle","mml:merror","mml:mpadded","mml:mphantom","mml:mfenced","mml:menclose","mml:msub","mml:msup","mml:msubsup","mml:munder","mml:mover","mml:munderover","mml:mmultiscripts","mml:mtable","mml:mstack","mml:mlongdiv","mml:maction","mml:none"]}]}},{"type":"?","block":{"type":",","blocks":["mml:mprescripts",{"type":"*","block":{"type":",","blocks":[{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs","mml:mi","mml:mn","mml:mo","mml:mtext","mml:mspace","mml:ms","mml:maligngroup","mml:malignmark","mml:mrow","mml:mfrac","mml:msqrt","mml:mroot","mml:mstyle","mml:merror","mml:mpadded","mml:mphantom","mml:mfenced","mml:menclose","mml:msub","mml:msup","mml:msubsup","mml:munder","mml:mover","mml:munderover","mml:mmultiscripts","mml:mtable","mml:mstack","mml:mlongdiv","mml:maction","mml:none"]},{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs","mml:mi","mml:mn","mml:mo","mml:mtext","mml:mspace","mml:ms","mml:maligngroup","mml:malignmark","mml:mrow","mml:mfrac","mml:msqrt","mml:mroot","mml:mstyle","mml:merror","mml:mpadded","mml:mphantom","mml:mfenced","mml:menclose","mml:msub","mml:msup","mml:msubsup","mml:munder","mml:mover","mml:munderover","mml:mmultiscripts","mml:mtable","mml:mstack","mml:mlongdiv","mml:maction","mml:none"]}]}}]}}]}}},"mml:mn":{"name":"mml:mn","type":"text","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"mathcolor":{"name":"mathcolor"},"mathbackground":{"name":"mathbackground"},"mathvariant":{"name":"mathvariant"},"mathsize":{"name":"mathsize"},"dir":{"name":"dir"},"fontfamily":{"name":"fontfamily"},"fontweight":{"name":"fontweight"},"fontstyle":{"name":"fontstyle"},"fontsize":{"name":"fontsize"},"color":{"name":"color"},"background":{"name":"background"}},"elements":{"name":"mml:mn","content":{"type":"*","block":{"type":"|","blocks":["TEXT","mml:mglyph","mml:malignmark"]}}}},"mml:mo":{"name":"mml:mo","type":"text","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"mathcolor":{"name":"mathcolor"},"mathbackground":{"name":"mathbackground"},"mathvariant":{"name":"mathvariant"},"mathsize":{"name":"mathsize"},"dir":{"name":"dir"},"fontfamily":{"name":"fontfamily"},"fontweight":{"name":"fontweight"},"fontstyle":{"name":"fontstyle"},"fontsize":{"name":"fontsize"},"color":{"name":"color"},"background":{"name":"background"},"form":{"name":"form"},"fence":{"name":"fence"},"separator":{"name":"separator"},"lspace":{"name":"lspace"},"rspace":{"name":"rspace"},"stretchy":{"name":"stretchy"},"symmetric":{"name":"symmetric"},"maxsize":{"name":"maxsize"},"minsize":{"name":"minsize"},"largeop":{"name":"largeop"},"movablelimits":{"name":"movablelimits"},"accent":{"name":"accent"},"linebreak":{"name":"linebreak"},"lineleading":{"name":"lineleading"},"linebreakstyle":{"name":"linebreakstyle"},"linebreakmultchar":{"name":"linebreakmultchar"},"indentalign":{"name":"indentalign"},"indentshift":{"name":"indentshift"},"indenttarget":{"name":"indenttarget"},"indentalignfirst":{"name":"indentalignfirst"},"indentshiftfirst":{"name":"indentshiftfirst"},"indentalignlast":{"name":"indentalignlast"},"indentshiftlast":{"name":"indentshiftlast"}},"elements":{"name":"mml:mo","content":{"type":"*","block":{"type":"|","blocks":["TEXT","mml:mglyph","mml:malignmark"]}}}},"mml:mode":{"name":"mml:mode","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:mode","content":{"type":",","blocks":[]}}},"mml:moment":{"name":"mml:moment","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:moment","content":{"type":",","blocks":[]}}},"mml:momentabout":{"name":"mml:momentabout","type":"element","attributes":{},"elements":{"name":"mml:momentabout","content":{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs"]}}},"mml:mover":{"name":"mml:mover","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"mathcolor":{"name":"mathcolor"},"mathbackground":{"name":"mathbackground"},"accent":{"name":"accent"},"align":{"name":"align"}},"elements":{"name":"mml:mover","content":{"type":",","blocks":[{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs","mml:mi","mml:mn","mml:mo","mml:mtext","mml:mspace","mml:ms","mml:maligngroup","mml:malignmark","mml:mrow","mml:mfrac","mml:msqrt","mml:mroot","mml:mstyle","mml:merror","mml:mpadded","mml:mphantom","mml:mfenced","mml:menclose","mml:msub","mml:msup","mml:msubsup","mml:munder","mml:mover","mml:munderover","mml:mmultiscripts","mml:mtable","mml:mstack","mml:mlongdiv","mml:maction"]},{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs","mml:mi","mml:mn","mml:mo","mml:mtext","mml:mspace","mml:ms","mml:maligngroup","mml:malignmark","mml:mrow","mml:mfrac","mml:msqrt","mml:mroot","mml:mstyle","mml:merror","mml:mpadded","mml:mphantom","mml:mfenced","mml:menclose","mml:msub","mml:msup","mml:msubsup","mml:munder","mml:mover","mml:munderover","mml:mmultiscripts","mml:mtable","mml:mstack","mml:mlongdiv","mml:maction"]}]}}},"mml:mpadded":{"name":"mml:mpadded","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"mathcolor":{"name":"mathcolor"},"mathbackground":{"name":"mathbackground"},"height":{"name":"height"},"depth":{"name":"depth"},"width":{"name":"width"},"lspace":{"name":"lspace"},"voffset":{"name":"voffset"}},"elements":{"name":"mml:mpadded","content":{"type":"*","block":{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs","mml:mi","mml:mn","mml:mo","mml:mtext","mml:mspace","mml:ms","mml:maligngroup","mml:malignmark","mml:mrow","mml:mfrac","mml:msqrt","mml:mroot","mml:mstyle","mml:merror","mml:mpadded","mml:mphantom","mml:mfenced","mml:menclose","mml:msub","mml:msup","mml:msubsup","mml:munder","mml:mover","mml:munderover","mml:mmultiscripts","mml:mtable","mml:mstack","mml:mlongdiv","mml:maction"]}}}},"mml:mphantom":{"name":"mml:mphantom","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"mathcolor":{"name":"mathcolor"},"mathbackground":{"name":"mathbackground"}},"elements":{"name":"mml:mphantom","content":{"type":"*","block":{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs","mml:mi","mml:mn","mml:mo","mml:mtext","mml:mspace","mml:ms","mml:maligngroup","mml:malignmark","mml:mrow","mml:mfrac","mml:msqrt","mml:mroot","mml:mstyle","mml:merror","mml:mpadded","mml:mphantom","mml:mfenced","mml:menclose","mml:msub","mml:msup","mml:msubsup","mml:munder","mml:mover","mml:munderover","mml:mmultiscripts","mml:mtable","mml:mstack","mml:mlongdiv","mml:maction"]}}}},"mml:mprescripts":{"name":"mml:mprescripts","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"mathcolor":{"name":"mathcolor"},"mathbackground":{"name":"mathbackground"}},"elements":{"name":"mml:mprescripts","content":{"type":",","blocks":[]}}},"mml:mroot":{"name":"mml:mroot","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"mathcolor":{"name":"mathcolor"},"mathbackground":{"name":"mathbackground"}},"elements":{"name":"mml:mroot","content":{"type":",","blocks":[{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs","mml:mi","mml:mn","mml:mo","mml:mtext","mml:mspace","mml:ms","mml:maligngroup","mml:malignmark","mml:mrow","mml:mfrac","mml:msqrt","mml:mroot","mml:mstyle","mml:merror","mml:mpadded","mml:mphantom","mml:mfenced","mml:menclose","mml:msub","mml:msup","mml:msubsup","mml:munder","mml:mover","mml:munderover","mml:mmultiscripts","mml:mtable","mml:mstack","mml:mlongdiv","mml:maction"]},{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs","mml:mi","mml:mn","mml:mo","mml:mtext","mml:mspace","mml:ms","mml:maligngroup","mml:malignmark","mml:mrow","mml:mfrac","mml:msqrt","mml:mroot","mml:mstyle","mml:merror","mml:mpadded","mml:mphantom","mml:mfenced","mml:menclose","mml:msub","mml:msup","mml:msubsup","mml:munder","mml:mover","mml:munderover","mml:mmultiscripts","mml:mtable","mml:mstack","mml:mlongdiv","mml:maction"]}]}}},"mml:mrow":{"name":"mml:mrow","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"mathcolor":{"name":"mathcolor"},"mathbackground":{"name":"mathbackground"},"dir":{"name":"dir"}},"elements":{"name":"mml:mrow","content":{"type":"*","block":{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs","mml:mi","mml:mn","mml:mo","mml:mtext","mml:mspace","mml:ms","mml:maligngroup","mml:malignmark","mml:mrow","mml:mfrac","mml:msqrt","mml:mroot","mml:mstyle","mml:merror","mml:mpadded","mml:mphantom","mml:mfenced","mml:menclose","mml:msub","mml:msup","mml:msubsup","mml:munder","mml:mover","mml:munderover","mml:mmultiscripts","mml:mtable","mml:mstack","mml:mlongdiv","mml:maction"]}}}},"mml:ms":{"name":"mml:ms","type":"text","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"mathcolor":{"name":"mathcolor"},"mathbackground":{"name":"mathbackground"},"mathvariant":{"name":"mathvariant"},"mathsize":{"name":"mathsize"},"dir":{"name":"dir"},"fontfamily":{"name":"fontfamily"},"fontweight":{"name":"fontweight"},"fontstyle":{"name":"fontstyle"},"fontsize":{"name":"fontsize"},"color":{"name":"color"},"background":{"name":"background"},"lquote":{"name":"lquote"},"rquote":{"name":"rquote"}},"elements":{"name":"mml:ms","content":{"type":"*","block":{"type":"|","blocks":["TEXT","mml:mglyph","mml:malignmark"]}}}},"mml:mscarries":{"name":"mml:mscarries","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"mathcolor":{"name":"mathcolor"},"mathbackground":{"name":"mathbackground"},"position":{"name":"position"},"location":{"name":"location"},"crossout":{"name":"crossout"},"scriptsizemultiplier":{"name":"scriptsizemultiplier"}},"elements":{"name":"mml:mscarries","content":{"type":"*","block":{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs","mml:mi","mml:mn","mml:mo","mml:mtext","mml:mspace","mml:ms","mml:maligngroup","mml:malignmark","mml:mrow","mml:mfrac","mml:msqrt","mml:mroot","mml:mstyle","mml:merror","mml:mpadded","mml:mphantom","mml:mfenced","mml:menclose","mml:msub","mml:msup","mml:msubsup","mml:munder","mml:mover","mml:munderover","mml:mmultiscripts","mml:mtable","mml:mstack","mml:mlongdiv","mml:maction","mml:none","mml:mscarry"]}}}},"mml:mscarry":{"name":"mml:mscarry","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"mathcolor":{"name":"mathcolor"},"mathbackground":{"name":"mathbackground"},"location":{"name":"location"},"crossout":{"name":"crossout"}},"elements":{"name":"mml:mscarry","content":{"type":"*","block":{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs","mml:mi","mml:mn","mml:mo","mml:mtext","mml:mspace","mml:ms","mml:maligngroup","mml:malignmark","mml:mrow","mml:mfrac","mml:msqrt","mml:mroot","mml:mstyle","mml:merror","mml:mpadded","mml:mphantom","mml:mfenced","mml:menclose","mml:msub","mml:msup","mml:msubsup","mml:munder","mml:mover","mml:munderover","mml:mmultiscripts","mml:mtable","mml:mstack","mml:mlongdiv","mml:maction","mml:none"]}}}},"mml:msgroup":{"name":"mml:msgroup","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"mathcolor":{"name":"mathcolor"},"mathbackground":{"name":"mathbackground"},"position":{"name":"position"},"shift":{"name":"shift"}},"elements":{"name":"mml:msgroup","content":{"type":"*","block":{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs","mml:mi","mml:mn","mml:mo","mml:mtext","mml:mspace","mml:ms","mml:maligngroup","mml:malignmark","mml:mrow","mml:mfrac","mml:msqrt","mml:mroot","mml:mstyle","mml:merror","mml:mpadded","mml:mphantom","mml:mfenced","mml:menclose","mml:msub","mml:msup","mml:msubsup","mml:munder","mml:mover","mml:munderover","mml:mmultiscripts","mml:mtable","mml:mstack","mml:mlongdiv","mml:maction","mml:mscarries","mml:msline","mml:msrow","mml:msgroup"]}}}},"mml:msline":{"name":"mml:msline","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"mathcolor":{"name":"mathcolor"},"mathbackground":{"name":"mathbackground"},"position":{"name":"position"},"length":{"name":"length"},"leftoverhang":{"name":"leftoverhang"},"rightoverhang":{"name":"rightoverhang"},"mslinethickness":{"name":"mslinethickness"}},"elements":{"name":"mml:msline","content":{"type":",","blocks":[]}}},"mml:mspace":{"name":"mml:mspace","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"mathcolor":{"name":"mathcolor"},"mathbackground":{"name":"mathbackground"},"mathvariant":{"name":"mathvariant"},"mathsize":{"name":"mathsize"},"dir":{"name":"dir"},"fontfamily":{"name":"fontfamily"},"fontweight":{"name":"fontweight"},"fontstyle":{"name":"fontstyle"},"fontsize":{"name":"fontsize"},"color":{"name":"color"},"background":{"name":"background"},"width":{"name":"width"},"height":{"name":"height"},"depth":{"name":"depth"},"linebreak":{"name":"linebreak"}},"elements":{"name":"mml:mspace","content":{"type":",","blocks":[]}}},"mml:msqrt":{"name":"mml:msqrt","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"mathcolor":{"name":"mathcolor"},"mathbackground":{"name":"mathbackground"}},"elements":{"name":"mml:msqrt","content":{"type":"*","block":{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs","mml:mi","mml:mn","mml:mo","mml:mtext","mml:mspace","mml:ms","mml:maligngroup","mml:malignmark","mml:mrow","mml:mfrac","mml:msqrt","mml:mroot","mml:mstyle","mml:merror","mml:mpadded","mml:mphantom","mml:mfenced","mml:menclose","mml:msub","mml:msup","mml:msubsup","mml:munder","mml:mover","mml:munderover","mml:mmultiscripts","mml:mtable","mml:mstack","mml:mlongdiv","mml:maction"]}}}},"mml:msrow":{"name":"mml:msrow","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"mathcolor":{"name":"mathcolor"},"mathbackground":{"name":"mathbackground"},"position":{"name":"position"}},"elements":{"name":"mml:msrow","content":{"type":"*","block":{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs","mml:mi","mml:mn","mml:mo","mml:mtext","mml:mspace","mml:ms","mml:maligngroup","mml:malignmark","mml:mrow","mml:mfrac","mml:msqrt","mml:mroot","mml:mstyle","mml:merror","mml:mpadded","mml:mphantom","mml:mfenced","mml:menclose","mml:msub","mml:msup","mml:msubsup","mml:munder","mml:mover","mml:munderover","mml:mmultiscripts","mml:mtable","mml:mstack","mml:mlongdiv","mml:maction","mml:none"]}}}},"mml:mstack":{"name":"mml:mstack","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"mathcolor":{"name":"mathcolor"},"mathbackground":{"name":"mathbackground"},"align":{"name":"align"},"stackalign":{"name":"stackalign"},"charalign":{"name":"charalign"},"charspacing":{"name":"charspacing"}},"elements":{"name":"mml:mstack","content":{"type":"*","block":{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs","mml:mi","mml:mn","mml:mo","mml:mtext","mml:mspace","mml:ms","mml:maligngroup","mml:malignmark","mml:mrow","mml:mfrac","mml:msqrt","mml:mroot","mml:mstyle","mml:merror","mml:mpadded","mml:mphantom","mml:mfenced","mml:menclose","mml:msub","mml:msup","mml:msubsup","mml:munder","mml:mover","mml:munderover","mml:mmultiscripts","mml:mtable","mml:mstack","mml:mlongdiv","mml:maction","mml:mscarries","mml:msline","mml:msrow","mml:msgroup"]}}}},"mml:mstyle":{"name":"mml:mstyle","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"mathcolor":{"name":"mathcolor"},"mathbackground":{"name":"mathbackground"},"scriptlevel":{"name":"scriptlevel"},"displaystyle":{"name":"displaystyle"},"scriptsizemultiplier":{"name":"scriptsizemultiplier"},"scriptminsize":{"name":"scriptminsize"},"infixlinebreakstyle":{"name":"infixlinebreakstyle"},"decimalpoint":{"name":"decimalpoint"},"accent":{"name":"accent"},"accentunder":{"name":"accentunder"},"align":{"name":"align"},"alignmentscope":{"name":"alignmentscope"},"bevelled":{"name":"bevelled"},"charalign":{"name":"charalign"},"charspacing":{"name":"charspacing"},"close":{"name":"close"},"columnalign":{"name":"columnalign"},"columnlines":{"name":"columnlines"},"columnspacing":{"name":"columnspacing"},"columnspan":{"name":"columnspan"},"columnwidth":{"name":"columnwidth"},"crossout":{"name":"crossout"},"denomalign":{"name":"denomalign"},"depth":{"name":"depth"},"dir":{"name":"dir"},"edge":{"name":"edge"},"equalcolumns":{"name":"equalcolumns"},"equalrows":{"name":"equalrows"},"fence":{"name":"fence"},"form":{"name":"form"},"frame":{"name":"frame"},"framespacing":{"name":"framespacing"},"groupalign":{"name":"groupalign"},"height":{"name":"height"},"indentalign":{"name":"indentalign"},"indentalignfirst":{"name":"indentalignfirst"},"indentalignlast":{"name":"indentalignlast"},"indentshift":{"name":"indentshift"},"indentshiftfirst":{"name":"indentshiftfirst"},"indentshiftlast":{"name":"indentshiftlast"},"indenttarget":{"name":"indenttarget"},"largeop":{"name":"largeop"},"leftoverhang":{"name":"leftoverhang"},"length":{"name":"length"},"linebreak":{"name":"linebreak"},"linebreakmultchar":{"name":"linebreakmultchar"},"linebreakstyle":{"name":"linebreakstyle"},"lineleading":{"name":"lineleading"},"linethickness":{"name":"linethickness"},"location":{"name":"location"},"longdivstyle":{"name":"longdivstyle"},"lquote":{"name":"lquote"},"lspace":{"name":"lspace"},"mathsize":{"name":"mathsize"},"mathvariant":{"name":"mathvariant"},"maxsize":{"name":"maxsize"},"minlabelspacing":{"name":"minlabelspacing"},"minsize":{"name":"minsize"},"movablelimits":{"name":"movablelimits"},"mslinethickness":{"name":"mslinethickness"},"notation":{"name":"notation"},"numalign":{"name":"numalign"},"open":{"name":"open"},"position":{"name":"position"},"rightoverhang":{"name":"rightoverhang"},"rowalign":{"name":"rowalign"},"rowlines":{"name":"rowlines"},"rowspacing":{"name":"rowspacing"},"rowspan":{"name":"rowspan"},"rquote":{"name":"rquote"},"rspace":{"name":"rspace"},"selection":{"name":"selection"},"separator":{"name":"separator"},"separators":{"name":"separators"},"shift":{"name":"shift"},"side":{"name":"side"},"stackalign":{"name":"stackalign"},"stretchy":{"name":"stretchy"},"subscriptshift":{"name":"subscriptshift"},"superscriptshift":{"name":"superscriptshift"},"symmetric":{"name":"symmetric"},"valign":{"name":"valign"},"width":{"name":"width"},"fontfamily":{"name":"fontfamily"},"fontweight":{"name":"fontweight"},"fontstyle":{"name":"fontstyle"},"fontsize":{"name":"fontsize"},"color":{"name":"color"},"background":{"name":"background"},"veryverythinmathspace":{"name":"veryverythinmathspace"},"verythinmathspace":{"name":"verythinmathspace"},"thinmathspace":{"name":"thinmathspace"},"mediummathspace":{"name":"mediummathspace"},"thickmathspace":{"name":"thickmathspace"},"verythickmathspace":{"name":"verythickmathspace"},"veryverythickmathspace":{"name":"veryverythickmathspace"}},"elements":{"name":"mml:mstyle","content":{"type":"*","block":{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs","mml:mi","mml:mn","mml:mo","mml:mtext","mml:mspace","mml:ms","mml:maligngroup","mml:malignmark","mml:mrow","mml:mfrac","mml:msqrt","mml:mroot","mml:mstyle","mml:merror","mml:mpadded","mml:mphantom","mml:mfenced","mml:menclose","mml:msub","mml:msup","mml:msubsup","mml:munder","mml:mover","mml:munderover","mml:mmultiscripts","mml:mtable","mml:mstack","mml:mlongdiv","mml:maction"]}}}},"mml:msub":{"name":"mml:msub","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"mathcolor":{"name":"mathcolor"},"mathbackground":{"name":"mathbackground"},"subscriptshift":{"name":"subscriptshift"}},"elements":{"name":"mml:msub","content":{"type":",","blocks":[{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs","mml:mi","mml:mn","mml:mo","mml:mtext","mml:mspace","mml:ms","mml:maligngroup","mml:malignmark","mml:mrow","mml:mfrac","mml:msqrt","mml:mroot","mml:mstyle","mml:merror","mml:mpadded","mml:mphantom","mml:mfenced","mml:menclose","mml:msub","mml:msup","mml:msubsup","mml:munder","mml:mover","mml:munderover","mml:mmultiscripts","mml:mtable","mml:mstack","mml:mlongdiv","mml:maction"]},{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs","mml:mi","mml:mn","mml:mo","mml:mtext","mml:mspace","mml:ms","mml:maligngroup","mml:malignmark","mml:mrow","mml:mfrac","mml:msqrt","mml:mroot","mml:mstyle","mml:merror","mml:mpadded","mml:mphantom","mml:mfenced","mml:menclose","mml:msub","mml:msup","mml:msubsup","mml:munder","mml:mover","mml:munderover","mml:mmultiscripts","mml:mtable","mml:mstack","mml:mlongdiv","mml:maction"]}]}}},"mml:msubsup":{"name":"mml:msubsup","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"mathcolor":{"name":"mathcolor"},"mathbackground":{"name":"mathbackground"},"subscriptshift":{"name":"subscriptshift"},"superscriptshift":{"name":"superscriptshift"}},"elements":{"name":"mml:msubsup","content":{"type":",","blocks":[{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs","mml:mi","mml:mn","mml:mo","mml:mtext","mml:mspace","mml:ms","mml:maligngroup","mml:malignmark","mml:mrow","mml:mfrac","mml:msqrt","mml:mroot","mml:mstyle","mml:merror","mml:mpadded","mml:mphantom","mml:mfenced","mml:menclose","mml:msub","mml:msup","mml:msubsup","mml:munder","mml:mover","mml:munderover","mml:mmultiscripts","mml:mtable","mml:mstack","mml:mlongdiv","mml:maction"]},{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs","mml:mi","mml:mn","mml:mo","mml:mtext","mml:mspace","mml:ms","mml:maligngroup","mml:malignmark","mml:mrow","mml:mfrac","mml:msqrt","mml:mroot","mml:mstyle","mml:merror","mml:mpadded","mml:mphantom","mml:mfenced","mml:menclose","mml:msub","mml:msup","mml:msubsup","mml:munder","mml:mover","mml:munderover","mml:mmultiscripts","mml:mtable","mml:mstack","mml:mlongdiv","mml:maction"]},{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs","mml:mi","mml:mn","mml:mo","mml:mtext","mml:mspace","mml:ms","mml:maligngroup","mml:malignmark","mml:mrow","mml:mfrac","mml:msqrt","mml:mroot","mml:mstyle","mml:merror","mml:mpadded","mml:mphantom","mml:mfenced","mml:menclose","mml:msub","mml:msup","mml:msubsup","mml:munder","mml:mover","mml:munderover","mml:mmultiscripts","mml:mtable","mml:mstack","mml:mlongdiv","mml:maction"]}]}}},"mml:msup":{"name":"mml:msup","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"mathcolor":{"name":"mathcolor"},"mathbackground":{"name":"mathbackground"},"superscriptshift":{"name":"superscriptshift"}},"elements":{"name":"mml:msup","content":{"type":",","blocks":[{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs","mml:mi","mml:mn","mml:mo","mml:mtext","mml:mspace","mml:ms","mml:maligngroup","mml:malignmark","mml:mrow","mml:mfrac","mml:msqrt","mml:mroot","mml:mstyle","mml:merror","mml:mpadded","mml:mphantom","mml:mfenced","mml:menclose","mml:msub","mml:msup","mml:msubsup","mml:munder","mml:mover","mml:munderover","mml:mmultiscripts","mml:mtable","mml:mstack","mml:mlongdiv","mml:maction"]},{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs","mml:mi","mml:mn","mml:mo","mml:mtext","mml:mspace","mml:ms","mml:maligngroup","mml:malignmark","mml:mrow","mml:mfrac","mml:msqrt","mml:mroot","mml:mstyle","mml:merror","mml:mpadded","mml:mphantom","mml:mfenced","mml:menclose","mml:msub","mml:msup","mml:msubsup","mml:munder","mml:mover","mml:munderover","mml:mmultiscripts","mml:mtable","mml:mstack","mml:mlongdiv","mml:maction"]}]}}},"mml:mtable":{"name":"mml:mtable","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"mathcolor":{"name":"mathcolor"},"mathbackground":{"name":"mathbackground"},"align":{"name":"align"},"rowalign":{"name":"rowalign"},"columnalign":{"name":"columnalign"},"groupalign":{"name":"groupalign"},"alignmentscope":{"name":"alignmentscope"},"columnwidth":{"name":"columnwidth"},"width":{"name":"width"},"rowspacing":{"name":"rowspacing"},"columnspacing":{"name":"columnspacing"},"rowlines":{"name":"rowlines"},"columnlines":{"name":"columnlines"},"frame":{"name":"frame"},"framespacing":{"name":"framespacing"},"equalrows":{"name":"equalrows"},"equalcolumns":{"name":"equalcolumns"},"displaystyle":{"name":"displaystyle"},"side":{"name":"side"},"minlabelspacing":{"name":"minlabelspacing"}},"elements":{"name":"mml:mtable","content":{"type":"*","block":{"type":"|","blocks":["mml:mtr","mml:mlabeledtr"]}}}},"mml:mtd":{"name":"mml:mtd","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"mathcolor":{"name":"mathcolor"},"mathbackground":{"name":"mathbackground"},"rowspan":{"name":"rowspan"},"columnspan":{"name":"columnspan"},"rowalign":{"name":"rowalign"},"columnalign":{"name":"columnalign"},"groupalign":{"name":"groupalign"}},"elements":{"name":"mml:mtd","content":{"type":"*","block":{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs","mml:mi","mml:mn","mml:mo","mml:mtext","mml:mspace","mml:ms","mml:maligngroup","mml:malignmark","mml:mrow","mml:mfrac","mml:msqrt","mml:mroot","mml:mstyle","mml:merror","mml:mpadded","mml:mphantom","mml:mfenced","mml:menclose","mml:msub","mml:msup","mml:msubsup","mml:munder","mml:mover","mml:munderover","mml:mmultiscripts","mml:mtable","mml:mstack","mml:mlongdiv","mml:maction"]}}}},"mml:mtext":{"name":"mml:mtext","type":"text","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"mathcolor":{"name":"mathcolor"},"mathbackground":{"name":"mathbackground"},"mathvariant":{"name":"mathvariant"},"mathsize":{"name":"mathsize"},"dir":{"name":"dir"},"fontfamily":{"name":"fontfamily"},"fontweight":{"name":"fontweight"},"fontstyle":{"name":"fontstyle"},"fontsize":{"name":"fontsize"},"color":{"name":"color"},"background":{"name":"background"}},"elements":{"name":"mml:mtext","content":{"type":"*","block":{"type":"|","blocks":["TEXT","mml:mglyph","mml:malignmark"]}}}},"mml:mtr":{"name":"mml:mtr","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"mathcolor":{"name":"mathcolor"},"mathbackground":{"name":"mathbackground"},"rowalign":{"name":"rowalign"},"columnalign":{"name":"columnalign"},"groupalign":{"name":"groupalign"}},"elements":{"name":"mml:mtr","content":{"type":"*","block":"mml:mtd"}}},"mml:munder":{"name":"mml:munder","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"mathcolor":{"name":"mathcolor"},"mathbackground":{"name":"mathbackground"},"accentunder":{"name":"accentunder"},"align":{"name":"align"}},"elements":{"name":"mml:munder","content":{"type":",","blocks":[{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs","mml:mi","mml:mn","mml:mo","mml:mtext","mml:mspace","mml:ms","mml:maligngroup","mml:malignmark","mml:mrow","mml:mfrac","mml:msqrt","mml:mroot","mml:mstyle","mml:merror","mml:mpadded","mml:mphantom","mml:mfenced","mml:menclose","mml:msub","mml:msup","mml:msubsup","mml:munder","mml:mover","mml:munderover","mml:mmultiscripts","mml:mtable","mml:mstack","mml:mlongdiv","mml:maction"]},{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs","mml:mi","mml:mn","mml:mo","mml:mtext","mml:mspace","mml:ms","mml:maligngroup","mml:malignmark","mml:mrow","mml:mfrac","mml:msqrt","mml:mroot","mml:mstyle","mml:merror","mml:mpadded","mml:mphantom","mml:mfenced","mml:menclose","mml:msub","mml:msup","mml:msubsup","mml:munder","mml:mover","mml:munderover","mml:mmultiscripts","mml:mtable","mml:mstack","mml:mlongdiv","mml:maction"]}]}}},"mml:munderover":{"name":"mml:munderover","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"mathcolor":{"name":"mathcolor"},"mathbackground":{"name":"mathbackground"},"accent":{"name":"accent"},"accentunder":{"name":"accentunder"},"align":{"name":"align"}},"elements":{"name":"mml:munderover","content":{"type":",","blocks":[{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs","mml:mi","mml:mn","mml:mo","mml:mtext","mml:mspace","mml:ms","mml:maligngroup","mml:malignmark","mml:mrow","mml:mfrac","mml:msqrt","mml:mroot","mml:mstyle","mml:merror","mml:mpadded","mml:mphantom","mml:mfenced","mml:menclose","mml:msub","mml:msup","mml:msubsup","mml:munder","mml:mover","mml:munderover","mml:mmultiscripts","mml:mtable","mml:mstack","mml:mlongdiv","mml:maction"]},{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs","mml:mi","mml:mn","mml:mo","mml:mtext","mml:mspace","mml:ms","mml:maligngroup","mml:malignmark","mml:mrow","mml:mfrac","mml:msqrt","mml:mroot","mml:mstyle","mml:merror","mml:mpadded","mml:mphantom","mml:mfenced","mml:menclose","mml:msub","mml:msup","mml:msubsup","mml:munder","mml:mover","mml:munderover","mml:mmultiscripts","mml:mtable","mml:mstack","mml:mlongdiv","mml:maction"]},{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs","mml:mi","mml:mn","mml:mo","mml:mtext","mml:mspace","mml:ms","mml:maligngroup","mml:malignmark","mml:mrow","mml:mfrac","mml:msqrt","mml:mroot","mml:mstyle","mml:merror","mml:mpadded","mml:mphantom","mml:mfenced","mml:menclose","mml:msub","mml:msup","mml:msubsup","mml:munder","mml:mover","mml:munderover","mml:mmultiscripts","mml:mtable","mml:mstack","mml:mlongdiv","mml:maction"]}]}}},"mml:naturalnumbers":{"name":"mml:naturalnumbers","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:naturalnumbers","content":{"type":",","blocks":[]}}},"mml:neq":{"name":"mml:neq","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:neq","content":{"type":",","blocks":[]}}},"mml:none":{"name":"mml:none","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"mathcolor":{"name":"mathcolor"},"mathbackground":{"name":"mathbackground"}},"elements":{"name":"mml:none","content":{"type":",","blocks":[]}}},"mml:not":{"name":"mml:not","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:not","content":{"type":",","blocks":[]}}},"mml:notanumber":{"name":"mml:notanumber","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:notanumber","content":{"type":",","blocks":[]}}},"mml:notin":{"name":"mml:notin","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:notin","content":{"type":",","blocks":[]}}},"mml:notprsubset":{"name":"mml:notprsubset","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:notprsubset","content":{"type":",","blocks":[]}}},"mml:notsubset":{"name":"mml:notsubset","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:notsubset","content":{"type":",","blocks":[]}}},"mml:or":{"name":"mml:or","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:or","content":{"type":",","blocks":[]}}},"mml:otherwise":{"name":"mml:otherwise","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:otherwise","content":{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs"]}}},"mml:outerproduct":{"name":"mml:outerproduct","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:outerproduct","content":{"type":",","blocks":[]}}},"mml:partialdiff":{"name":"mml:partialdiff","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:partialdiff","content":{"type":",","blocks":[]}}},"mml:pi":{"name":"mml:pi","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:pi","content":{"type":",","blocks":[]}}},"mml:piece":{"name":"mml:piece","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:piece","content":{"type":",","blocks":[{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs"]},{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs"]}]}}},"mml:piecewise":{"name":"mml:piecewise","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:piecewise","content":{"type":"*","block":{"type":"|","blocks":["mml:piece","mml:otherwise"]}}}},"mml:plus":{"name":"mml:plus","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:plus","content":{"type":",","blocks":[]}}},"mml:power":{"name":"mml:power","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:power","content":{"type":",","blocks":[]}}},"mml:primes":{"name":"mml:primes","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:primes","content":{"type":",","blocks":[]}}},"mml:product":{"name":"mml:product","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:product","content":{"type":",","blocks":[]}}},"mml:prsubset":{"name":"mml:prsubset","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:prsubset","content":{"type":",","blocks":[]}}},"mml:quotient":{"name":"mml:quotient","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:quotient","content":{"type":",","blocks":[]}}},"mml:rationals":{"name":"mml:rationals","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:rationals","content":{"type":",","blocks":[]}}},"mml:real":{"name":"mml:real","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:real","content":{"type":",","blocks":[]}}},"mml:reals":{"name":"mml:reals","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:reals","content":{"type":",","blocks":[]}}},"mml:reln":{"name":"mml:reln","type":"element","attributes":{},"elements":{"name":"mml:reln","content":{"type":"*","block":{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs"]}}}},"mml:rem":{"name":"mml:rem","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:rem","content":{"type":",","blocks":[]}}},"mml:root":{"name":"mml:root","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:root","content":{"type":",","blocks":[]}}},"mml:scalarproduct":{"name":"mml:scalarproduct","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:scalarproduct","content":{"type":",","blocks":[]}}},"mml:sdev":{"name":"mml:sdev","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:sdev","content":{"type":",","blocks":[]}}},"mml:sec":{"name":"mml:sec","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:sec","content":{"type":",","blocks":[]}}},"mml:sech":{"name":"mml:sech","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:sech","content":{"type":",","blocks":[]}}},"mml:selector":{"name":"mml:selector","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:selector","content":{"type":",","blocks":[]}}},"mml:semantics":{"name":"mml:semantics","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"},"cd":{"name":"cd"},"name":{"name":"name"}},"elements":{"name":"mml:semantics","content":{"type":",","blocks":[{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs","mml:mi","mml:mn","mml:mo","mml:mtext","mml:mspace","mml:ms","mml:maligngroup","mml:malignmark","mml:mrow","mml:mfrac","mml:msqrt","mml:mroot","mml:mstyle","mml:merror","mml:mpadded","mml:mphantom","mml:mfenced","mml:menclose","mml:msub","mml:msup","mml:msubsup","mml:munder","mml:mover","mml:munderover","mml:mmultiscripts","mml:mtable","mml:mstack","mml:mlongdiv","mml:maction"]},{"type":"*","block":{"type":"|","blocks":["mml:annotation","mml:annotation-xml"]}}]}}},"mml:sep":{"name":"mml:sep","type":"element","attributes":{},"elements":{"name":"mml:sep","content":{"type":",","blocks":[]}}},"mml:set":{"name":"mml:set","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"},"type":{"name":"type"}},"elements":{"name":"mml:set","content":{"type":",","blocks":[{"type":"*","block":{"type":"*","block":"mml:bvar"}},{"type":"*","block":{"type":"*","block":{"type":"|","blocks":["mml:domainofapplication","mml:condition",{"type":",","blocks":["mml:lowlimit",{"type":"?","block":"mml:uplimit"}]}]}}},{"type":"*","block":{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs"]}}]}}},"mml:setdiff":{"name":"mml:setdiff","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:setdiff","content":{"type":",","blocks":[]}}},"mml:share":{"name":"mml:share","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"src":{"name":"src"}},"elements":{"name":"mml:share","content":{"type":",","blocks":[]}}},"mml:sin":{"name":"mml:sin","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:sin","content":{"type":",","blocks":[]}}},"mml:sinh":{"name":"mml:sinh","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:sinh","content":{"type":",","blocks":[]}}},"mml:subset":{"name":"mml:subset","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:subset","content":{"type":",","blocks":[]}}},"mml:sum":{"name":"mml:sum","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:sum","content":{"type":",","blocks":[]}}},"mml:tan":{"name":"mml:tan","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:tan","content":{"type":",","blocks":[]}}},"mml:tanh":{"name":"mml:tanh","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:tanh","content":{"type":",","blocks":[]}}},"mml:tendsto":{"name":"mml:tendsto","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"},"type":{"name":"type"}},"elements":{"name":"mml:tendsto","content":{"type":",","blocks":[]}}},"mml:times":{"name":"mml:times","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:times","content":{"type":",","blocks":[]}}},"mml:transpose":{"name":"mml:transpose","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:transpose","content":{"type":",","blocks":[]}}},"mml:true":{"name":"mml:true","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:true","content":{"type":",","blocks":[]}}},"mml:union":{"name":"mml:union","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:union","content":{"type":",","blocks":[]}}},"mml:uplimit":{"name":"mml:uplimit","type":"element","attributes":{},"elements":{"name":"mml:uplimit","content":{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs"]}}},"mml:variance":{"name":"mml:variance","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:variance","content":{"type":",","blocks":[]}}},"mml:vector":{"name":"mml:vector","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:vector","content":{"type":",","blocks":[{"type":"*","block":"mml:bvar"},{"type":"*","block":{"type":"|","blocks":["mml:domainofapplication","mml:condition",{"type":",","blocks":["mml:lowlimit",{"type":"?","block":"mml:uplimit"}]}]}},{"type":"*","block":{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs"]}}]}}},"mml:vectorproduct":{"name":"mml:vectorproduct","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:vectorproduct","content":{"type":",","blocks":[]}}},"mml:xor":{"name":"mml:xor","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:xor","content":{"type":",","blocks":[]}}},"monospace":{"name":"monospace","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"toggle":{"name":"toggle"},"specific-use":{"name":"specific-use"}},"elements":{"name":"monospace","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","break"]}}}},"month":{"name":"month","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"month","content":"TEXT"}},"name":{"name":"name","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"name-style":{"name":"name-style"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"name","content":{"type":",","blocks":[{"type":"|","blocks":[{"type":",","blocks":["surname",{"type":"?","block":"given-names"}]},"given-names"]},{"type":"?","block":"prefix"},{"type":"?","block":"suffix"}]}}},"name-alternatives":{"name":"name-alternatives","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"}},"elements":{"name":"name-alternatives","content":{"type":"+","block":{"type":"|","blocks":["name","string-name"]}}}},"named-content":{"name":"named-content","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"rid":{"name":"rid"},"alt":{"name":"alt"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"xlink:type":{"name":"xlink:type"},"xlink:href":{"name":"xlink:href"},"xlink:role":{"name":"xlink:role"},"xlink:title":{"name":"xlink:title"},"xlink:show":{"name":"xlink:show"},"xlink:actuate":{"name":"xlink:actuate"}},"elements":{"name":"named-content","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","address","array","boxed-text","chem-struct-wrap","code","fig","fig-group","graphic","media","preformat","supplementary-material","table-wrap","table-wrap-group","disp-formula","disp-formula-group","def-list","list","ack","disp-quote","speech","statement","verse-group"]}}}},"nested-kwd":{"name":"nested-kwd","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"}},"elements":{"name":"nested-kwd","content":{"type":",","blocks":[{"type":"+","block":{"type":"|","blocks":["kwd","compound-kwd"]}},{"type":"*","block":"nested-kwd"}]}}},"nlm-citation":{"name":"nlm-citation","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"publication-type":{"name":"publication-type"},"publisher-type":{"name":"publisher-type"},"publication-format":{"name":"publication-format"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"xlink:type":{"name":"xlink:type"},"xlink:href":{"name":"xlink:href"},"xlink:role":{"name":"xlink:role"},"xlink:title":{"name":"xlink:title"},"xlink:show":{"name":"xlink:show"},"xlink:actuate":{"name":"xlink:actuate"}},"elements":{"name":"nlm-citation","content":{"type":",","blocks":[{"type":"*","block":{"type":"|","blocks":["person-group","collab"]}},{"type":"*","block":{"type":"|","blocks":["article-title","trans-title"]}},{"type":"?","block":"source"},{"type":"?","block":"patent"},{"type":"?","block":"trans-source"},{"type":"?","block":"year"},{"type":"|","blocks":[{"type":",","blocks":[{"type":"?","block":"month"},{"type":"?","block":"day"},{"type":"?","block":"time-stamp"}]},{"type":"?","block":"season"}]},{"type":"?","block":"access-date"},{"type":"?","block":"volume"},{"type":"?","block":"edition"},{"type":"?","block":"conf-name"},{"type":"?","block":"conf-date"},{"type":"?","block":"conf-loc"},{"type":"*","block":{"type":"|","blocks":["issue","supplement"]}},{"type":"?","block":"publisher-loc"},{"type":"?","block":"publisher-name"},{"type":"*","block":{"type":",","blocks":[{"type":"?","block":"fpage"},{"type":"?","block":"lpage"}]}},{"type":"?","block":"page-count"},{"type":"?","block":"series"},{"type":"*","block":"comment"},{"type":"*","block":"pub-id"},{"type":"?","block":"annotation"}]}}},"note":{"name":"note","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"note","content":{"type":",","blocks":[{"type":"?","block":"label"},{"type":"+","block":{"type":"|","blocks":["p","product"]}}]}}},"notes":{"name":"notes","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"notes-type":{"name":"notes-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"notes","content":{"type":",","blocks":[{"type":"?","block":"sec-meta"},{"type":"?","block":"label"},{"type":"?","block":"title"},{"type":"*","block":{"type":"|","blocks":["address","alternatives","array","boxed-text","chem-struct-wrap","code","fig","fig-group","graphic","media","preformat","supplementary-material","table-wrap","table-wrap-group","disp-formula","disp-formula-group","def-list","list","tex-math","mml:math","p","related-article","related-object","ack","disp-quote","speech","statement","verse-group","x"]}},{"type":"*","block":"sec"},{"type":"*","block":{"type":"|","blocks":["notes","fn-group","glossary","ref-list"]}}]}}},"oasis:colspec":{"name":"oasis:colspec","type":"element","attributes":{"colnum":{"name":"colnum"},"colname":{"name":"colname"},"colwidth":{"name":"colwidth"},"colsep":{"name":"colsep"},"rowsep":{"name":"rowsep"},"align":{"name":"align"},"char":{"name":"char"},"charoff":{"name":"charoff"},"id":{"name":"id"},"xml:base":{"name":"xml:base"}},"elements":{"name":"oasis:colspec","content":{"type":",","blocks":[]}}},"oasis:entry":{"name":"oasis:entry","type":"text","attributes":{"colname":{"name":"colname"},"namest":{"name":"namest"},"nameend":{"name":"nameend"},"morerows":{"name":"morerows"},"colsep":{"name":"colsep"},"rowsep":{"name":"rowsep"},"align":{"name":"align"},"char":{"name":"char"},"charoff":{"name":"charoff"},"valign":{"name":"valign"},"id":{"name":"id"},"xml:base":{"name":"xml:base"}},"elements":{"name":"oasis:entry","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","disp-formula","disp-formula-group","break","chem-struct-wrap","citation-alternatives","element-citation","mixed-citation","nlm-citation","def-list","list","p","array","code","graphic","media","preformat"]}}}},"oasis:row":{"name":"oasis:row","type":"element","attributes":{"rowsep":{"name":"rowsep"},"valign":{"name":"valign"},"id":{"name":"id"},"xml:base":{"name":"xml:base"}},"elements":{"name":"oasis:row","content":{"type":"+","block":"oasis:entry"}}},"oasis:table":{"name":"oasis:table","type":"element","attributes":{"frame":{"name":"frame"},"colsep":{"name":"colsep"},"rowsep":{"name":"rowsep"},"id":{"name":"id"},"xml:base":{"name":"xml:base"},"specific-use":{"name":"specific-use"},"content-type":{"name":"content-type"}},"elements":{"name":"oasis:table","content":{"type":"+","block":"oasis:tgroup"}}},"oasis:tbody":{"name":"oasis:tbody","type":"element","attributes":{"valign":{"name":"valign"},"id":{"name":"id"},"xml:base":{"name":"xml:base"}},"elements":{"name":"oasis:tbody","content":{"type":"+","block":"oasis:row"}}},"oasis:tgroup":{"name":"oasis:tgroup","type":"element","attributes":{"cols":{"name":"cols"},"colsep":{"name":"colsep"},"rowsep":{"name":"rowsep"},"align":{"name":"align"},"id":{"name":"id"},"xml:base":{"name":"xml:base"}},"elements":{"name":"oasis:tgroup","content":{"type":",","blocks":[{"type":"*","block":"oasis:colspec"},{"type":"?","block":"oasis:thead"},"oasis:tbody"]}}},"oasis:thead":{"name":"oasis:thead","type":"element","attributes":{"valign":{"name":"valign"},"id":{"name":"id"},"xml:base":{"name":"xml:base"}},"elements":{"name":"oasis:thead","content":{"type":"+","block":"oasis:row"}}},"object-id":{"name":"object-id","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"pub-id-type":{"name":"pub-id-type"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"}},"elements":{"name":"object-id","content":"TEXT"}},"on-behalf-of":{"name":"on-behalf-of","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"on-behalf-of","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","institution","institution-wrap"]}}}},"open-access":{"name":"open-access","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"open-access","content":{"type":"+","block":"p"}}},"overline":{"name":"overline","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"toggle":{"name":"toggle"},"specific-use":{"name":"specific-use"}},"elements":{"name":"overline","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","break"]}}}},"overline-end":{"name":"overline-end","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"rid":{"name":"rid"},"specific-use":{"name":"specific-use"}},"elements":{"name":"overline-end","content":{"type":",","blocks":[]}}},"overline-start":{"name":"overline-start","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"specific-use":{"name":"specific-use"}},"elements":{"name":"overline-start","content":{"type":",","blocks":[]}}},"p":{"name":"p","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"p","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","address","array","boxed-text","chem-struct-wrap","code","fig","fig-group","graphic","media","preformat","supplementary-material","table-wrap","table-wrap-group","disp-formula","disp-formula-group","citation-alternatives","element-citation","mixed-citation","nlm-citation","award-id","funding-source","open-access","def-list","list","ack","disp-quote","speech","statement","verse-group"]}}}},"page-count":{"name":"page-count","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"count":{"name":"count"}},"elements":{"name":"page-count","content":{"type":",","blocks":[]}}},"page-range":{"name":"page-range","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"page-range","content":"TEXT"}},"part-title":{"name":"part-title","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"part-title","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","break"]}}}},"patent":{"name":"patent","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"country":{"name":"country"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"patent","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x"]}}}},"permissions":{"name":"permissions","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"}},"elements":{"name":"permissions","content":{"type":",","blocks":[{"type":"*","block":"copyright-statement"},{"type":"*","block":"copyright-year"},{"type":"*","block":"copyright-holder"},{"type":"*","block":{"type":"|","blocks":["ali:free_to_read","license"]}}]}}},"person-group":{"name":"person-group","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"person-group-type":{"name":"person-group-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"person-group","content":{"type":"*","block":{"type":"|","blocks":["TEXT","anonymous","collab","collab-alternatives","name","name-alternatives","string-name","aff","aff-alternatives","etal","role","x"]}}}},"phone":{"name":"phone","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"}},"elements":{"name":"phone","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x"]}}}},"postal-code":{"name":"postal-code","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"postal-code","content":"TEXT"}},"prefix":{"name":"prefix","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"prefix","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x"]}}}},"preformat":{"name":"preformat","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"position":{"name":"position"},"orientation":{"name":"orientation"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"preformat-type":{"name":"preformat-type"},"xml:space":{"name":"xml:space"}},"elements":{"name":"preformat","content":{"type":"*","block":{"type":"|","blocks":["TEXT","alt-text","long-desc","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","attrib","permissions"]}}}},"price":{"name":"price","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"currency":{"name":"currency"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"price","content":{"type":"*","block":{"type":"|","blocks":["TEXT","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby"]}}}},"principal-award-recipient":{"name":"principal-award-recipient","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"principal-award-recipient","content":{"type":"*","block":{"type":"|","blocks":["TEXT","contrib-id","name","name-alternatives","institution","institution-wrap","string-name"]}}}},"principal-investigator":{"name":"principal-investigator","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"principal-investigator","content":{"type":"*","block":{"type":"|","blocks":["TEXT","contrib-id","name","name-alternatives","string-name"]}}}},"private-char":{"name":"private-char","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"description":{"name":"description"},"name":{"name":"name"},"specific-use":{"name":"specific-use"}},"elements":{"name":"private-char","content":{"type":"|","blocks":["glyph-data","glyph-ref",{"type":"*","block":"inline-graphic"}]}}},"product":{"name":"product","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"product-type":{"name":"product-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"xlink:type":{"name":"xlink:type"},"xlink:href":{"name":"xlink:href"},"xlink:role":{"name":"xlink:role"},"xlink:title":{"name":"xlink:title"},"xlink:show":{"name":"xlink:show"},"xlink:actuate":{"name":"xlink:actuate"}},"elements":{"name":"product","content":{"type":"*","block":{"type":"|","blocks":["TEXT","inline-supplementary-material","related-article","related-object","hr","break","string-date","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","label","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","price","annotation","article-title","chapter-title","collab","collab-alternatives","comment","conf-acronym","conf-date","conf-loc","conf-name","conf-sponsor","data-title","date","date-in-citation","day","edition","email","elocation-id","etal","ext-link","fpage","gov","institution","institution-wrap","isbn","issn","issn-l","issue","issue-id","issue-part","issue-title","lpage","month","name","name-alternatives","object-id","page-range","part-title","patent","person-group","pub-id","publisher-loc","publisher-name","role","season","series","size","source","std","string-name","supplement","trans-source","trans-title","uri","version","volume","volume-id","volume-series","year","fn","target","xref","sub","sup","x"]}}}},"pub-date":{"name":"pub-date","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"pub-type":{"name":"pub-type"},"publication-format":{"name":"publication-format"},"date-type":{"name":"date-type"},"iso-8601-date":{"name":"iso-8601-date"},"calendar":{"name":"calendar"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"pub-date","content":{"type":"*","block":{"type":"|","blocks":["day","era","month","season","year","string-date","x"]}}}},"pub-id":{"name":"pub-id","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"pub-id-type":{"name":"pub-id-type"},"assigning-authority":{"name":"assigning-authority"},"specific-use":{"name":"specific-use"},"xlink:type":{"name":"xlink:type"},"xlink:href":{"name":"xlink:href"},"xlink:role":{"name":"xlink:role"},"xlink:title":{"name":"xlink:title"},"xlink:show":{"name":"xlink:show"},"xlink:actuate":{"name":"xlink:actuate"}},"elements":{"name":"pub-id","content":"TEXT"}},"publisher":{"name":"publisher","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"}},"elements":{"name":"publisher","content":{"type":"+","block":{"type":",","blocks":["publisher-name",{"type":"?","block":"publisher-loc"}]}}}},"publisher-loc":{"name":"publisher-loc","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"publisher-loc","content":{"type":"*","block":{"type":"|","blocks":["TEXT","addr-line","city","country","fax","institution","institution-wrap","phone","postal-code","state","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","break"]}}}},"publisher-name":{"name":"publisher-name","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"publisher-name","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","institution","institution-wrap"]}}}},"rb":{"name":"rb","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"rb","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x"]}}}},"ref":{"name":"ref","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"ref","content":{"type":",","blocks":[{"type":"?","block":"label"},{"type":"+","block":{"type":"|","blocks":["citation-alternatives","element-citation","mixed-citation","nlm-citation","note","x"]}}]}}},"ref-count":{"name":"ref-count","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"count":{"name":"count"}},"elements":{"name":"ref-count","content":{"type":",","blocks":[]}}},"ref-list":{"name":"ref-list","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"ref-list","content":{"type":",","blocks":[{"type":"?","block":"label"},{"type":"?","block":"title"},{"type":"*","block":{"type":"|","blocks":["address","alternatives","array","boxed-text","chem-struct-wrap","code","fig","fig-group","graphic","media","preformat","supplementary-material","table-wrap","table-wrap-group","disp-formula","disp-formula-group","def-list","list","tex-math","mml:math","p","related-article","related-object","ack","disp-quote","speech","statement","verse-group","x","ref"]}},{"type":"*","block":"ref-list"}]}}},"related-article":{"name":"related-article","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"related-article-type":{"name":"related-article-type"},"ext-link-type":{"name":"ext-link-type"},"vol":{"name":"vol"},"page":{"name":"page"},"issue":{"name":"issue"},"elocation-id":{"name":"elocation-id"},"journal-id":{"name":"journal-id"},"journal-id-type":{"name":"journal-id-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"xlink:type":{"name":"xlink:type"},"xlink:href":{"name":"xlink:href"},"xlink:role":{"name":"xlink:role"},"xlink:title":{"name":"xlink:title"},"xlink:show":{"name":"xlink:show"},"xlink:actuate":{"name":"xlink:actuate"}},"elements":{"name":"related-article","content":{"type":"*","block":{"type":"|","blocks":["TEXT","inline-supplementary-material","related-article","related-object","hr","break","string-date","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","journal-id","label","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","annotation","article-title","chapter-title","collab","collab-alternatives","comment","conf-acronym","conf-date","conf-loc","conf-name","conf-sponsor","data-title","date","date-in-citation","day","edition","email","elocation-id","etal","ext-link","fpage","gov","institution","institution-wrap","isbn","issn","issn-l","issue","issue-id","issue-part","issue-title","lpage","month","name","name-alternatives","object-id","page-range","part-title","patent","person-group","pub-id","publisher-loc","publisher-name","role","season","series","size","source","std","string-name","supplement","trans-source","trans-title","uri","version","volume","volume-id","volume-series","year","fn","target","xref","sub","sup","x"]}}}},"related-object":{"name":"related-object","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"link-type":{"name":"link-type"},"ext-link-type":{"name":"ext-link-type"},"source-id":{"name":"source-id"},"source-id-type":{"name":"source-id-type"},"source-type":{"name":"source-type"},"document-id":{"name":"document-id"},"document-id-type":{"name":"document-id-type"},"document-type":{"name":"document-type"},"object-id":{"name":"object-id"},"object-id-type":{"name":"object-id-type"},"object-type":{"name":"object-type"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"xlink:type":{"name":"xlink:type"},"xlink:href":{"name":"xlink:href"},"xlink:role":{"name":"xlink:role"},"xlink:title":{"name":"xlink:title"},"xlink:show":{"name":"xlink:show"},"xlink:actuate":{"name":"xlink:actuate"}},"elements":{"name":"related-object","content":{"type":"*","block":{"type":"|","blocks":["TEXT","inline-supplementary-material","related-article","related-object","hr","break","string-date","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","label","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","annotation","article-title","chapter-title","collab","collab-alternatives","comment","conf-acronym","conf-date","conf-loc","conf-name","conf-sponsor","data-title","date","date-in-citation","day","edition","email","elocation-id","etal","ext-link","fpage","gov","institution","institution-wrap","isbn","issn","issn-l","issue","issue-id","issue-part","issue-title","lpage","month","name","name-alternatives","object-id","page-range","part-title","patent","person-group","pub-id","publisher-loc","publisher-name","role","season","series","size","source","std","string-name","supplement","trans-source","trans-title","uri","version","volume","volume-id","volume-series","year","fn","target","xref","sub","sup","x"]}}}},"response":{"name":"response","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"response-type":{"name":"response-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"response","content":{"type":",","blocks":[{"type":"|","blocks":["front","front-stub"]},{"type":"?","block":"body"},{"type":"?","block":"back"},{"type":"?","block":"floats-group"}]}}},"role":{"name":"role","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"role","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x"]}}}},"roman":{"name":"roman","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"toggle":{"name":"toggle"},"specific-use":{"name":"specific-use"}},"elements":{"name":"roman","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","break"]}}}},"rp":{"name":"rp","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"}},"elements":{"name":"rp","content":"TEXT"}},"rt":{"name":"rt","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"rt","content":"TEXT"}},"ruby":{"name":"ruby","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"}},"elements":{"name":"ruby","content":{"type":",","blocks":["rb",{"type":"|","blocks":["rt",{"type":",","blocks":["rp","rt","rp"]}]}]}}},"sans-serif":{"name":"sans-serif","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"toggle":{"name":"toggle"},"specific-use":{"name":"specific-use"}},"elements":{"name":"sans-serif","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","break"]}}}},"sc":{"name":"sc","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"toggle":{"name":"toggle"},"specific-use":{"name":"specific-use"}},"elements":{"name":"sc","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","break"]}}}},"season":{"name":"season","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"season","content":"TEXT"}},"sec":{"name":"sec","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"xml:lang":{"name":"xml:lang"},"sec-type":{"name":"sec-type"},"disp-level":{"name":"disp-level"},"specific-use":{"name":"specific-use"}},"elements":{"name":"sec","content":{"type":",","blocks":[{"type":"?","block":"sec-meta"},{"type":"?","block":"label"},{"type":"?","block":"title"},{"type":"*","block":{"type":"|","blocks":["address","alternatives","array","boxed-text","chem-struct-wrap","code","fig","fig-group","graphic","media","preformat","supplementary-material","table-wrap","table-wrap-group","disp-formula","disp-formula-group","def-list","list","tex-math","mml:math","p","related-article","related-object","ack","disp-quote","speech","statement","verse-group","x"]}},{"type":"*","block":"sec"},{"type":"*","block":{"type":"|","blocks":["notes","fn-group","glossary","ref-list"]}}]}}},"sec-meta":{"name":"sec-meta","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"}},"elements":{"name":"sec-meta","content":{"type":",","blocks":[{"type":"*","block":"contrib-group"},{"type":"*","block":"abstract"},{"type":"*","block":"kwd-group"},{"type":"?","block":"permissions"}]}}},"self-uri":{"name":"self-uri","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"xlink:type":{"name":"xlink:type"},"xlink:href":{"name":"xlink:href"},"xlink:role":{"name":"xlink:role"},"xlink:title":{"name":"xlink:title"},"xlink:show":{"name":"xlink:show"},"xlink:actuate":{"name":"xlink:actuate"}},"elements":{"name":"self-uri","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x"]}}}},"series":{"name":"series","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"series","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x"]}}}},"series-text":{"name":"series-text","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"series-text","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x"]}}}},"series-title":{"name":"series-title","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"series-title","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x"]}}}},"sig":{"name":"sig","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"rid":{"name":"rid"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"sig","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","break","graphic","media"]}}}},"sig-block":{"name":"sig-block","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"rid":{"name":"rid"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"}},"elements":{"name":"sig-block","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","break","contrib","graphic","media","aff","aff-alternatives","etal","role","sig"]}}}},"size":{"name":"size","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"units":{"name":"units"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"size","content":{"type":"*","block":{"type":"|","blocks":["TEXT","x"]}}}},"source":{"name":"source","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"source","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","break"]}}}},"speaker":{"name":"speaker","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"speaker","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","degrees","given-names","prefix","surname","suffix"]}}}},"speech":{"name":"speech","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"speech","content":{"type":",","blocks":["speaker",{"type":"+","block":"p"}]}}},"state":{"name":"state","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"state","content":"TEXT"}},"statement":{"name":"statement","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"statement","content":{"type":",","blocks":[{"type":"?","block":"label"},{"type":"?","block":"title"},{"type":"*","block":"abstract"},{"type":"*","block":"kwd-group"},{"type":"+","block":{"type":"|","blocks":["p","statement"]}},{"type":"*","block":{"type":"|","blocks":["attrib","permissions"]}}]}}},"std":{"name":"std","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"std","content":{"type":"*","block":{"type":"|","blocks":["TEXT","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","named-content","styled-content","day","month","pub-id","source","std-organization","year","sub","sup"]}}}},"std-organization":{"name":"std-organization","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"std-organization","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","institution","institution-wrap","break"]}}}},"strike":{"name":"strike","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"toggle":{"name":"toggle"},"specific-use":{"name":"specific-use"}},"elements":{"name":"strike","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","break"]}}}},"string-conf":{"name":"string-conf","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"string-conf","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","conf-date","conf-name","conf-num","conf-loc","conf-sponsor","conf-theme","conf-acronym","string-conf"]}}}},"string-date":{"name":"string-date","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"iso-8601-date":{"name":"iso-8601-date"},"calendar":{"name":"calendar"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"string-date","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","day","era","month","season","year"]}}}},"string-name":{"name":"string-name","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"name-style":{"name":"name-style"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"string-name","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","degrees","given-names","prefix","surname","suffix"]}}}},"styled-content":{"name":"styled-content","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"toggle":{"name":"toggle"},"style":{"name":"style"},"style-type":{"name":"style-type"},"alt":{"name":"alt"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"styled-content","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","address","array","boxed-text","chem-struct-wrap","code","fig","fig-group","graphic","media","preformat","supplementary-material","table-wrap","table-wrap-group","disp-formula","disp-formula-group","def-list","list","ack","disp-quote","speech","statement","verse-group"]}}}},"sub":{"name":"sub","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"arrange":{"name":"arrange"},"specific-use":{"name":"specific-use"}},"elements":{"name":"sub","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","break"]}}}},"sub-article":{"name":"sub-article","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"article-type":{"name":"article-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"sub-article","content":{"type":",","blocks":[{"type":"|","blocks":["front","front-stub"]},{"type":"?","block":"body"},{"type":"?","block":"back"},{"type":"?","block":"floats-group"},{"type":"|","blocks":[{"type":"*","block":"sub-article"},{"type":"*","block":"response"}]}]}}},"subj-group":{"name":"subj-group","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"subj-group-type":{"name":"subj-group-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"subj-group","content":{"type":",","blocks":[{"type":"+","block":{"type":"|","blocks":["subject","compound-subject"]}},{"type":"*","block":"subj-group"}]}}},"subject":{"name":"subject","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"}},"elements":{"name":"subject","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","break"]}}}},"subtitle":{"name":"subtitle","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"subtitle","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","break"]}}}},"suffix":{"name":"suffix","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"suffix","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x"]}}}},"sup":{"name":"sup","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"arrange":{"name":"arrange"},"specific-use":{"name":"specific-use"}},"elements":{"name":"sup","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","break"]}}}},"supplement":{"name":"supplement","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"supplement-type":{"name":"supplement-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"supplement","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","contrib-group","title"]}}}},"supplementary-material":{"name":"supplementary-material","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"position":{"name":"position"},"orientation":{"name":"orientation"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"content-type":{"name":"content-type"},"mimetype":{"name":"mimetype"},"mime-subtype":{"name":"mime-subtype"},"xlink:type":{"name":"xlink:type"},"xlink:href":{"name":"xlink:href"},"xlink:role":{"name":"xlink:role"},"xlink:title":{"name":"xlink:title"},"xlink:show":{"name":"xlink:show"},"xlink:actuate":{"name":"xlink:actuate"}},"elements":{"name":"supplementary-material","content":{"type":",","blocks":[{"type":"*","block":"object-id"},{"type":"?","block":"label"},{"type":"*","block":"caption"},{"type":"*","block":"abstract"},{"type":"*","block":"kwd-group"},{"type":"*","block":{"type":"|","blocks":["alt-text","long-desc","email","ext-link","uri"]}},{"type":"*","block":{"type":"|","blocks":["disp-formula","disp-formula-group","chem-struct-wrap","disp-quote","speech","statement","verse-group","table-wrap","p","def-list","list","alternatives","array","code","graphic","media","preformat"]}},{"type":"*","block":{"type":"|","blocks":["attrib","permissions"]}}]}}},"surname":{"name":"surname","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"initials":{"name":"initials"}},"elements":{"name":"surname","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x"]}}}},"table":{"name":"table","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"style":{"name":"style"},"summary":{"name":"summary"},"width":{"name":"width"},"border":{"name":"border"},"frame":{"name":"frame"},"rules":{"name":"rules"},"cellspacing":{"name":"cellspacing"},"cellpadding":{"name":"cellpadding"},"specific-use":{"name":"specific-use"}},"elements":{"name":"table","content":{"type":",","blocks":[{"type":"|","blocks":[{"type":"*","block":"col"},{"type":"*","block":"colgroup"}]},{"type":"|","blocks":[{"type":",","blocks":[{"type":"?","block":"thead"},{"type":"?","block":"tfoot"},{"type":"+","block":"tbody"}]},{"type":"+","block":"tr"}]}]}}},"table-count":{"name":"table-count","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"count":{"name":"count"}},"elements":{"name":"table-count","content":{"type":",","blocks":[]}}},"table-wrap":{"name":"table-wrap","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"position":{"name":"position"},"orientation":{"name":"orientation"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"content-type":{"name":"content-type"}},"elements":{"name":"table-wrap","content":{"type":",","blocks":[{"type":"*","block":"object-id"},{"type":"?","block":"label"},{"type":"?","block":"caption"},{"type":"*","block":"abstract"},{"type":"*","block":"kwd-group"},{"type":"*","block":{"type":"|","blocks":["alt-text","long-desc","email","ext-link","uri"]}},{"type":"*","block":{"type":"|","blocks":["disp-quote","speech","statement","verse-group","def-list","list","alternatives","chem-struct-wrap","code","graphic","media","preformat","table","oasis:table"]}},{"type":"*","block":{"type":"|","blocks":["table-wrap-foot","attrib","permissions"]}}]}}},"table-wrap-foot":{"name":"table-wrap-foot","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"}},"elements":{"name":"table-wrap-foot","content":{"type":",","blocks":[{"type":"?","block":"label"},{"type":"?","block":"title"},{"type":"+","block":{"type":"|","blocks":["p","fn-group","fn","attrib","permissions","x"]}}]}}},"table-wrap-group":{"name":"table-wrap-group","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"position":{"name":"position"},"orientation":{"name":"orientation"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"content-type":{"name":"content-type"}},"elements":{"name":"table-wrap-group","content":{"type":",","blocks":[{"type":"?","block":"label"},{"type":"?","block":"caption"},{"type":"*","block":"abstract"},{"type":"*","block":"kwd-group"},{"type":"*","block":{"type":"|","blocks":["alt-text","long-desc","email","ext-link","uri"]}},{"type":"+","block":"table-wrap"}]}}},"target":{"name":"target","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"target-type":{"name":"target-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"target","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","break"]}}}},"tbody":{"name":"tbody","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"style":{"name":"style"},"align":{"name":"align"},"char":{"name":"char"},"charoff":{"name":"charoff"},"valign":{"name":"valign"}},"elements":{"name":"tbody","content":{"type":"+","block":"tr"}}},"td":{"name":"td","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"style":{"name":"style"},"abbr":{"name":"abbr"},"axis":{"name":"axis"},"headers":{"name":"headers"},"scope":{"name":"scope"},"rowspan":{"name":"rowspan"},"colspan":{"name":"colspan"},"align":{"name":"align"},"char":{"name":"char"},"charoff":{"name":"charoff"},"valign":{"name":"valign"}},"elements":{"name":"td","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","disp-formula","disp-formula-group","break","chem-struct-wrap","citation-alternatives","element-citation","mixed-citation","nlm-citation","def-list","list","p","array","code","graphic","media","preformat"]}}}},"term":{"name":"term","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"rid":{"name":"rid"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"term","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","disp-formula","disp-formula-group","chem-struct-wrap","array","code","graphic","media","preformat"]}}}},"term-head":{"name":"term-head","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"}},"elements":{"name":"term-head","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x"]}}}},"tex-math":{"name":"tex-math","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"notation":{"name":"notation"},"version":{"name":"version"}},"elements":{"name":"tex-math","content":"TEXT"}},"textual-form":{"name":"textual-form","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"textual-form","content":{"type":"*","block":{"type":"|","blocks":["TEXT","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","inline-graphic","private-char","label","tex-math","mml:math","named-content","styled-content","sub","sup"]}}}},"tfoot":{"name":"tfoot","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"style":{"name":"style"},"align":{"name":"align"},"char":{"name":"char"},"charoff":{"name":"charoff"},"valign":{"name":"valign"}},"elements":{"name":"tfoot","content":{"type":"+","block":"tr"}}},"th":{"name":"th","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"style":{"name":"style"},"abbr":{"name":"abbr"},"axis":{"name":"axis"},"headers":{"name":"headers"},"scope":{"name":"scope"},"rowspan":{"name":"rowspan"},"colspan":{"name":"colspan"},"align":{"name":"align"},"char":{"name":"char"},"charoff":{"name":"charoff"},"valign":{"name":"valign"}},"elements":{"name":"th","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","disp-formula","disp-formula-group","break","chem-struct-wrap","citation-alternatives","element-citation","mixed-citation","nlm-citation","def-list","list","p","array","code","graphic","media","preformat"]}}}},"thead":{"name":"thead","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"style":{"name":"style"},"align":{"name":"align"},"char":{"name":"char"},"charoff":{"name":"charoff"},"valign":{"name":"valign"}},"elements":{"name":"thead","content":{"type":"+","block":"tr"}}},"time-stamp":{"name":"time-stamp","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"}},"elements":{"name":"time-stamp","content":{"type":"*","block":{"type":"|","blocks":["TEXT","day","era","month","season","year","x"]}}}},"title":{"name":"title","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"}},"elements":{"name":"title","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","break","citation-alternatives","element-citation","mixed-citation","nlm-citation"]}}}},"title-group":{"name":"title-group","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"}},"elements":{"name":"title-group","content":{"type":",","blocks":["article-title",{"type":"*","block":"subtitle"},{"type":"*","block":"trans-title-group"},{"type":"*","block":"alt-title"},{"type":"?","block":"fn-group"}]}}},"tr":{"name":"tr","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"style":{"name":"style"},"align":{"name":"align"},"char":{"name":"char"},"charoff":{"name":"charoff"},"valign":{"name":"valign"}},"elements":{"name":"tr","content":{"type":"+","block":{"type":"|","blocks":["th","td"]}}}},"trans-abstract":{"name":"trans-abstract","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"abstract-type":{"name":"abstract-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"trans-abstract","content":{"type":",","blocks":[{"type":"*","block":"object-id"},{"type":"?","block":"sec-meta"},{"type":"?","block":"label"},{"type":"?","block":"title"},{"type":"*","block":{"type":"|","blocks":["address","alternatives","array","boxed-text","chem-struct-wrap","code","fig","fig-group","graphic","media","preformat","supplementary-material","table-wrap","table-wrap-group","disp-formula","disp-formula-group","def-list","list","tex-math","mml:math","p","related-article","related-object","ack","disp-quote","speech","statement","verse-group","x"]}},{"type":"*","block":"sec"},{"type":"*","block":{"type":"|","blocks":["notes","fn-group","glossary","ref-list"]}}]}}},"trans-source":{"name":"trans-source","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"trans-source","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","break"]}}}},"trans-subtitle":{"name":"trans-subtitle","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"trans-subtitle","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","break"]}}}},"trans-title":{"name":"trans-title","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"trans-title","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","break"]}}}},"trans-title-group":{"name":"trans-title-group","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"trans-title-group","content":{"type":",","blocks":["trans-title",{"type":"*","block":"trans-subtitle"}]}}},"underline":{"name":"underline","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"toggle":{"name":"toggle"},"underline-style":{"name":"underline-style"},"specific-use":{"name":"specific-use"}},"elements":{"name":"underline","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","break"]}}}},"underline-end":{"name":"underline-end","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"rid":{"name":"rid"},"specific-use":{"name":"specific-use"}},"elements":{"name":"underline-end","content":{"type":",","blocks":[]}}},"underline-start":{"name":"underline-start","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"specific-use":{"name":"specific-use"}},"elements":{"name":"underline-start","content":{"type":",","blocks":[]}}},"unstructured-kwd-group":{"name":"unstructured-kwd-group","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"kwd-group-type":{"name":"kwd-group-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"unstructured-kwd-group","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x"]}}}},"uri":{"name":"uri","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"xlink:type":{"name":"xlink:type"},"xlink:href":{"name":"xlink:href"},"xlink:role":{"name":"xlink:role"},"xlink:title":{"name":"xlink:title"},"xlink:show":{"name":"xlink:show"},"xlink:actuate":{"name":"xlink:actuate"}},"elements":{"name":"uri","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x"]}}}},"verse-group":{"name":"verse-group","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"verse-group","content":{"type":",","blocks":[{"type":"?","block":"label"},{"type":"?","block":"title"},{"type":"?","block":"subtitle"},{"type":"+","block":{"type":"|","blocks":["verse-line","verse-group"]}},{"type":"*","block":{"type":"|","blocks":["attrib","permissions"]}}]}}},"verse-line":{"name":"verse-line","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"verse-line","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x"]}}}},"version":{"name":"version","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"designator":{"name":"designator"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"version","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x"]}}}},"volume":{"name":"volume","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"seq":{"name":"seq"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"volume","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x"]}}}},"volume-id":{"name":"volume-id","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"pub-id-type":{"name":"pub-id-type"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"xlink:type":{"name":"xlink:type"},"xlink:href":{"name":"xlink:href"},"xlink:role":{"name":"xlink:role"},"xlink:title":{"name":"xlink:title"},"xlink:show":{"name":"xlink:show"},"xlink:actuate":{"name":"xlink:actuate"}},"elements":{"name":"volume-id","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x"]}}}},"volume-issue-group":{"name":"volume-issue-group","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"volume-issue-group","content":{"type":",","blocks":[{"type":"*","block":"volume"},{"type":"*","block":"volume-id"},{"type":"?","block":"volume-series"},{"type":"*","block":"issue"},{"type":"*","block":"issue-id"},{"type":"*","block":"issue-title"},{"type":"*","block":"issue-sponsor"},{"type":"?","block":"issue-part"}]}}},"volume-series":{"name":"volume-series","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"volume-series","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x"]}}}},"word-count":{"name":"word-count","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"count":{"name":"count"}},"elements":{"name":"word-count","content":{"type":",","blocks":[]}}},"x":{"name":"x","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"xml:space":{"name":"xml:space"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"x","content":{"type":"*","block":{"type":"|","blocks":["TEXT","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","named-content","styled-content","sub","sup","x"]}}}},"xref":{"name":"xref","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"ref-type":{"name":"ref-type"},"alt":{"name":"alt"},"rid":{"name":"rid"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"xref","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","break"]}}}},"year":{"name":"year","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"iso-8601-date":{"name":"iso-8601-date"},"calendar":{"name":"calendar"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"year","content":"TEXT"}}}}

  const DOC_TYPE_PARAMS = [
    'article',
    '-//NLM//DTD JATS (Z39.96) Journal Archiving DTD v1.0 20120330//EN',
    'JATS-journalarchiving.dtd'
  ];

  var JATS = createSchema(JATSArchivingData, 'jats', '1.1', DOC_TYPE_PARAMS)

  var TextureArticleData = {"start":"article","elements":{"abbrev":{"name":"abbrev","type":"not-implemented","attributes":{},"elements":{"name":"abbrev","content":{"type":",","blocks":[]}}},"abbrev-journal-title":{"name":"abbrev-journal-title","type":"not-implemented","attributes":{},"elements":{"name":"abbrev-journal-title","content":{"type":",","blocks":[]}}},"abstract":{"name":"abstract","type":"container","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"abstract-type":{"name":"abstract-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"abstract","content":{"type":"*","block":"p"}}},"ack":{"name":"ack","type":"not-implemented","attributes":{},"elements":{"name":"ack","content":{"type":",","blocks":[]}}},"addr-line":{"name":"addr-line","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"addr-line","content":"TEXT"}},"address":{"name":"address","type":"not-implemented","attributes":{},"elements":{"name":"address","content":{"type":",","blocks":[]}}},"aff":{"name":"aff","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"rid":{"name":"rid"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"aff","content":{"type":"~","blocks":[{"type":"*","block":"addr-line"},{"type":"?","block":"label"},{"type":"?","block":"city"},{"type":"?","block":"country"},{"type":"?","block":"fax"},{"type":"*","block":"institution"},{"type":"*","block":"institution-wrap"},{"type":"?","block":"phone"},{"type":"?","block":"postal-code"},{"type":"?","block":"state"},{"type":"?","block":"email"},{"type":"*","block":"ext-link"},{"type":"?","block":"uri"}]}}},"aff-alternatives":{"name":"aff-alternatives","type":"not-implemented","attributes":{},"elements":{"name":"aff-alternatives","content":{"type":",","blocks":[]}}},"ali:free_to_read":{"name":"ali:free_to_read","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"end_date":{"name":"end_date"},"start_date":{"name":"start_date"}},"elements":{"name":"ali:free_to_read","content":{"type":",","blocks":[]}}},"ali:license_ref":{"name":"ali:license_ref","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"start_date":{"name":"start_date"}},"elements":{"name":"ali:license_ref","content":"TEXT"}},"alt-text":{"name":"alt-text","type":"not-implemented","attributes":{},"elements":{"name":"alt-text","content":{"type":",","blocks":[]}}},"alt-title":{"name":"alt-title","type":"not-implemented","attributes":{},"elements":{"name":"alt-title","content":{"type":",","blocks":[]}}},"alternatives":{"name":"alternatives","type":"not-implemented","attributes":{},"elements":{"name":"alternatives","content":{"type":",","blocks":[]}}},"annotation":{"name":"annotation","type":"not-implemented","attributes":{},"elements":{"name":"annotation","content":{"type":",","blocks":[]}}},"anonymous":{"name":"anonymous","type":"not-implemented","attributes":{},"elements":{"name":"anonymous","content":{"type":",","blocks":[]}}},"app":{"name":"app","type":"not-implemented","attributes":{},"elements":{"name":"app","content":{"type":",","blocks":[]}}},"app-group":{"name":"app-group","type":"not-implemented","attributes":{},"elements":{"name":"app-group","content":{"type":",","blocks":[]}}},"array":{"name":"array","type":"not-implemented","attributes":{},"elements":{"name":"array","content":{"type":",","blocks":[]}}},"article":{"name":"article","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"article-type":{"name":"article-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"dtd-version":{"name":"dtd-version"}},"elements":{"name":"article","content":{"type":",","blocks":["front",{"type":"?","block":"body"},{"type":"?","block":"back"}]}}},"article-categories":{"name":"article-categories","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"}},"elements":{"name":"article-categories","content":{"type":"*","block":"subj-group"}}},"article-id":{"name":"article-id","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"pub-id-type":{"name":"pub-id-type"},"specific-use":{"name":"specific-use"}},"elements":{"name":"article-id","content":"TEXT"}},"article-meta":{"name":"article-meta","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"}},"elements":{"name":"article-meta","content":{"type":",","blocks":[{"type":"*","block":"article-id"},{"type":"?","block":"article-categories"},{"type":"?","block":"title-group"},{"type":"*","block":"contrib-group"},{"type":"*","block":"aff"},{"type":"*","block":"pub-date"},{"type":"?","block":"volume"},{"type":"?","block":"issue"},{"type":"?","block":"isbn"},{"type":"?","block":{"type":"|","blocks":[{"type":",","blocks":[{"type":"?","block":{"type":",","blocks":["fpage",{"type":"?","block":"lpage"}]}},{"type":"?","block":"page-range"}]},"elocation-id"]}},{"type":"?","block":"history"},{"type":"?","block":"permissions"},{"type":"?","block":"abstract"},{"type":"*","block":"trans-abstract"},{"type":"*","block":"kwd-group"},{"type":"*","block":"funding-group"}]}}},"article-title":{"name":"article-title","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"article-title","content":{"type":"*","block":{"type":"|","blocks":["TEXT","ext-link","inline-supplementary-material","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","abbrev","milestone-end","milestone-start","named-content","styled-content","target","xref","sub","sup","break"]}}}},"attrib":{"name":"attrib","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"attrib","content":{"type":"*","block":{"type":"|","blocks":["TEXT","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","sub","sup"]}}}},"author-comment":{"name":"author-comment","type":"not-implemented","attributes":{},"elements":{"name":"author-comment","content":{"type":",","blocks":[]}}},"author-notes":{"name":"author-notes","type":"not-implemented","attributes":{},"elements":{"name":"author-notes","content":{"type":",","blocks":[]}}},"award-group":{"name":"award-group","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"rid":{"name":"rid"},"award-type":{"name":"award-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"xlink:type":{"name":"xlink:type"},"xlink:href":{"name":"xlink:href"},"xlink:role":{"name":"xlink:role"},"xlink:title":{"name":"xlink:title"},"xlink:show":{"name":"xlink:show"},"xlink:actuate":{"name":"xlink:actuate"}},"elements":{"name":"award-group","content":{"type":",","blocks":[{"type":"*","block":"funding-source"},{"type":"*","block":"award-id"},{"type":"*","block":"principal-award-recipient"},{"type":"*","block":"principal-investigator"}]}}},"award-id":{"name":"award-id","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"rid":{"name":"rid"},"award-type":{"name":"award-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"xlink:type":{"name":"xlink:type"},"xlink:href":{"name":"xlink:href"},"xlink:role":{"name":"xlink:role"},"xlink:title":{"name":"xlink:title"},"xlink:show":{"name":"xlink:show"},"xlink:actuate":{"name":"xlink:actuate"}},"elements":{"name":"award-id","content":"TEXT"}},"back":{"name":"back","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"}},"elements":{"name":"back","content":{"type":"~","blocks":[{"type":"?","block":"fn-group"},{"type":"?","block":"ref-list"}]}}},"bio":{"name":"bio","type":"container","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"rid":{"name":"rid"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"xlink:type":{"name":"xlink:type"},"xlink:href":{"name":"xlink:href"},"xlink:role":{"name":"xlink:role"},"xlink:title":{"name":"xlink:title"},"xlink:show":{"name":"xlink:show"},"xlink:actuate":{"name":"xlink:actuate"}},"elements":{"name":"bio","content":{"type":"*","block":"p"}}},"body":{"name":"body","type":"container","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"specific-use":{"name":"specific-use"}},"elements":{"name":"body","content":{"type":"*","block":{"type":"|","blocks":["sec","boxed-text","chem-struct-wrap","code","fig","fig-group","table-wrap","disp-formula","disp-formula-group","def-list","list","p","preformat","disp-quote","disp-formula","disp-formula-group","def-list","list","p","ack","disp-quote","speech","statement","verse-group"]}}}},"bold":{"name":"bold","type":"annotation","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"toggle":{"name":"toggle"},"specific-use":{"name":"specific-use"}},"elements":{"name":"bold","content":{"type":"*","block":{"type":"|","blocks":["TEXT","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","sub","sup"]}}}},"boxed-text":{"name":"boxed-text","type":"not-implemented","attributes":{},"elements":{"name":"boxed-text","content":{"type":",","blocks":[]}}},"break":{"name":"break","type":"inline-element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"}},"elements":{"name":"break","content":{"type":",","blocks":[]}}},"caption":{"name":"caption","type":"container","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"style":{"name":"style"}},"elements":{"name":"caption","content":{"type":",","blocks":[{"type":"?","block":"title"},{"type":"*","block":"p"}]}}},"chapter-title":{"name":"chapter-title","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"chapter-title","content":{"type":"*","block":{"type":"|","blocks":["TEXT","ext-link","inline-supplementary-material","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","abbrev","milestone-end","milestone-start","named-content","styled-content","target","xref","sub","sup","break"]}}}},"chem-struct":{"name":"chem-struct","type":"not-implemented","attributes":{},"elements":{"name":"chem-struct","content":{"type":",","blocks":[]}}},"chem-struct-wrap":{"name":"chem-struct-wrap","type":"not-implemented","attributes":{},"elements":{"name":"chem-struct-wrap","content":{"type":",","blocks":[]}}},"citation-alternatives":{"name":"citation-alternatives","type":"not-implemented","attributes":{},"elements":{"name":"citation-alternatives","content":{"type":",","blocks":[]}}},"city":{"name":"city","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"city","content":"TEXT"}},"code":{"name":"code","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"code-type":{"name":"code-type"},"code-version":{"name":"code-version"},"executable":{"name":"executable"},"language":{"name":"language"},"language-version":{"name":"language-version"},"platforms":{"name":"platforms"},"position":{"name":"position"},"orientation":{"name":"orientation"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"}},"elements":{"name":"code","content":"TEXT"}},"col":{"name":"col","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"style":{"name":"style"},"span":{"name":"span"},"width":{"name":"width"},"align":{"name":"align"},"char":{"name":"char"},"charoff":{"name":"charoff"},"valign":{"name":"valign"}},"elements":{"name":"col","content":{"type":",","blocks":[]}}},"colgroup":{"name":"colgroup","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"style":{"name":"style"},"span":{"name":"span"},"width":{"name":"width"},"align":{"name":"align"},"char":{"name":"char"},"charoff":{"name":"charoff"},"valign":{"name":"valign"}},"elements":{"name":"colgroup","content":{"type":"*","block":"col"}}},"collab":{"name":"collab","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"collab-type":{"name":"collab-type"},"symbol":{"name":"symbol"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"xlink:type":{"name":"xlink:type"},"xlink:href":{"name":"xlink:href"},"xlink:role":{"name":"xlink:role"},"xlink:title":{"name":"xlink:title"},"xlink:show":{"name":"xlink:show"},"xlink:actuate":{"name":"xlink:actuate"}},"elements":{"name":"collab","content":{"type":"~","blocks":[{"type":"?","block":"email"},"named-content",{"type":"?","block":"contrib-group"},{"type":"*","block":"xref"}]}}},"collab-alternatives":{"name":"collab-alternatives","type":"not-implemented","attributes":{},"elements":{"name":"collab-alternatives","content":{"type":",","blocks":[]}}},"comment":{"name":"comment","type":"not-implemented","attributes":{},"elements":{"name":"comment","content":{"type":",","blocks":[]}}},"compound-kwd":{"name":"compound-kwd","type":"not-implemented","attributes":{},"elements":{"name":"compound-kwd","content":{"type":",","blocks":[]}}},"compound-kwd-part":{"name":"compound-kwd-part","type":"not-implemented","attributes":{},"elements":{"name":"compound-kwd-part","content":{"type":",","blocks":[]}}},"compound-subject":{"name":"compound-subject","type":"not-implemented","attributes":{},"elements":{"name":"compound-subject","content":{"type":",","blocks":[]}}},"compound-subject-part":{"name":"compound-subject-part","type":"not-implemented","attributes":{},"elements":{"name":"compound-subject-part","content":{"type":",","blocks":[]}}},"conf-acronym":{"name":"conf-acronym","type":"not-implemented","attributes":{},"elements":{"name":"conf-acronym","content":{"type":",","blocks":[]}}},"conf-date":{"name":"conf-date","type":"not-implemented","attributes":{},"elements":{"name":"conf-date","content":{"type":",","blocks":[]}}},"conf-loc":{"name":"conf-loc","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"conf-loc","content":"TEXT"}},"conf-name":{"name":"conf-name","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"conf-name","content":"TEXT"}},"conf-num":{"name":"conf-num","type":"not-implemented","attributes":{},"elements":{"name":"conf-num","content":{"type":",","blocks":[]}}},"conf-sponsor":{"name":"conf-sponsor","type":"not-implemented","attributes":{},"elements":{"name":"conf-sponsor","content":{"type":",","blocks":[]}}},"conf-theme":{"name":"conf-theme","type":"not-implemented","attributes":{},"elements":{"name":"conf-theme","content":{"type":",","blocks":[]}}},"conference":{"name":"conference","type":"not-implemented","attributes":{},"elements":{"name":"conference","content":{"type":",","blocks":[]}}},"contrib":{"name":"contrib","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"contrib-type":{"name":"contrib-type"},"corresp":{"name":"corresp"},"equal-contrib":{"name":"equal-contrib"},"deceased":{"name":"deceased"},"rid":{"name":"rid"},"specific-use":{"name":"specific-use"},"xlink:type":{"name":"xlink:type"},"xlink:href":{"name":"xlink:href"},"xlink:role":{"name":"xlink:role"},"xlink:title":{"name":"xlink:title"},"xlink:show":{"name":"xlink:show"},"xlink:actuate":{"name":"xlink:actuate"}},"elements":{"name":"contrib","content":{"type":"~","blocks":[{"type":"*","block":"contrib-id"},{"type":"?","block":"name"},{"type":"?","block":"email"},{"type":"?","block":"string-name"},{"type":"?","block":"bio"},{"type":"?","block":"collab"},{"type":"?","block":"role"},{"type":"*","block":"xref"}]}}},"contrib-group":{"name":"contrib-group","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"}},"elements":{"name":"contrib-group","content":{"type":"*","block":"contrib"}}},"contrib-id":{"name":"contrib-id","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"contrib-id-type":{"name":"contrib-id-type"},"authenticated":{"name":"authenticated"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"contrib-id","content":"TEXT"}},"copyright-holder":{"name":"copyright-holder","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"copyright-holder","content":"TEXT"}},"copyright-statement":{"name":"copyright-statement","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"copyright-statement","content":"TEXT"}},"copyright-year":{"name":"copyright-year","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"}},"elements":{"name":"copyright-year","content":"TEXT"}},"corresp":{"name":"corresp","type":"not-implemented","attributes":{},"elements":{"name":"corresp","content":{"type":",","blocks":[]}}},"count":{"name":"count","type":"not-implemented","attributes":{},"elements":{"name":"count","content":{"type":",","blocks":[]}}},"country":{"name":"country","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"country":{"name":"country"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"country","content":"TEXT"}},"counts":{"name":"counts","type":"not-implemented","attributes":{},"elements":{"name":"counts","content":{"type":",","blocks":[]}}},"custom-meta":{"name":"custom-meta","type":"not-implemented","attributes":{},"elements":{"name":"custom-meta","content":{"type":",","blocks":[]}}},"custom-meta-group":{"name":"custom-meta-group","type":"not-implemented","attributes":{},"elements":{"name":"custom-meta-group","content":{"type":",","blocks":[]}}},"data-title":{"name":"data-title","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"data-title","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","named-content","styled-content","sub","sup"]}}}},"date":{"name":"date","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"date-type":{"name":"date-type"},"publication-format":{"name":"publication-format"},"iso-8601-date":{"name":"iso-8601-date"},"calendar":{"name":"calendar"},"specific-use":{"name":"specific-use"}},"elements":{"name":"date","content":{"type":",","blocks":[{"type":"?","block":{"type":"|","blocks":[{"type":",","blocks":[{"type":"?","block":"day"},{"type":"?","block":"month"}]},"season"]}},{"type":"?","block":"year"},{"type":"?","block":"era"},{"type":"?","block":"string-date"}]}}},"date-in-citation":{"name":"date-in-citation","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"iso-8601-date":{"name":"iso-8601-date"},"calendar":{"name":"calendar"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"date-in-citation","content":"TEXT"}},"day":{"name":"day","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"day","content":"TEXT"}},"def":{"name":"def","type":"not-implemented","attributes":{},"elements":{"name":"def","content":{"type":",","blocks":[]}}},"def-head":{"name":"def-head","type":"not-implemented","attributes":{},"elements":{"name":"def-head","content":{"type":",","blocks":[]}}},"def-item":{"name":"def-item","type":"not-implemented","attributes":{},"elements":{"name":"def-item","content":{"type":",","blocks":[]}}},"def-list":{"name":"def-list","type":"not-implemented","attributes":{},"elements":{"name":"def-list","content":{"type":",","blocks":[]}}},"degrees":{"name":"degrees","type":"not-implemented","attributes":{},"elements":{"name":"degrees","content":{"type":",","blocks":[]}}},"disp-formula":{"name":"disp-formula","type":"not-implemented","attributes":{},"elements":{"name":"disp-formula","content":{"type":",","blocks":[]}}},"disp-formula-group":{"name":"disp-formula-group","type":"not-implemented","attributes":{},"elements":{"name":"disp-formula-group","content":{"type":",","blocks":[]}}},"disp-quote":{"name":"disp-quote","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"disp-quote","content":{"type":",","blocks":[{"type":"+","block":"p"},{"type":"?","block":"attrib"}]}}},"edition":{"name":"edition","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"designator":{"name":"designator"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"edition","content":{"type":"*","block":{"type":"|","blocks":["TEXT","ext-link","inline-supplementary-material","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","abbrev","milestone-end","milestone-start","named-content","styled-content","target","xref","sub","sup"]}}}},"element-citation":{"name":"element-citation","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"publication-type":{"name":"publication-type"},"publisher-type":{"name":"publisher-type"},"publication-format":{"name":"publication-format"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"xlink:type":{"name":"xlink:type"},"xlink:href":{"name":"xlink:href"},"xlink:role":{"name":"xlink:role"},"xlink:title":{"name":"xlink:title"},"xlink:show":{"name":"xlink:show"},"xlink:actuate":{"name":"xlink:actuate"}},"elements":{"name":"element-citation","content":{"type":"~","blocks":[{"type":"?","block":"article-title"},{"type":"?","block":"chapter-title"},{"type":"?","block":"comment"},{"type":"?","block":"collab"},{"type":"?","block":"edition"},{"type":"?","block":"elocation-id"},{"type":"?","block":"fpage"},{"type":"?","block":"issue"},{"type":"?","block":"lpage"},{"type":"?","block":"page-range"},{"type":"*","block":"person-group"},{"type":"*","block":"pub-id"},{"type":"*","block":"publisher-loc"},{"type":"*","block":"publisher-name"},{"type":"?","block":"source"},{"type":"?","block":"volume"},{"type":"?","block":"year"},{"type":"?","block":"month"},{"type":"?","block":"day"},{"type":"?","block":"conf-name"},{"type":"?","block":"conf-loc"},{"type":"?","block":"data-title"},{"type":"?","block":"part-title"},{"type":"?","block":"patent"},{"type":"?","block":"series"},{"type":"?","block":"version"},{"type":"?","block":"uri"},{"type":"?","block":"date-in-citation"}]}}},"elocation-id":{"name":"elocation-id","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"seq":{"name":"seq"},"specific-use":{"name":"specific-use"}},"elements":{"name":"elocation-id","content":"TEXT"}},"email":{"name":"email","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"xlink:type":{"name":"xlink:type"},"xlink:href":{"name":"xlink:href"},"xlink:role":{"name":"xlink:role"},"xlink:title":{"name":"xlink:title"},"xlink:show":{"name":"xlink:show"},"xlink:actuate":{"name":"xlink:actuate"}},"elements":{"name":"email","content":{"type":"*","block":{"type":"|","blocks":["TEXT","ext-link","inline-supplementary-material","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","abbrev","milestone-end","milestone-start","named-content","styled-content","target","xref","sub","sup"]}}}},"equation-count":{"name":"equation-count","type":"not-implemented","attributes":{},"elements":{"name":"equation-count","content":{"type":",","blocks":[]}}},"era":{"name":"era","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"era","content":"TEXT"}},"etal":{"name":"etal","type":"not-implemented","attributes":{},"elements":{"name":"etal","content":{"type":",","blocks":[]}}},"ext-link":{"name":"ext-link","type":"annotation","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"ext-link-type":{"name":"ext-link-type"},"assigning-authority":{"name":"assigning-authority"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"xlink:type":{"name":"xlink:type"},"xlink:href":{"name":"xlink:href"},"xlink:role":{"name":"xlink:role"},"xlink:title":{"name":"xlink:title"},"xlink:show":{"name":"xlink:show"},"xlink:actuate":{"name":"xlink:actuate"}},"elements":{"name":"ext-link","content":{"type":"*","block":{"type":"|","blocks":["TEXT","ext-link","inline-supplementary-material","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","abbrev","milestone-end","milestone-start","named-content","styled-content","target","xref","sub","sup"]}}}},"fax":{"name":"fax","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"}},"elements":{"name":"fax","content":"TEXT"}},"fig":{"name":"fig","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"position":{"name":"position"},"orientation":{"name":"orientation"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"fig-type":{"name":"fig-type"}},"elements":{"name":"fig","content":{"type":",","blocks":[{"type":"?","block":"object-id"},{"type":"?","block":"label"},{"type":"?","block":"caption"},"graphic",{"type":"?","block":"permissions"}]}}},"fig-count":{"name":"fig-count","type":"not-implemented","attributes":{},"elements":{"name":"fig-count","content":{"type":",","blocks":[]}}},"fig-group":{"name":"fig-group","type":"not-implemented","attributes":{},"elements":{"name":"fig-group","content":{"type":",","blocks":[]}}},"fixed-case":{"name":"fixed-case","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"}},"elements":{"name":"fixed-case","content":{"type":"*","block":{"type":"|","blocks":["TEXT","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","sub","sup"]}}}},"floats-group":{"name":"floats-group","type":"not-implemented","attributes":{},"elements":{"name":"floats-group","content":{"type":",","blocks":[]}}},"fn":{"name":"fn","type":"container","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"symbol":{"name":"symbol"},"fn-type":{"name":"fn-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"fn","content":{"type":"+","block":"p"}}},"fn-group":{"name":"fn-group","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"fn-group","content":{"type":",","blocks":[{"type":"?","block":"label"},{"type":"?","block":"title"},{"type":"+","block":"fn"}]}}},"fpage":{"name":"fpage","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"seq":{"name":"seq"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"fpage","content":"TEXT"}},"front":{"name":"front","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"}},"elements":{"name":"front","content":{"type":",","blocks":[{"type":"?","block":"journal-meta"},"article-meta"]}}},"front-stub":{"name":"front-stub","type":"not-implemented","attributes":{},"elements":{"name":"front-stub","content":{"type":",","blocks":[]}}},"funding-group":{"name":"funding-group","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"funding-group","content":{"type":"*","block":"award-group"}}},"funding-source":{"name":"funding-source","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"rid":{"name":"rid"},"source-type":{"name":"source-type"},"country":{"name":"country"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"xlink:type":{"name":"xlink:type"},"xlink:href":{"name":"xlink:href"},"xlink:role":{"name":"xlink:role"},"xlink:title":{"name":"xlink:title"},"xlink:show":{"name":"xlink:show"},"xlink:actuate":{"name":"xlink:actuate"}},"elements":{"name":"funding-source","content":"institution-wrap"}},"funding-statement":{"name":"funding-statement","type":"not-implemented","attributes":{},"elements":{"name":"funding-statement","content":{"type":",","blocks":[]}}},"given-names":{"name":"given-names","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"initials":{"name":"initials"}},"elements":{"name":"given-names","content":{"type":"*","block":{"type":"|","blocks":["TEXT","ext-link","inline-supplementary-material","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","abbrev","milestone-end","milestone-start","named-content","styled-content","target","xref","sub","sup"]}}}},"glossary":{"name":"glossary","type":"not-implemented","attributes":{},"elements":{"name":"glossary","content":{"type":",","blocks":[]}}},"glyph-data":{"name":"glyph-data","type":"not-implemented","attributes":{},"elements":{"name":"glyph-data","content":{"type":",","blocks":[]}}},"glyph-ref":{"name":"glyph-ref","type":"not-implemented","attributes":{},"elements":{"name":"glyph-ref","content":{"type":",","blocks":[]}}},"gov":{"name":"gov","type":"not-implemented","attributes":{},"elements":{"name":"gov","content":{"type":",","blocks":[]}}},"graphic":{"name":"graphic","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"position":{"name":"position"},"orientation":{"name":"orientation"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"content-type":{"name":"content-type"},"mime-subtype":{"name":"mime-subtype"},"mimetype":{"name":"mimetype"},"xlink:type":{"name":"xlink:type"},"xlink:href":{"name":"xlink:href"},"xlink:role":{"name":"xlink:role"},"xlink:title":{"name":"xlink:title"},"xlink:show":{"name":"xlink:show"},"xlink:actuate":{"name":"xlink:actuate"}},"elements":{"name":"graphic","content":{"type":",","blocks":[]}}},"history":{"name":"history","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"}},"elements":{"name":"history","content":{"type":"*","block":"date"}}},"hr":{"name":"hr","type":"not-implemented","attributes":{},"elements":{"name":"hr","content":{"type":",","blocks":[]}}},"inline-formula":{"name":"inline-formula","type":"inline-element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"inline-formula","content":"tex-math"}},"inline-graphic":{"name":"inline-graphic","type":"not-implemented","attributes":{},"elements":{"name":"inline-graphic","content":{"type":",","blocks":[]}}},"inline-supplementary-material":{"name":"inline-supplementary-material","type":"not-implemented","attributes":{},"elements":{"name":"inline-supplementary-material","content":{"type":",","blocks":[]}}},"institution":{"name":"institution","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"xlink:type":{"name":"xlink:type"},"xlink:href":{"name":"xlink:href"},"xlink:role":{"name":"xlink:role"},"xlink:title":{"name":"xlink:title"},"xlink:show":{"name":"xlink:show"},"xlink:actuate":{"name":"xlink:actuate"}},"elements":{"name":"institution","content":{"type":"*","block":{"type":"|","blocks":["TEXT","ext-link","inline-supplementary-material","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","abbrev","milestone-end","milestone-start","named-content","styled-content","target","xref","sub","sup","break"]}}}},"institution-id":{"name":"institution-id","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"institution-id-type":{"name":"institution-id-type"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"institution-id","content":"TEXT"}},"institution-wrap":{"name":"institution-wrap","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"}},"elements":{"name":"institution-wrap","content":{"type":"*","block":{"type":"|","blocks":["institution","institution-id"]}}}},"isbn":{"name":"isbn","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"publication-format":{"name":"publication-format"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"}},"elements":{"name":"isbn","content":"TEXT"}},"issn":{"name":"issn","type":"not-implemented","attributes":{},"elements":{"name":"issn","content":{"type":",","blocks":[]}}},"issn-l":{"name":"issn-l","type":"not-implemented","attributes":{},"elements":{"name":"issn-l","content":{"type":",","blocks":[]}}},"issue":{"name":"issue","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"seq":{"name":"seq"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"issue","content":"TEXT"}},"issue-id":{"name":"issue-id","type":"not-implemented","attributes":{},"elements":{"name":"issue-id","content":{"type":",","blocks":[]}}},"issue-part":{"name":"issue-part","type":"not-implemented","attributes":{},"elements":{"name":"issue-part","content":{"type":",","blocks":[]}}},"issue-sponsor":{"name":"issue-sponsor","type":"not-implemented","attributes":{},"elements":{"name":"issue-sponsor","content":{"type":",","blocks":[]}}},"issue-title":{"name":"issue-title","type":"not-implemented","attributes":{},"elements":{"name":"issue-title","content":{"type":",","blocks":[]}}},"italic":{"name":"italic","type":"annotation","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"toggle":{"name":"toggle"},"specific-use":{"name":"specific-use"}},"elements":{"name":"italic","content":{"type":"*","block":{"type":"|","blocks":["TEXT","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","sub","sup"]}}}},"journal-id":{"name":"journal-id","type":"not-implemented","attributes":{},"elements":{"name":"journal-id","content":{"type":",","blocks":[]}}},"journal-meta":{"name":"journal-meta","type":"not-implemented","attributes":{},"elements":{"name":"journal-meta","content":{"type":",","blocks":[]}}},"journal-subtitle":{"name":"journal-subtitle","type":"not-implemented","attributes":{},"elements":{"name":"journal-subtitle","content":{"type":",","blocks":[]}}},"journal-title":{"name":"journal-title","type":"not-implemented","attributes":{},"elements":{"name":"journal-title","content":{"type":",","blocks":[]}}},"journal-title-group":{"name":"journal-title-group","type":"not-implemented","attributes":{},"elements":{"name":"journal-title-group","content":{"type":",","blocks":[]}}},"kwd":{"name":"kwd","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"}},"elements":{"name":"kwd","content":{"type":"*","block":{"type":"|","blocks":["TEXT","ext-link","inline-supplementary-material","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","abbrev","milestone-end","milestone-start","named-content","styled-content","target","xref","sub","sup","break"]}}}},"kwd-group":{"name":"kwd-group","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"kwd-group-type":{"name":"kwd-group-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"kwd-group","content":{"type":",","blocks":[{"type":"?","block":"label"},{"type":"?","block":"title"},{"type":"|","blocks":[{"type":"+","block":{"type":"|","blocks":["kwd","compound-kwd","nested-kwd"]}},{"type":"*","block":"unstructured-kwd-group"}]}]}}},"label":{"name":"label","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"alt":{"name":"alt"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"label","content":{"type":"*","block":{"type":"|","blocks":["TEXT","ext-link","inline-supplementary-material","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","abbrev","milestone-end","milestone-start","named-content","styled-content","target","xref","sub","sup","break"]}}}},"license":{"name":"license","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"license-type":{"name":"license-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"xlink:type":{"name":"xlink:type"},"xlink:href":{"name":"xlink:href"},"xlink:role":{"name":"xlink:role"},"xlink:title":{"name":"xlink:title"},"xlink:show":{"name":"xlink:show"},"xlink:actuate":{"name":"xlink:actuate"}},"elements":{"name":"license","content":{"type":"~","blocks":[{"type":"?","block":"ali:license_ref"},{"type":"?","block":"license-p"}]}}},"license-p":{"name":"license-p","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"}},"elements":{"name":"license-p","content":{"type":"*","block":{"type":"|","blocks":["TEXT","ext-link","inline-supplementary-material","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","chem-struct","inline-formula","inline-graphic","private-char","abbrev","milestone-end","milestone-start","named-content","styled-content","target","xref","sub","sup","price"]}}}},"list":{"name":"list","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"list-type":{"name":"list-type"},"prefix-word":{"name":"prefix-word"},"list-content":{"name":"list-content"},"continued-from":{"name":"continued-from"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"list","content":{"type":"+","block":"list-item"}}},"list-item":{"name":"list-item","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"list-item","content":{"type":"+","block":{"type":"|","blocks":["p","list"]}}}},"long-desc":{"name":"long-desc","type":"not-implemented","attributes":{},"elements":{"name":"long-desc","content":{"type":",","blocks":[]}}},"lpage":{"name":"lpage","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"lpage","content":"TEXT"}},"media":{"name":"media","type":"not-implemented","attributes":{},"elements":{"name":"media","content":{"type":",","blocks":[]}}},"meta-name":{"name":"meta-name","type":"not-implemented","attributes":{},"elements":{"name":"meta-name","content":{"type":",","blocks":[]}}},"meta-value":{"name":"meta-value","type":"not-implemented","attributes":{},"elements":{"name":"meta-value","content":{"type":",","blocks":[]}}},"milestone-end":{"name":"milestone-end","type":"not-implemented","attributes":{},"elements":{"name":"milestone-end","content":{"type":",","blocks":[]}}},"milestone-start":{"name":"milestone-start","type":"not-implemented","attributes":{},"elements":{"name":"milestone-start","content":{"type":",","blocks":[]}}},"mixed-citation":{"name":"mixed-citation","type":"not-implemented","attributes":{},"elements":{"name":"mixed-citation","content":{"type":",","blocks":[]}}},"monospace":{"name":"monospace","type":"annotation","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"toggle":{"name":"toggle"},"specific-use":{"name":"specific-use"}},"elements":{"name":"monospace","content":{"type":"*","block":{"type":"|","blocks":["TEXT","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","sub","sup"]}}}},"month":{"name":"month","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"month","content":"TEXT"}},"name":{"name":"name","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"name-style":{"name":"name-style"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"name","content":{"type":",","blocks":[{"type":"|","blocks":[{"type":",","blocks":["surname",{"type":"?","block":"given-names"}]},"given-names"]},{"type":"?","block":"prefix"},{"type":"?","block":"suffix"}]}}},"name-alternatives":{"name":"name-alternatives","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"}},"elements":{"name":"name-alternatives","content":{"type":"+","block":{"type":"|","blocks":["name","string-name"]}}}},"named-content":{"name":"named-content","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"rid":{"name":"rid"},"alt":{"name":"alt"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"xlink:type":{"name":"xlink:type"},"xlink:href":{"name":"xlink:href"},"xlink:role":{"name":"xlink:role"},"xlink:title":{"name":"xlink:title"},"xlink:show":{"name":"xlink:show"},"xlink:actuate":{"name":"xlink:actuate"}},"elements":{"name":"named-content","content":"TEXT"}},"nested-kwd":{"name":"nested-kwd","type":"not-implemented","attributes":{},"elements":{"name":"nested-kwd","content":{"type":",","blocks":[]}}},"note":{"name":"note","type":"not-implemented","attributes":{},"elements":{"name":"note","content":{"type":",","blocks":[]}}},"notes":{"name":"notes","type":"not-implemented","attributes":{},"elements":{"name":"notes","content":{"type":",","blocks":[]}}},"object-id":{"name":"object-id","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"pub-id-type":{"name":"pub-id-type"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"}},"elements":{"name":"object-id","content":"TEXT"}},"on-behalf-of":{"name":"on-behalf-of","type":"not-implemented","attributes":{},"elements":{"name":"on-behalf-of","content":{"type":",","blocks":[]}}},"open-access":{"name":"open-access","type":"not-implemented","attributes":{},"elements":{"name":"open-access","content":{"type":",","blocks":[]}}},"overline":{"name":"overline","type":"annotation","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"toggle":{"name":"toggle"},"specific-use":{"name":"specific-use"}},"elements":{"name":"overline","content":{"type":"*","block":{"type":"|","blocks":["TEXT","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","sub","sup"]}}}},"overline-end":{"name":"overline-end","type":"not-implemented","attributes":{},"elements":{"name":"overline-end","content":{"type":",","blocks":[]}}},"overline-start":{"name":"overline-start","type":"not-implemented","attributes":{},"elements":{"name":"overline-start","content":{"type":",","blocks":[]}}},"p":{"name":"p","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"p","content":{"type":"*","block":{"type":"|","blocks":["TEXT","ext-link","inline-supplementary-material","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","chem-struct","inline-formula","inline-graphic","private-char","abbrev","milestone-end","milestone-start","named-content","styled-content","target","xref","sub","sup"]}}}},"page-count":{"name":"page-count","type":"not-implemented","attributes":{},"elements":{"name":"page-count","content":{"type":",","blocks":[]}}},"page-range":{"name":"page-range","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"page-range","content":"TEXT"}},"part-title":{"name":"part-title","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"part-title","content":{"type":"*","block":{"type":"|","blocks":["TEXT","ext-link","inline-supplementary-material","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","abbrev","milestone-end","milestone-start","named-content","styled-content","target","xref","sub","sup","break"]}}}},"patent":{"name":"patent","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"country":{"name":"country"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"patent","content":{"type":"*","block":{"type":"|","blocks":["TEXT","ext-link","inline-supplementary-material","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","abbrev","milestone-end","milestone-start","named-content","styled-content","target","xref","sub","sup"]}}}},"permissions":{"name":"permissions","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"}},"elements":{"name":"permissions","content":{"type":",","blocks":[{"type":"*","block":"copyright-statement"},{"type":"*","block":"copyright-year"},{"type":"*","block":"copyright-holder"},{"type":"*","block":{"type":"|","blocks":["ali:free_to_read","license"]}}]}}},"person-group":{"name":"person-group","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"person-group-type":{"name":"person-group-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"person-group","content":{"type":"*","block":{"type":"|","blocks":["anonymous","collab","collab-alternatives","name","name-alternatives","string-name","aff","aff-alternatives","etal","role"]}}}},"phone":{"name":"phone","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"}},"elements":{"name":"phone","content":{"type":"*","block":{"type":"|","blocks":["TEXT","ext-link","inline-supplementary-material","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","abbrev","milestone-end","milestone-start","named-content","styled-content","target","xref","sub","sup"]}}}},"postal-code":{"name":"postal-code","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"postal-code","content":"TEXT"}},"prefix":{"name":"prefix","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"prefix","content":{"type":"*","block":{"type":"|","blocks":["TEXT","ext-link","inline-supplementary-material","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","abbrev","milestone-end","milestone-start","named-content","styled-content","target","xref","sub","sup"]}}}},"preformat":{"name":"preformat","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"position":{"name":"position"},"orientation":{"name":"orientation"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"preformat-type":{"name":"preformat-type"},"xml:space":{"name":"xml:space"}},"elements":{"name":"preformat","content":{"type":"*","block":{"type":"|","blocks":["TEXT","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","abbrev","milestone-end","milestone-start","named-content","styled-content","sub","sup"]}}}},"price":{"name":"price","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"currency":{"name":"currency"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"price","content":{"type":"*","block":{"type":"|","blocks":["TEXT","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby"]}}}},"principal-award-recipient":{"name":"principal-award-recipient","type":"not-implemented","attributes":{},"elements":{"name":"principal-award-recipient","content":{"type":",","blocks":[]}}},"principal-investigator":{"name":"principal-investigator","type":"not-implemented","attributes":{},"elements":{"name":"principal-investigator","content":{"type":",","blocks":[]}}},"private-char":{"name":"private-char","type":"not-implemented","attributes":{},"elements":{"name":"private-char","content":{"type":",","blocks":[]}}},"product":{"name":"product","type":"not-implemented","attributes":{},"elements":{"name":"product","content":{"type":",","blocks":[]}}},"pub-date":{"name":"pub-date","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"pub-type":{"name":"pub-type"},"publication-format":{"name":"publication-format"},"date-type":{"name":"date-type"},"iso-8601-date":{"name":"iso-8601-date"},"calendar":{"name":"calendar"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"pub-date","content":{"type":"*","block":{"type":"|","blocks":["day","era","month","season","year","string-date"]}}}},"pub-id":{"name":"pub-id","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"pub-id-type":{"name":"pub-id-type"},"assigning-authority":{"name":"assigning-authority"},"specific-use":{"name":"specific-use"},"xlink:type":{"name":"xlink:type"},"xlink:href":{"name":"xlink:href"},"xlink:role":{"name":"xlink:role"},"xlink:title":{"name":"xlink:title"},"xlink:show":{"name":"xlink:show"},"xlink:actuate":{"name":"xlink:actuate"}},"elements":{"name":"pub-id","content":"TEXT"}},"publisher":{"name":"publisher","type":"not-implemented","attributes":{},"elements":{"name":"publisher","content":{"type":",","blocks":[]}}},"publisher-loc":{"name":"publisher-loc","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"publisher-loc","content":"TEXT"}},"publisher-name":{"name":"publisher-name","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"publisher-name","content":"TEXT"}},"rb":{"name":"rb","type":"not-implemented","attributes":{},"elements":{"name":"rb","content":{"type":",","blocks":[]}}},"ref":{"name":"ref","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"ref","content":"element-citation"}},"ref-count":{"name":"ref-count","type":"not-implemented","attributes":{},"elements":{"name":"ref-count","content":{"type":",","blocks":[]}}},"ref-list":{"name":"ref-list","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"ref-list","content":{"type":"*","block":"ref"}}},"related-article":{"name":"related-article","type":"not-implemented","attributes":{},"elements":{"name":"related-article","content":{"type":",","blocks":[]}}},"related-object":{"name":"related-object","type":"not-implemented","attributes":{},"elements":{"name":"related-object","content":{"type":",","blocks":[]}}},"response":{"name":"response","type":"not-implemented","attributes":{},"elements":{"name":"response","content":{"type":",","blocks":[]}}},"role":{"name":"role","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"role","content":{"type":"*","block":{"type":"|","blocks":["TEXT","ext-link","inline-supplementary-material","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","abbrev","milestone-end","milestone-start","named-content","styled-content","target","xref","sub","sup"]}}}},"roman":{"name":"roman","type":"not-implemented","attributes":{},"elements":{"name":"roman","content":{"type":",","blocks":[]}}},"rp":{"name":"rp","type":"not-implemented","attributes":{},"elements":{"name":"rp","content":{"type":",","blocks":[]}}},"rt":{"name":"rt","type":"not-implemented","attributes":{},"elements":{"name":"rt","content":{"type":",","blocks":[]}}},"ruby":{"name":"ruby","type":"not-implemented","attributes":{},"elements":{"name":"ruby","content":{"type":",","blocks":[]}}},"sans-serif":{"name":"sans-serif","type":"not-implemented","attributes":{},"elements":{"name":"sans-serif","content":{"type":",","blocks":[]}}},"sc":{"name":"sc","type":"annotation","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"toggle":{"name":"toggle"},"specific-use":{"name":"specific-use"}},"elements":{"name":"sc","content":{"type":"*","block":{"type":"|","blocks":["TEXT","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","sub","sup"]}}}},"season":{"name":"season","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"season","content":"TEXT"}},"sec":{"name":"sec","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"xml:lang":{"name":"xml:lang"},"sec-type":{"name":"sec-type"},"disp-level":{"name":"disp-level"},"specific-use":{"name":"specific-use"}},"elements":{"name":"sec","content":{"type":",","blocks":[{"type":"?","block":"title"},{"type":"*","block":{"type":"|","blocks":["boxed-text","chem-struct-wrap","code","fig","fig-group","table-wrap","disp-formula","disp-formula-group","def-list","list","p","preformat","disp-quote","disp-formula","disp-formula-group","def-list","list","p","ack","disp-quote","speech","statement","verse-group"]}},{"type":"*","block":"sec"}]}}},"sec-meta":{"name":"sec-meta","type":"not-implemented","attributes":{},"elements":{"name":"sec-meta","content":{"type":",","blocks":[]}}},"self-uri":{"name":"self-uri","type":"not-implemented","attributes":{},"elements":{"name":"self-uri","content":{"type":",","blocks":[]}}},"series":{"name":"series","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"series","content":{"type":"*","block":{"type":"|","blocks":["TEXT","ext-link","inline-supplementary-material","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","abbrev","milestone-end","milestone-start","named-content","styled-content","target","xref","sub","sup"]}}}},"series-text":{"name":"series-text","type":"not-implemented","attributes":{},"elements":{"name":"series-text","content":{"type":",","blocks":[]}}},"series-title":{"name":"series-title","type":"not-implemented","attributes":{},"elements":{"name":"series-title","content":{"type":",","blocks":[]}}},"sig":{"name":"sig","type":"not-implemented","attributes":{},"elements":{"name":"sig","content":{"type":",","blocks":[]}}},"sig-block":{"name":"sig-block","type":"not-implemented","attributes":{},"elements":{"name":"sig-block","content":{"type":",","blocks":[]}}},"size":{"name":"size","type":"not-implemented","attributes":{},"elements":{"name":"size","content":{"type":",","blocks":[]}}},"source":{"name":"source","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"source","content":{"type":"*","block":{"type":"|","blocks":["TEXT","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","sub","sup"]}}}},"speaker":{"name":"speaker","type":"not-implemented","attributes":{},"elements":{"name":"speaker","content":{"type":",","blocks":[]}}},"speech":{"name":"speech","type":"not-implemented","attributes":{},"elements":{"name":"speech","content":{"type":",","blocks":[]}}},"state":{"name":"state","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"state","content":"TEXT"}},"statement":{"name":"statement","type":"not-implemented","attributes":{},"elements":{"name":"statement","content":{"type":",","blocks":[]}}},"std":{"name":"std","type":"not-implemented","attributes":{},"elements":{"name":"std","content":{"type":",","blocks":[]}}},"std-organization":{"name":"std-organization","type":"not-implemented","attributes":{},"elements":{"name":"std-organization","content":{"type":",","blocks":[]}}},"strike":{"name":"strike","type":"annotation","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"toggle":{"name":"toggle"},"specific-use":{"name":"specific-use"}},"elements":{"name":"strike","content":{"type":"*","block":{"type":"|","blocks":["TEXT","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","sub","sup"]}}}},"string-conf":{"name":"string-conf","type":"not-implemented","attributes":{},"elements":{"name":"string-conf","content":{"type":",","blocks":[]}}},"string-date":{"name":"string-date","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"iso-8601-date":{"name":"iso-8601-date"},"calendar":{"name":"calendar"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"string-date","content":"TEXT"}},"string-name":{"name":"string-name","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"name-style":{"name":"name-style"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"string-name","content":{"type":"*","block":{"type":"|","blocks":["TEXT","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","sub","sup"]}}}},"styled-content":{"name":"styled-content","type":"not-implemented","attributes":{},"elements":{"name":"styled-content","content":{"type":",","blocks":[]}}},"sub":{"name":"sub","type":"annotation","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"arrange":{"name":"arrange"},"specific-use":{"name":"specific-use"}},"elements":{"name":"sub","content":{"type":"*","block":{"type":"|","blocks":["TEXT","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","sub","sup"]}}}},"sub-article":{"name":"sub-article","type":"not-implemented","attributes":{},"elements":{"name":"sub-article","content":{"type":",","blocks":[]}}},"subj-group":{"name":"subj-group","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"subj-group-type":{"name":"subj-group-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"subj-group","content":{"type":",","blocks":[{"type":"+","block":{"type":"|","blocks":["subject","compound-subject"]}},{"type":"*","block":"subj-group"}]}}},"subject":{"name":"subject","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"}},"elements":{"name":"subject","content":{"type":"*","block":{"type":"|","blocks":["TEXT","ext-link","inline-supplementary-material","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","abbrev","milestone-end","milestone-start","named-content","styled-content","target","xref","sub","sup","break"]}}}},"subtitle":{"name":"subtitle","type":"not-implemented","attributes":{},"elements":{"name":"subtitle","content":{"type":",","blocks":[]}}},"suffix":{"name":"suffix","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"suffix","content":{"type":"*","block":{"type":"|","blocks":["TEXT","ext-link","inline-supplementary-material","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","abbrev","milestone-end","milestone-start","named-content","styled-content","target","xref","sub","sup"]}}}},"sup":{"name":"sup","type":"annotation","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"arrange":{"name":"arrange"},"specific-use":{"name":"specific-use"}},"elements":{"name":"sup","content":{"type":"*","block":{"type":"|","blocks":["TEXT","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","sub","sup"]}}}},"supplement":{"name":"supplement","type":"not-implemented","attributes":{},"elements":{"name":"supplement","content":{"type":",","blocks":[]}}},"supplementary-material":{"name":"supplementary-material","type":"not-implemented","attributes":{},"elements":{"name":"supplementary-material","content":{"type":",","blocks":[]}}},"surname":{"name":"surname","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"initials":{"name":"initials"}},"elements":{"name":"surname","content":{"type":"*","block":{"type":"|","blocks":["TEXT","ext-link","inline-supplementary-material","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","abbrev","milestone-end","milestone-start","named-content","styled-content","target","xref","sub","sup"]}}}},"table":{"name":"table","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"style":{"name":"style"},"summary":{"name":"summary"},"width":{"name":"width"},"border":{"name":"border"},"frame":{"name":"frame"},"rules":{"name":"rules"},"cellspacing":{"name":"cellspacing"},"cellpadding":{"name":"cellpadding"},"specific-use":{"name":"specific-use"}},"elements":{"name":"table","content":{"type":",","blocks":[{"type":"|","blocks":[{"type":"*","block":"col"},{"type":"*","block":"colgroup"}]},{"type":"|","blocks":[{"type":",","blocks":[{"type":"?","block":"thead"},{"type":"?","block":"tfoot"},{"type":"+","block":"tbody"}]},{"type":"+","block":"tr"}]}]}}},"table-count":{"name":"table-count","type":"not-implemented","attributes":{},"elements":{"name":"table-count","content":{"type":",","blocks":[]}}},"table-wrap":{"name":"table-wrap","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"position":{"name":"position"},"orientation":{"name":"orientation"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"content-type":{"name":"content-type"}},"elements":{"name":"table-wrap","content":{"type":",","blocks":[{"type":"?","block":"object-id"},{"type":"?","block":"label"},{"type":"?","block":"caption"},"table",{"type":"?","block":"permissions"}]}}},"table-wrap-foot":{"name":"table-wrap-foot","type":"not-implemented","attributes":{},"elements":{"name":"table-wrap-foot","content":{"type":",","blocks":[]}}},"table-wrap-group":{"name":"table-wrap-group","type":"not-implemented","attributes":{},"elements":{"name":"table-wrap-group","content":{"type":",","blocks":[]}}},"target":{"name":"target","type":"not-implemented","attributes":{},"elements":{"name":"target","content":{"type":",","blocks":[]}}},"tbody":{"name":"tbody","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"style":{"name":"style"},"align":{"name":"align"},"char":{"name":"char"},"charoff":{"name":"charoff"},"valign":{"name":"valign"}},"elements":{"name":"tbody","content":{"type":"+","block":"tr"}}},"td":{"name":"td","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"style":{"name":"style"},"abbr":{"name":"abbr"},"axis":{"name":"axis"},"headers":{"name":"headers"},"scope":{"name":"scope"},"rowspan":{"name":"rowspan"},"colspan":{"name":"colspan"},"align":{"name":"align"},"char":{"name":"char"},"charoff":{"name":"charoff"},"valign":{"name":"valign"}},"elements":{"name":"td","content":{"type":"*","block":{"type":"|","blocks":["TEXT","ext-link","inline-supplementary-material","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","abbrev","milestone-end","milestone-start","named-content","styled-content","target","xref","sub","sup"]}}}},"term":{"name":"term","type":"not-implemented","attributes":{},"elements":{"name":"term","content":{"type":",","blocks":[]}}},"term-head":{"name":"term-head","type":"not-implemented","attributes":{},"elements":{"name":"term-head","content":{"type":",","blocks":[]}}},"tex-math":{"name":"tex-math","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"notation":{"name":"notation"},"version":{"name":"version"}},"elements":{"name":"tex-math","content":"TEXT"}},"textual-form":{"name":"textual-form","type":"not-implemented","attributes":{},"elements":{"name":"textual-form","content":{"type":",","blocks":[]}}},"tfoot":{"name":"tfoot","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"style":{"name":"style"},"align":{"name":"align"},"char":{"name":"char"},"charoff":{"name":"charoff"},"valign":{"name":"valign"}},"elements":{"name":"tfoot","content":{"type":"+","block":"tr"}}},"th":{"name":"th","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"style":{"name":"style"},"abbr":{"name":"abbr"},"axis":{"name":"axis"},"headers":{"name":"headers"},"scope":{"name":"scope"},"rowspan":{"name":"rowspan"},"colspan":{"name":"colspan"},"align":{"name":"align"},"char":{"name":"char"},"charoff":{"name":"charoff"},"valign":{"name":"valign"}},"elements":{"name":"th","content":{"type":"*","block":{"type":"|","blocks":["TEXT","ext-link","inline-supplementary-material","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","abbrev","milestone-end","milestone-start","named-content","styled-content","target","xref","sub","sup"]}}}},"thead":{"name":"thead","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"style":{"name":"style"},"align":{"name":"align"},"char":{"name":"char"},"charoff":{"name":"charoff"},"valign":{"name":"valign"}},"elements":{"name":"thead","content":{"type":"+","block":"tr"}}},"title":{"name":"title","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"}},"elements":{"name":"title","content":{"type":"*","block":{"type":"|","blocks":["TEXT","ext-link","inline-supplementary-material","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","abbrev","milestone-end","milestone-start","named-content","styled-content","target","xref","sub","sup","break"]}}}},"title-group":{"name":"title-group","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"}},"elements":{"name":"title-group","content":{"type":",","blocks":["article-title",{"type":"*","block":"trans-title-group"}]}}},"tr":{"name":"tr","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"style":{"name":"style"},"align":{"name":"align"},"char":{"name":"char"},"charoff":{"name":"charoff"},"valign":{"name":"valign"}},"elements":{"name":"tr","content":{"type":"+","block":{"type":"|","blocks":["th","td"]}}}},"trans-abstract":{"name":"trans-abstract","type":"container","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"abstract-type":{"name":"abstract-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"trans-abstract","content":{"type":"*","block":"p"}}},"trans-source":{"name":"trans-source","type":"not-implemented","attributes":{},"elements":{"name":"trans-source","content":{"type":",","blocks":[]}}},"trans-subtitle":{"name":"trans-subtitle","type":"not-implemented","attributes":{},"elements":{"name":"trans-subtitle","content":{"type":",","blocks":[]}}},"trans-title":{"name":"trans-title","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"trans-title","content":{"type":"*","block":{"type":"|","blocks":["TEXT","ext-link","inline-supplementary-material","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","abbrev","milestone-end","milestone-start","named-content","styled-content","target","xref","sub","sup","break"]}}}},"trans-title-group":{"name":"trans-title-group","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"trans-title-group","content":{"type":",","blocks":["trans-title",{"type":"*","block":"trans-subtitle"}]}}},"underline":{"name":"underline","type":"annotation","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"toggle":{"name":"toggle"},"underline-style":{"name":"underline-style"},"specific-use":{"name":"specific-use"}},"elements":{"name":"underline","content":{"type":"*","block":{"type":"|","blocks":["TEXT","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","sub","sup"]}}}},"underline-end":{"name":"underline-end","type":"not-implemented","attributes":{},"elements":{"name":"underline-end","content":{"type":",","blocks":[]}}},"underline-start":{"name":"underline-start","type":"not-implemented","attributes":{},"elements":{"name":"underline-start","content":{"type":",","blocks":[]}}},"unstructured-kwd-group":{"name":"unstructured-kwd-group","type":"not-implemented","attributes":{},"elements":{"name":"unstructured-kwd-group","content":{"type":",","blocks":[]}}},"uri":{"name":"uri","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"xlink:type":{"name":"xlink:type"},"xlink:href":{"name":"xlink:href"},"xlink:role":{"name":"xlink:role"},"xlink:title":{"name":"xlink:title"},"xlink:show":{"name":"xlink:show"},"xlink:actuate":{"name":"xlink:actuate"}},"elements":{"name":"uri","content":{"type":"*","block":{"type":"|","blocks":["TEXT","ext-link","inline-supplementary-material","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","abbrev","milestone-end","milestone-start","named-content","styled-content","target","xref","sub","sup"]}}}},"verse-group":{"name":"verse-group","type":"not-implemented","attributes":{},"elements":{"name":"verse-group","content":{"type":",","blocks":[]}}},"verse-line":{"name":"verse-line","type":"not-implemented","attributes":{},"elements":{"name":"verse-line","content":{"type":",","blocks":[]}}},"version":{"name":"version","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"designator":{"name":"designator"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"version","content":{"type":"*","block":{"type":"|","blocks":["TEXT","ext-link","inline-supplementary-material","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","abbrev","milestone-end","milestone-start","named-content","styled-content","target","xref","sub","sup"]}}}},"volume":{"name":"volume","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"seq":{"name":"seq"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"volume","content":"TEXT"}},"volume-id":{"name":"volume-id","type":"not-implemented","attributes":{},"elements":{"name":"volume-id","content":{"type":",","blocks":[]}}},"volume-issue-group":{"name":"volume-issue-group","type":"not-implemented","attributes":{},"elements":{"name":"volume-issue-group","content":{"type":",","blocks":[]}}},"volume-series":{"name":"volume-series","type":"not-implemented","attributes":{},"elements":{"name":"volume-series","content":{"type":",","blocks":[]}}},"word-count":{"name":"word-count","type":"not-implemented","attributes":{},"elements":{"name":"word-count","content":{"type":",","blocks":[]}}},"xref":{"name":"xref","type":"inline-element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"ref-type":{"name":"ref-type"},"alt":{"name":"alt"},"rid":{"name":"rid"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"xref","content":{"type":"*","block":{"type":"|","blocks":["TEXT","ext-link","inline-supplementary-material","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","abbrev","milestone-end","milestone-start","named-content","styled-content","target","xref","sub","sup","break"]}}}},"year":{"name":"year","type":"text","attributes":{},"elements":{"name":"year","content":"TEXT"}}}}

  const DOC_TYPE_PARAMS$1 = ['article', 'TextureArticle 0.1.0', 'http://substance.io/TextureArticle-1.0.0.dtd'];

  var TextureArticle = createSchema(TextureArticleData, 'texture-article', '0.1.0', DOC_TYPE_PARAMS$1)

  const PRESERVE_WHITESPACE = {
    'preformat': true,
    'code': true
  };

  function pruneText (el, xmlSchema) {
    if (el.isElementNode()) {
      let schema = xmlSchema.getElementSchema(el.tagName);
      if (!schema.isTextAllowed()) {
        _pruneText(el, xmlSchema);
      } else if (schema.type === 'text' && !PRESERVE_WHITESPACE[el.tagName]) {
        _pruneWhiteSpace(el, xmlSchema);
      }
    }
  }

  function _pruneText (el, xmlSchema) {
    let childNodes = el.childNodes;
    for (let i = childNodes.length - 1; i >= 0; i--) {
      let child = childNodes[i];
      if (child.isTextNode()) {
        el.removeChild(child);
      } else if (child.isElementNode()) {
        pruneText(child, xmlSchema);
      }
    }
  }

  function _pruneWhiteSpace (el, xmlSchema) {
    // TODO:
    // - remove all leading ws
    // - replace all inner ws with one space
    // - remove all trailing ws
    let childNodes = el.childNodes;
    if (childNodes.length === 0) return
    let firstChild = childNodes[0];
    let lastChild = substance.last(childNodes);
    // trim leading ws
    if (firstChild.isTextNode()) {
      let text = firstChild.textContent;
      text = text.replace(/^\s+/g, '');
      firstChild.textContent = text;
    }
    // trim trailing ws
    if (lastChild.isTextNode()) {
      let text = lastChild.textContent;
      text = text.replace(/\s+$/g, '');
      lastChild.textContent = text;
    }
    for (let i = 0; i < childNodes.length; i++) {
      let child = childNodes[i];
      if (child.isTextNode()) {
        let text = child.textContent;
        let m;
        while ((m = /\s\s+/g.exec(text))) {
          const L = m[0].length;
          text = text.slice(0, m.index) + ' ' + text.slice(m.index + L);
        }
        child.textContent = text;
      } else if (child.isElementNode()) {
        let schema = xmlSchema.getElementSchema(child.tagName);
        if (schema.type === '@annotation') {
          _pruneWhiteSpace(child, xmlSchema);
        }
      }
    }
  }

  /*
    Removes all native TextNodes from elements which we specified to be
    not-mixed.
  */
  class PruneText {
    import (dom) {
      pruneText(dom.find('article'), TextureArticle);
    }

    export () {
      // nothing
    }
  }

  /*
    Normalize footnotes contents.
    Removes everything except textual paragraphs from footnotes.
  */
  class NormalizeFn {
    import (dom) {
      let fns = dom.findAll('fn');
      fns.forEach(fn => {
        // Find all ptags that are nested in another p tag
        let ptags = fn.findAll('p p');
        // If any nested paragraphs are found we need to take action
        if (ptags.length > 0) {
          fn.empty();
          fn.append(ptags);
        }
      });
    }

    export () {
      // nothing
    }
  }

  /*
    Ensures the first contrib-group is tagged as authors and second as editors
  */
  class NormalizeContribGroup {
    import (dom) {
      let contribGroups = dom.findAll('article-meta > contrib-group');
      if (contribGroups[0]) {
        _normalizeContribGroup(contribGroups[0], 'author');
      }

      if (contribGroups[1]) {
        _normalizeContribGroup(contribGroups[1], 'editor');
      }

      if (contribGroups.length > 2) {
        console.warn(`Only the first 2 found contrib-groups (authors, editors) will be editable.`);
      }
    }

    export () {
      // nothing
    }
  }

  function _normalizeContribGroup (contribGroup, targetType) {
    contribGroup.attr('content-type', targetType);
  }

  /*
    This pulls block-elements such as `<fig>` which are
    wrapped in a `<p>` one level up.
    In the opposite direction only those elements are wrapped
    which would otherwise violate JATS
  */
  class UnwrapBlockLevelElements {
    import (dom) {
      dom.findAll('body > p').forEach(_pBlock);
    }

    export () {}
  }

  // TODO: add all of them
  const BLOCKS = ['fig', 'fig-group', 'media', 'list', 'disp-formula', 'disp-quote'];
  const isBlock = BLOCKS.reduce((m, n) => { m[n] = true; return m }, {});

  function _pBlock (p) {
    let parent = p.parentNode;
    let children = p.children;
    let L = children.length;
    // doing it reverse so that we don't miss elements due to the ongoing tranformations
    for (var i = L - 1; i >= 0; i--) {
      let child = children[i];
      if (isBlock[child.tagName]) {
        // create a new <p>
        let newP = parent.createElement('p');
        let childPos = p.getChildIndex(child);
        let siblings = p.childNodes.slice(childPos + 1);
        // move all subsequent siblings to the new <p>
        // and insert the block element and the new one after the current <p>
        let pos = parent.getChildIndex(p) + 1;
        parent.insertAt(pos, child);
        if (siblings.length > 0 && _needsP(siblings)) {
          newP.append(siblings);
          parent.insertAt(pos + 1, newP);
        }
      }
    }
    // if the original <p> is now empty, remove it
    if (!_needsP(p.childNodes)) {
      p.parentNode.removeChild(p);
    }
  }

  function _needsP (nodes) {
    for (let i = 0; i < nodes.length; i++) {
      let child = nodes[i];
      // don't prune if there is something else left
      if (!child.isTextNode() || !(/^\s*$/.exec(child.textContent))) return true
    }
    return false
  }

  /*
    Creates empty ref-list if there is no one
    and removes everything except refs from existing ref-list.
  */
  class RefList {
    import (dom) {
      let refLists = dom.findAll('ref-list');
      if (refLists.length > 0) {
        refLists.forEach(refList => {
          let refs = refList.findAll('ref');
          refList.empty();
          refList.append(refs);
        });
      } else {
        let back = dom.find('back');
        back.append(
          dom.createElement('ref-list')
        );
      }
    }

    export () {
      // nothing
    }
  }

  class WrapSig {
    import (dom, api) {
      dom.findAll('sig-block').forEach((sigBlock) => {
        _importSigBlock(sigBlock, api);
      });
    }

    export () {
      // nothing
    }
  }

  function _importSigBlock (sigBlock, api) {
    let dom = sigBlock.getOwnerDocument();
    let sig = sigBlock.find('sig');

    if (isMixed(sigBlock)) {
      if (sig) {
        api.error({
          msg: 'Found <sig-block> containing <sig> elements but also text. Please wrap all content in <sig>.'
        });
      } else {
        let sig = dom.createElement('sig');
        sig.append(sigBlock.childNodes);
        sigBlock.append(sig);
      }
    }
  }

  const trafos = [
    WrapSig,
    NormalizeContribGroup,
    NormalizeFn,
    RefList,
    UnwrapBlockLevelElements,
    PruneText
  ].map(C => new C());

  function jats2restrictedJats (dom, api) {
    for (let i = 0; i < trafos.length; i++) {
      trafos[i].import(dom, api);
    }
  }

  const IMPL = Symbol('__AppStateImpl__');

  class AbstractAppState {
    constructor (...args) {
      this[IMPL] = new AppStateImpl();

      this._initialize(...args);
      this._reset();
    }

    _initialize () {
      // nothing to initialize on this level
    }

    dispose () {}

    isDirty (name) {
      return this._getImpl().isDirty(name)
    }

    get (name) {
      return this._getImpl().get(name)
    }

    set (name, value, propagateImmediately) {
      const impl = this._getImpl();
      let oldVal = impl.get(name);
      let hasChanged;
      if (substance.isObject(value)) {
        hasChanged = true;
      } else {
        hasChanged = oldVal !== value;
      }
      if (hasChanged) {
        impl.set(name, value);
        impl.setDirty(name);
        if (propagateImmediately) {
          this.propagateUpdates();
        }
      }
    }

    getUpdate (name) {
      return this._getImpl().getUpdate(name)
    }

    addObserver (deps, handler, observer, options = {}) { // eslint-disable-line no-unused-vars
      throw new Error('This method is abstract.')
    }

    removeObserver (observer) { // eslint-disable-line no-unused-vars
      throw new Error('This method is abstract.')
    }

    off (observer) {
      this.removeObserver(observer);
    }

    propagateUpdates () {
      throw new Error('This method is abstract.')
    }

    _getImpl () {
      return this[IMPL]
    }

    _addProperty (name, initialValue) {
      const impl = this._getImpl();
      if (impl.has(name)) {
        throw new Error(`State variable '${name}' is already declared.`)
      }
      impl.set(name, initialValue);
      Object.defineProperty(this, name, {
        configurable: false,
        enumerable: false,
        get: () => { return this.get(name) },
        set: (value) => { this.set(name, value); }
      });
    }

    // TODO: we should not need this on the long run
    // for now we use it to allow some hackz
    _setDirty (name) {
      this._getImpl().setDirty(name);
    }

    _setUpdate (name, update) {
      const impl = this._getImpl();
      impl.setUpdate(name, update);
      impl.setDirty(name);
    }

    _reset () {
      this._getImpl().reset();
    }
  }

  class AppStateImpl {
    constructor () {
      this.id = substance.uuid();
      this.values = new Map();
      this.dirty = {};
      this.updates = {};
    }

    get (name) {
      return this.values.get(name)
    }

    set (name, newValue) {
      this.values.set(name, newValue);
    }

    has (name) {
      return this.values.has(name)
    }

    setDirty (name) {
      this.dirty[name] = true;
    }

    isDirty (name) {
      return Boolean(this.dirty[name])
    }

    getUpdate (name) {
      return this.updates[name]
    }

    setUpdate (name, update) {
      this.updates[name] = update;
    }

    reset () {
      this.dirty = {};
      this.updates = {};
    }
  }

  const ANY = '@any';
  const STAGES = ['update', 'pre-render', 'render', 'post-render', 'position', 'finalize'];
  const DEFAULT_STAGE = 'update';
  const STAGE_IDX = STAGES.reduce((m, s, idx) => {
    m[s] = idx;
    return m
  }, {});

  class AppState extends AbstractAppState {
    _initialize (initialState) {
      super._initialize();

      const impl = this._getImpl();
      impl.slots = new Map();
      impl.schedule = null;
      impl.isFlowing = false;

      const names = Object.keys(initialState);
      names.forEach(name => {
        const initialValue = initialState[name];
        this._addProperty(name, initialValue);
      });
    }

    addObserver (deps, handler, observer, options = {}) {
      if (substance.isNil(handler)) throw new Error('Provided handler function is nil')
      if (!substance.isFunction(handler)) throw new Error('Provided handler is not a function')
      handler = handler.bind(observer);

      const impl = this._getImpl();
      const ID = impl.id;
      if (!options.stage) options.stage = DEFAULT_STAGE;
      const stage = options.stage;
      const slotId = this._getSlotId(stage, deps.slice());
      let slot = impl.slots.get(slotId);
      if (!slot) {
        slot = this._createSlot(slotId, stage, deps);
        impl.slots.set(slotId, slot);
      }
      if (!observer[ID]) observer[ID] = new Map();
      slot.addObserver(observer, {
        stage,
        deps,
        handler,
        options
      });
    }

    removeObserver (observer) {
      const impl = this._getImpl();
      const ID = impl.id;
      let entries = observer[ID] || [];
      entries.forEach(e => {
        e.slot.removeObserver(observer);
      });
      delete observer[ID];
    }

    propagateUpdates () {
      const impl = this._getImpl();
      if (impl.isFlowing) throw new Error('Already updating.')
      impl.isFlowing = true;
      try {
        const schedule = this._getSchedule();
        for (let slot of schedule) {
          if (slot.needsUpdate()) {
            slot.notifyObservers();
          }
        }
        this._reset();
      } finally {
        impl.isFlowing = false;
      }
    }

    propagate (...args) {
      return this.propagateUpdates(...args)
    }

    _getSlotId (stage, deps) {
      deps.sort();
      return `@${stage}:${deps.join(',')}`
    }

    _createSlot (id, stage, deps) {
      const impl = this._getImpl();
      impl.schedule = null;
      return new Slot(this, id, stage, deps)
    }

    // order slots by stage
    _getSchedule () {
      const impl = this._getImpl();
      let schedule = impl.schedule;
      if (!schedule) {
        schedule = [];
        impl.slots.forEach(s => schedule.push(s));
        schedule.sort((a, b) => STAGE_IDX[a.stage] - STAGE_IDX[b.stage]);
        impl.schedule = schedule;
      }
      return schedule
    }

    _reset () {
      super._reset();
      this._setDirty(ANY);
    }
  }

  class Slot {
    constructor (appState, id, stage, deps) {
      this._id = appState._getImpl().id;
      this.id = id;
      this.appState = appState;
      this.stage = stage;
      this.deps = deps;

      this.observers = new Set();
    }

    addObserver (observer, spec) {
      observer[this._id].set(this.id, {
        slot: this,
        spec
      });
      this.observers.add(observer);
    }

    removeObserver (observer) {
      this._deleteEntry(observer);
      this.observers.delete(observer);
    }

    needsUpdate () {
      const state = this.appState;
      for (let dep of this.deps) {
        if (state.isDirty(dep)) return true
      }
      return false
    }

    notifyObservers () {
      let observers = this._getObservers();
      for (let o of observers) {
        let entry = this._getEntryForObserver(o);
        // observer might have been disposed in the meantime
        if (!entry) continue
        this._notifyObserver(entry);
      }
    }

    _getObservers () {
      return this.observers
    }

    _getEntryForObserver (observer) {
      return observer[this._id].get(this.id)
    }

    _deleteEntry (observer) {
      delete observer[this._id].get(this.id);
    }

    _notifyObserver (entry) {
      entry.spec.handler();
    }
  }

  function createComponentContext (config) {
    return {
      componentRegistry: config.getComponentRegistry(),
      toolRegistry: config.getToolRegistry(),
      labelProvider: config.getLabelProvider(),
      iconProvider: config.getIconProvider()
    }
  }

  function createEditorContext (config, editorSession) {
    return Object.assign(createComponentContext(config), {
      config,
      editorSession: editorSession,
      appState: editorSession.editorState,
      surfaceManager: editorSession.surfaceManager,
      markersManager: editorSession.markersManager,
      globalEventHandler: editorSession.globalEventHandler,
      keyboardManager: editorSession.keyboardManager,
      findAndReplaceManager: editorSession.findAndReplaceManager,
      // TODO: I'd like to move towards 'config', instead of configurator
      // because it is a configurator only during configuration
      // In the app we want to have a configuration.
      // FIXME: Substance.Surface assumes to find context.configurator
      configurator: config
    })
  }

  // kind of an index that is used to dispatch updates
  class DocumentObserver {
    constructor (doc) {
      this.doc = doc;
      this.dirty = new Set();

      if (!doc.getIndex('relationships')) {
        doc.addIndex('relationships', new RelationshipIndex());
      }
      doc.on('document:changed', this._onDocumentChanged, this);
    }

    dispose () {
      this.doc.off(this);
    }

    // called by EditorState when updates have been propagated
    reset () {
      this.dirty = new Set();
    }

    setDirty (path) {
      this.dirty.add(String(path));
    }

    // TODO: this is built on top of the current implementation of
    // DocumentChange. We could try to consolidate and have just
    // one place where this information is derived
    _onDocumentChanged (change) {
      const doc = this.doc;
      const index = doc.getIndex('relationships');
      let dirty = this.dirty;
      Object.keys(change.updated).forEach(id => {
        dirty.add(id);
        let related = index.get(id);
        if (related) {
          // console.log('Capturing change via relationship', related)
          related.forEach(id => {
            dirty.add(id);
          });
        }
      });
    }
  }

  const ONE = Symbol('ONE');
  const MANY = Symbol('MANY');

  class RelationshipIndex extends substance.NodeIndex {
    constructor () {
      super();
      // a mapping from type to relational properties
      this._relationsByType = {};
      // the inverse index
      this._byTarget = new ValuesById();
    }

    get (targetId) {
      return this._byTarget.get(targetId)
    }

    select (node) { // eslint-disable-line no-unused-vars
      return true
    }

    clear () {
      this._byTarget.clear();
    }

    create (node) { // eslint-disable-line no-unused-vars
      let relations = this._getRelations(node);
      if (!relations) return
      for (let [name, type] of relations) {
        const val = node[name];
        if (!val) continue
        if (type === ONE) {
          this._add(val, node.id);
        } else {
          val.forEach(targetId => this._add(targetId, node.id));
        }
      }
    }

    delete (node) {
      let relations = this._getRelations(node);
      if (!relations) return
      for (let [name, type] of relations) {
        const val = node[name];
        if (!val) continue
        if (type === ONE) {
          this._remove(val, node.id);
        } else {
          val.forEach(targetId => this._remove(targetId, node.id));
        }
      }
    }

    update (node, path, newValue, oldValue) {
      let relations = this._getRelations(node);
      if (!relations) return
      let type = relations.get(path[1]);
      if (!type) return
      if (type === ONE) {
        this._remove(oldValue, node.id);
        this._add(newValue, node.id);
      } else {
        oldValue.forEach(targetId => this._remove(targetId, node.id));
        newValue.forEach(targetId => this._add(targetId, node.id));
      }
    }

    _getRelations (node) {
      let relations = this._relationsByType[node.type];
      if (relations === undefined) {
        relations = getRelations(node);
        if (relations.size === 0) relations = false;
        this._relationsByType[node.type] = relations;
      }
      return relations
    }

    _add (targetId, sourceId) {
      this._byTarget.add(targetId, sourceId);
    }

    _remove (targetId, sourceId) {
      this._byTarget.remove(targetId, sourceId);
    }
  }

  function getRelations (node) {
    let relations = new Map();
    let nodeSchema = node.getSchema();
    for (let property of nodeSchema) {
      if (property.isReference()) {
        const name = property.name;
        const type = property.isArray() ? MANY : ONE;
        relations.set(name, type);
      }
    }
    return relations
  }

  class ValuesById {
    constructor () {
      this._index = new Map();
    }
    get (key) {
      return this._index.get(key)
    }
    add (key, val) {
      let vals = this._index.get(key);
      if (!vals) {
        vals = new Set();
        this._index.set(key, vals);
      }
      vals.add(val);
    }
    remove (key, val) {
      let vals = this._index.get(key);
      if (vals) {
        vals.delete(val);
        if (vals.size === 0) {
          this._index.delete(key);
        }
      }
    }
    clear () {
      this._index = new Map();
    }
  }

  class DocumentSession extends substance.EventEmitter {
    constructor (doc) {
      super();

      this._document = doc;
      this._selection = substance.Selection.null;
      this._history = new substance.ChangeHistory();
      this._transaction = new substance.Transaction(doc);
    }

    getDocument () {
      return this._document
    }

    canUndo () {
      return this._history.canUndo()
    }

    canRedo () {
      return this._history.canRedo()
    }

    createSelection (...args) {
      return this._document.createSelection(...args)
    }

    /**
      Start a transaction to manipulate the document

      @param {function} transformation a function(tx) that performs actions on the transaction document tx

      @example

      ```js
      doc.transaction(function(tx, args) {
        tx.update(...)
        ...
        tx.setSelection(newSelection)
      })
      ```
    */
    transaction (transformation, info) {
      let change = this._recordChange(transformation, info);
      if (change) {
        this._commit(change, info);
      }
      return change
    }

    undo () {
      return this._undoRedo('undo')
    }

    redo () {
      return this._undoRedo('redo')
    }

    /*
      There are cases when we want to explicitly reset the change history of
      an editor session
    */
    resetHistory () {
      this._history.reset();
    }

    // EXPERIMENTAL: for certain cases it is useful to store volatile information on nodes
    // Then the data does not need to be disposed when a node is deleted.
    updateNodeStates (tuples, silent) {
      // using a pseudo change to get into the existing updating mechanism
      const doc = this._document;
      let change = new substance.DocumentChange([], {}, {});
      let info = { action: 'node-state-update' };
      change._extractInformation();
      change.info = info;
      for (let [id, state] of tuples) {
        let node = doc.get(id);
        if (!node) continue
        if (!node.state) node.state = {};
        Object.assign(node.state, state);
        change.updated[id] = true;
      }
      if (!silent) {
        doc._notifyChangeListeners(change, info);
        this.emit('change', change, info);
      }
    }

    _recordChange (transformation, info) {
      const t = this._transaction;
      info = info || {};
      t._sync();
      return t._recordChange(transformation, info)
    }

    _undoRedo (which) {
      const doc = this.getDocument();
      var from, to;
      if (which === 'redo') {
        from = this._history.undoneChanges;
        to = this._history.doneChanges;
      } else {
        from = this._history.doneChanges;
        to = this._history.undoneChanges;
      }
      var change = from.pop();
      if (change) {
        this._applyChange(change, {});
        this._transaction.__applyChange__(change);
        // move change to the opposite change list (undo <-> redo)
        to.push(doc.invert(change));
      }
      return change
    }

    _transformLocalChangeHistory (externalChange) {
      // Transform the change history
      // Note: using a clone as the transform is done inplace
      // which is ok for the changes in the undo history, but not
      // for the external change
      var clone = {
        ops: externalChange.ops.map(function (op) { return op.clone() })
      };
      substance.operationHelpers.transformDocumentChange(clone, this._history.doneChanges);
      substance.operationHelpers.transformDocumentChange(clone, this._history.undoneChanges);
    }

    _commit (change, info) {
      this._commitChange(change, info);
    }

    _commitChange (change, info = {}) {
      change.timestamp = Date.now();
      this._applyChange(change, info);
      if (info['history'] !== false && !info['hidden']) {
        let inverted = this.getDocument().invert(change);
        this._history.push(inverted);
      }
    }

    _applyChange (change, info) {
      if (!change) {
        console.error('FIXME: change is null.');
        return
      }
      const doc = this.getDocument();
      doc._apply(change);
      doc._notifyChangeListeners(change, info);
      this.emit('change', change, info);
    }

    _applyRemoteChange (change) {
      // console.log('EditorSession: applying remote change');
      if (change.ops.length > 0) {
        this._applyChange(change, { remote: true });
        // update the 'stage' and the undo-history too
        this._transaction.__applyChange__(change);
      }
    }
  }

  class SelectionStateReducer {
    constructor (appState) {
      this.appState = appState;
      appState.addObserver(['document', 'selection'], this.update, this, { stage: 'update' });
    }

    update () {
      const appState = this.appState;
      let doc = appState.get('document');
      let sel = appState.get('selection');
      let newState = this.deriveState(doc, sel);
      appState.set('selectionState', newState);
    }

    deriveState (doc, sel) {
      let state = this.createState(sel);
      this.deriveContainerSelectionState(state, doc, sel);
      this.deriveAnnoState(state, doc, sel);
      if (doc.getIndex('markers')) {
        this.deriveMarkerState(state, doc, sel);
      }
      return state
    }

    deriveContainerSelectionState (state, doc, sel) {
      if (sel.containerId) {
        let container = doc.get(sel.containerId);
        state.container = container;
        let startId = sel.start.getNodeId();
        let endId = sel.end.getNodeId();
        let startNode = doc.get(startId).getContainerRoot();
        let startPos = container.getPosition(startNode);
        if (startPos > 0) {
          state.previousNode = container.getNodeAt(startPos - 1);
        }
        state.isFirst = substance.selectionHelpers.isFirst(doc, sel.start);
        let endNode, endPos;
        if (endId === startId) {
          endNode = startNode;
          endPos = startPos;
        } else {
          endNode = doc.get(endId).getContainerRoot();
          endPos = container.getPosition(endNode);
        }
        if (endPos < container.getLength() - 1) {
          state.nextNode = container.getNodeAt(endPos + 1);
        }
        state.isLast = substance.selectionHelpers.isLast(doc, sel.end);
      }
    }

    deriveAnnoState (state, doc, sel) {
      // create a mapping by type for the currently selected annotations
      // create a mapping by type for the currently selected annotations
      let annosByType = {};
      function _add (anno) {
        if (!annosByType[anno.type]) {
          annosByType[anno.type] = [];
        }
        annosByType[anno.type].push(anno);
      }
      const propAnnos = substance.documentHelpers.getPropertyAnnotationsForSelection(doc, sel);
      propAnnos.forEach(_add);
      if (propAnnos.length === 1 && propAnnos[0].isInlineNode()) {
        state.isInlineNodeSelection = propAnnos[0].getSelection().equals(sel);
      }
      const containerId = sel.containerId;
      if (containerId) {
        const containerAnnos = substance.documentHelpers.getContainerAnnotationsForSelection(doc, sel, containerId);
        containerAnnos.forEach(_add);
      }
      state.annosByType = annosByType;
    }

    deriveMarkerState (state, doc, sel) {
      let markers = substance.documentHelpers.getMarkersForSelection(doc, sel);
      state.markers = markers;
    }

    createState (sel) {
      return new SelectionState(sel)
    }
  }

  class SelectionState {
    constructor (sel) {
      this.selection = sel || substance.Selection.null;

      Object.assign(this, {
        // all annotations under the current selection
        annosByType: null,
        // markers under the current selection
        markers: null,
        // flags for inline nodes
        isInlineNodeSelection: false,
        // container information (only for ContainerSelection)
        container: null,
        previousNode: null,
        nextNode: null,
        // if the previous node is one char away
        isFirst: false,
        // if the next node is one char away
        isLast: false
      });
    }
  }

  const ANY$1 = '@any';

  class EditorState extends AppState {
    _initialize (initialState) {
      super._initialize(initialState);

      if (!initialState.document) {
        throw new Error("'document' is required")
      }
      let doc = initialState.document;
      let impl = this._getImpl();
      // EXPERIMENTAL:
      // one observer for all slots that watches for document changes and marks paths as dirty
      // this is also used to broadcast other node based changes such as node state updates
      let documentObserver = new DocumentObserver(doc);
      impl.documentObserver = documentObserver;

      let selectionStateReducer = new SelectionStateReducer(this);
      selectionStateReducer.update();
      impl._selectionStateReducer = impl._selectionStateReducer;
    }

    dispose () {
      super.dispose();

      this._getImpl().documentObserver.dispose();
    }

    _createSlot (id, stage, deps) {
      const impl = this._getImpl();
      impl.schedule = null;
      if (deps.indexOf('document') !== -1) {
        return new DocumentSlot(this, id, stage, deps, impl.documentObserver)
      } else {
        return new Slot$1(this, id, stage, deps)
      }
    }

    _reset () {
      super._reset();
      this._getImpl().documentObserver.reset();
    }

    _getDocumentObserver () {
      return this._getImpl().documentObserver
    }
  }

  class Slot$1 {
    constructor (editorState, id, stage, deps) {
      this._id = editorState._getImpl().id;
      this.id = id;
      this.editorState = editorState;
      this.stage = stage;
      this.deps = deps;

      this.observers = new Set();
    }

    addObserver (observer, spec) {
      observer[this._id].set(this.id, {
        slot: this,
        spec
      });
      this.observers.add(observer);
    }

    removeObserver (observer) {
      this._deleteEntry(observer);
      this.observers.delete(observer);
    }

    needsUpdate () {
      const state = this.editorState;
      for (let dep of this.deps) {
        if (state.isDirty(dep)) return true
      }
      return false
    }

    notifyObservers () {
      let observers = this._getObservers();
      for (let o of observers) {
        let entry = this._getEntryForObserver(o);
        // observer might have been disposed in the meantime
        if (!entry) continue
        this._notifyObserver(entry);
      }
    }

    _getObservers () {
      return this.observers
    }

    _getEntryForObserver (observer) {
      let entries = observer[this._id];
      if (entries) {
        return entries.get(this.id)
      }
    }

    _deleteEntry (observer) {
      let entries = observer[this._id];
      if (entries) {
        entries.delete(this.id);
      }
    }

    _getDocumentChange () {
      let { change, info } = this._updates['document'];
      change.info = info;
      return change
    }

    _notifyObserver (entry) {
      const state = this.editorState;
      let spec = entry.spec;
      // TODO: we want to drop this auto-arguments completely
      // after having switched to a pure AppState based implementation
      // i.e. without using observers via EditorSession
      if (spec.deps.length === 1) {
        let name = spec.deps[0];
        switch (name) {
          case 'document': {
            let update = state.getUpdate('document') || {};
            spec.handler(update.change, update.info);
            break
          }
          default:
            spec.handler(state.get(name));
        }
      } else {
        spec.handler();
      }
    }
  }

  class DocumentSlot extends Slot$1 {
    constructor (editorState, id, stage, deps, documentObserver) {
      super(editorState, id, stage, deps);

      this.documentObserver = documentObserver;
      this.byPath = {'@any': new Set()};
    }

    addObserver (observer, spec) {
      super.addObserver(observer, spec);

      const index = this.byPath;
      let docSpec = spec.options.document;
      if (docSpec && docSpec.path) {
        let key = docSpec.path;
        let records = index[key];
        if (!records) {
          records = index[key] = new Set();
        }
        records.add(observer);
      } else {
        index[ANY$1].add(observer);
      }
    }

    removeObserver (observer) {
      const entries = observer[this._id];
      if (entries) {
        const entry = entries.get(this.id);
        const index = this.byPath;

        super.removeObserver(observer);

        let docSpec = entry.spec.options.document;
        if (docSpec && docSpec.path) {
          let key = docSpec.path;
          let records = index[key];
          records.delete(observer);
        } else {
          index[ANY$1].delete(observer);
        }
      }
    }

    _getObservers () {
      const state = this.editorState;
      if (!state.isDirty('document')) return this.observers

      // notify all observers that are affected by the change
      const index = this.byPath;
      let { change } = state.getUpdate('document');

      if (!change) {
        console.error('FIXME: expected to find a document change as update for document');
        return index[ANY$1]
      }

      let updated = this.documentObserver.dirty;
      let sets = [];
      // observers without a path spec are registered with path=undefined
      sets.push(index[ANY$1]);
      updated.forEach(id => {
        let set = index[id];
        if (set) sets.push(set);
      });
      let observers = new Set();
      sets.forEach(s => {
        s.forEach(o => observers.add(o));
      });
      return observers
    }
  }

  class SurfaceManager {
    constructor (editorState) {
      this.editorState = editorState;
      this.surfaces = {};

      editorState.addObserver(['selection', 'document'], this._onSelectionOrDocumentChange, this, { stage: 'post-render' });
      editorState.addObserver(['selection', 'document'], this._scrollSelectionIntoView, this, { stage: 'finalize' });
    }

    dispose () {
      this.editorState.off(this);
    }

    getSurface (name) {
      if (name) {
        return this.surfaces[name]
      }
    }

    getFocusedSurface () {
      console.error("DEPRECATED: use 'context.editorState.focusedSurface instead");
      return this.editorState.focusedSurface
    }

    registerSurface (surface) {
      const id = surface.getId();
      // console.log(`Registering surface ${id}.`, surface.__id__)
      if (this.surfaces[id]) {
        console.error(`A surface with id ${id} has already been registered.`);
      }
      this.surfaces[id] = surface;
    }

    unregisterSurface (surface) {
      let id = surface.getId();
      // console.log(`Unregistering surface ${id}.`, surface.__id__)
      let registeredSurface = this.surfaces[id];
      if (registeredSurface === surface) {
        delete this.surfaces[id];
      }
    }

    _onSelectionOrDocumentChange () {
      // console.log('SurfaceManager._onSelectionChange()')

      // Reducing state.focusedSurface (only if selection has changed)
      if (this.editorState.isDirty('selection')) {
        const selection = this.editorState.selection;
        // update state.focusedSurface
        this._reduceFocusedSurface(selection);
        // HACK: removing DOM selection *and* blurring when having a CustomSelection
        // otherwise we will receive events on the wrong surface
        // instead of bubbling up to GlobalEventManager
        if (selection && selection.isCustomSelection() && substance.platform.inBrowser) {
          window.getSelection().removeAllRanges();
          window.document.activeElement.blur();
        }
      }

      // TODO: this still needs to be improved. The DOM selection can be affected by other updates than document changes
      this._recoverDOMSelection();
    }

    _reduceFocusedSurface (sel) {
      const editorState = this.editorState;
      let surface = null;
      if (sel && sel.surfaceId) {
        surface = this.surfaces[sel.surfaceId];
      }
      editorState.focusedSurface = surface;
    }

    /*
      At the end of the update flow, make sure the surface is focused
      and displays the right DOM selection
    */
    _recoverDOMSelection () {
      // console.log('SurfaceManager._recoverDOMSelection()')
      const editorState = this.editorState;
      // do not rerender the selection if the editorSession has
      // been blurred, e.g., while some component, such as Find-And-Replace
      // dialog has the focus
      if (editorState.isBlurred) return
      let focusedSurface = editorState.focusedSurface;
      // console.log('focusedSurface', focusedSurface)
      if (focusedSurface && !focusedSurface.isDisabled()) {
        // console.log('Rendering selection on surface', focusedSurface.getId(), this.editorState.selection.toString())
        focusedSurface._focus();
        focusedSurface.rerenderDOMSelection();
      }
    }

    _scrollSelectionIntoView () {
      const editorState = this.editorState;
      let focusedSurface = editorState.focusedSurface;
      if (focusedSurface && !focusedSurface.isDisabled()) {
        focusedSurface.send('scrollSelectionIntoView');
      }
    }
  }

  const BEFORE = -1;
  const AFTER = 1;
  const PARENT = -2;
  const CHILD = 2;

  // TODO:this should go into Substance Land
  function compareDOMElementPosition (a, b) {
    if (a.el._isBrowserDOMElement) {
      let res = a.getNativeElement().compareDocumentPosition(b.getNativeElement());
      if (res & window.Node.DOCUMENT_POSITION_CONTAINS) {
        return CHILD
      } else if (res & window.Node.DOCUMENT_POSITION_CONTAINED_BY) {
        return PARENT
      } else if (res & window.Node.DOCUMENT_POSITION_PRECEDING) {
        return AFTER
      } else if (res & window.Node.DOCUMENT_POSITION_FOLLOWING) {
        return BEFORE
      } else {
        return 0
      }
    } else {
      console.error('FIXME: compareDOMElementPosition() is not implemented for MemoryDOMElement.');
      return 0
    }
  }

  class TextPropertyIndex {
    constructor () {
      this._index = new Map();
      this._sorted = null;
    }

    registerTextProperty (tp) {
      this._index.set(String(tp.getPath()), tp);
      // invalidating the topology on every structural change
      this._sorted = null;
    }

    unregisterTextProperty (tp) {
      this._index.delete(String(tp.getPath()));
      // invalidating the topology on every structural change
      this._sorted = null;
    }

    getTextProperty (path) {
      return this._index.get(String(path))
    }

    getSorted () {
      if (!this._sorted) {
        let tps = Array.from(this._index.values());
        tps.sort((a, b) => {
          if (a === b) return 0
          return compareDOMElementPosition(a, b)
        });
        this._sorted = tps;
      }
      return this._sorted
    }

    _hasProperty (pathStr) {
      return this._index.has(pathStr)
    }
  }

  /*
    A DocumentIndex implementation for keeping track of markers
  */
  class MarkersIndex {
    constructor (manager) {
      this._manager = manager;

      this._byKey = new substance.ArrayTree();
      this._documentMarkers = new substance.ArrayTree();
      this._surfaceMarkers = {};
      this._containerMarkers = {};
    }

    get (path, surfaceId) {
      let markers = this._documentMarkers[path] || [];
      if (surfaceId && this._surfaceMarkers[surfaceId]) {
        let surfaceMarkers = this._surfaceMarkers[surfaceId][path];
        if (surfaceMarkers) markers = markers.concat(surfaceMarkers);
      }
      // TODO support container scoped markers
      return markers
    }

    add (marker) {
      const key = marker._key;
      this._byKey.add(key, marker);
      this._add(marker);
    }

    // used to remove a single marker when invalidated
    remove (marker) {
      const key = marker._key;
      this._byKey.remove(key, marker);
      this._remove(marker);
    }

    // remove all markers for a given key
    clear (key) {
      let markers = this._byKey.get(key);
      markers.forEach((marker) => {
        this._remove(marker);
      });
    }

    clearPropertyMarkers (path, filter) {
      let arr = this._documentMarkers.get(path);
      for (let idx = arr.length - 1; idx >= 0; idx--) {
        if (filter(arr[idx])) arr.splice(idx, 1);
      }
    }

    addPropertyMarker (path, marker) {
      this._documentMarkers.add(path, marker);
    }

    _add (marker) {
      const dirtyProps = this._manager._dirtyProps;
      // console.log('Indexing marker', marker)
      const scope = marker.scope || 'document';
      switch (scope) {
        case 'document': {
          const path = marker.start.path;
          // console.log('Adding marker for path', path, marker)
          dirtyProps[path] = true;
          this._documentMarkers.add(path, marker);
          break
        }
        case 'surface': {
          if (!this._surfaceMarkers[marker.surfaceId]) {
            this._surfaceMarkers[marker.surfaceId] = new substance.ArrayTree();
          }
          const path = marker.start.path;
          dirtyProps[path] = true;
          this._surfaceMarkers[marker.surfaceId].add(path, marker);
          break
        }
        case 'container': {
          console.warn('Container scoped markers are not supported yet');
          break
        }
        default:
          console.error('Invalid marker scope.');
      }
    }

    _remove (marker) {
      const dirtyProps = this._manager._dirtyProps;
      const scope = marker.scope || 'document';
      switch (scope) {
        case 'document': {
          const path = marker.start.path;
          dirtyProps[path] = true;
          this._documentMarkers.remove(path, marker);
          break
        }
        case 'surface': {
          if (!this._surfaceMarkers[marker.surfaceId]) {
            this._surfaceMarkers[marker.surfaceId] = new substance.ArrayTree();
          }
          const path = marker.start.path;
          dirtyProps[path] = true;
          this._surfaceMarkers[marker.surfaceId].remove(path, marker);
          break
        }
        case 'container': {
          console.warn('Container scoped markers are not supported yet');
          break
        }
        default:
          console.error('Invalid marker scope.');
      }
    }

    // used for applying transformations
    _getAllCustomMarkers (path) {
      let markers = this._documentMarkers[path] || [];
      for (let surfaceId in this._surfaceMarkers) {
        if (!this._surfaceMarkers.hasOwnProperty(surfaceId)) continue
        let surfaceMarkers = this._surfaceMarkers[surfaceId][path];
        if (surfaceMarkers) markers = markers.concat(surfaceMarkers);
      }
      // TODO: support container markers
      return markers
    }

    _onDocumentChange (change) {
      change.ops.forEach((op) => {
        if (op.type === 'update' && op.diff._isTextOperation) {
          let markers = this._getAllCustomMarkers(op.path);
          let diff = op.diff;
          switch (diff.type) {
            case 'insert':
              this._transformInsert(markers, diff);
              break
            case 'delete':
              this._transformDelete(markers, diff);
              break
            default:
              //
          }
        }
      });
    }

    _transformInsert (markers, op) {
      const pos = op.pos;
      const length = op.str.length;
      if (length === 0) return
      markers.forEach((marker) => {
        // console.log('Transforming marker after insert')
        var start = marker.start.offset;
        var end = marker.end.offset;
        var newStart = start;
        var newEnd = end;
        if (pos >= end) return
        if (pos <= start) {
          newStart += length;
          newEnd += length;
          marker.start.offset = newStart;
          marker.end.offset = newEnd;
          return
        }
        if (pos < end) {
          newEnd += length;
          marker.end.offset = newEnd;
          // NOTE: right now, any change inside a marker
          // removes the marker, as opposed to changes before
          // which shift the marker
          this._remove(marker);
        }
      });
    }

    _transformDelete (markers, op) {
      const pos1 = op.pos;
      const length = op.str.length;
      const pos2 = pos1 + length;
      if (pos1 === pos2) return
      markers.forEach((marker) => {
        var start = marker.start.offset;
        var end = marker.end.offset;
        var newStart = start;
        var newEnd = end;
        if (pos2 <= start) {
          newStart -= length;
          newEnd -= length;
          marker.start.offset = newStart;
          marker.end.offset = newEnd;
        } else if (pos1 >= end) ; else {
          if (pos1 <= start) {
            newStart = start - Math.min(pos2 - pos1, start - pos1);
          }
          if (pos1 <= end) {
            newEnd = end - Math.min(pos2 - pos1, end - pos1);
          }
          // TODO: we should do something special when the change occurred inside the marker
          if (start !== end && newStart === newEnd) {
            this._remove(marker);
            return
          }
          if (start !== newStart) {
            marker.start.offset = newStart;
          }
          if (end !== newEnd) {
            marker.end.offset = newEnd;
          }
          this._remove(marker);
        }
      });
    }
  }

  // TODO: extract code that can be shared with original editorSession based implementation
  // TODO: let this act as a reducer for editorState.markers
  // EXPERIMENTAL: events emitted by this class are meant for internal use only
  class MarkersManager extends substance.EventEmitter {
    constructor (editorState) {
      super();

      this.editorState = editorState;
      // registry
      this._textProperties = new TextPropertyIndex();
      this._dirtyProps = {};
      this._markers = new MarkersIndex(this);

      // keep markers up-to-date, and record which text properties
      // are affected by a change
      editorState.addObserver(['document'], this._onChange, this, { stage: 'update' });
      editorState.addObserver(['@any'], this._updateProperties, this, { stage: 'render' });
    }

    dispose () {
      this.editorState.off(this);
    }

    setMarkers (key, markers) {
      this.clearMarkers(key);
      markers.forEach(m => this.addMarker(key, m));
    }

    addMarker (key, marker) {
      marker._key = key;
      if (!marker._isMarker) {
        marker = new substance.Marker(this.editorState.document, marker);
      }
      this._markers.add(marker);
    }

    clearMarkers (key) {
      this._markers.clear(key);
    }

    clearPropertyMarkers (path, filter) {
      this._markers.clearPropertyMarkers(path, filter);
      this._dirtyProps[path] = true;
    }

    addPropertyMarker (path, data) {
      // TODO: maybe provide a factory for creating markers
      this._markers.addPropertyMarker(path, new substance.Marker(this.editorState.document, data));
      this._dirtyProps[path] = true;
    }

    register (textPropertyComponent) {
      this._textProperties.registerTextProperty(textPropertyComponent);
      // ATTENTION: see note about events above
      this.emit('text-property:registered', textPropertyComponent.getPath());
    }

    deregister (textPropertyComponent) {
      this._textProperties.unregisterTextProperty(textPropertyComponent);
      // ATTENTION: see note about events above
      this.emit('text-property:deregistered', textPropertyComponent.getPath());
    }

    getMarkers (path, opts) {
      opts = opts || {};
      let doc = this.editorState.document;
      let annos = doc.getAnnotations(path) || [];
      let markers = this._markers.get(path, opts.surfaceId, opts.containerId);
      return annos.concat(markers)
    }

    _onChange (change) {
      // console.log('MarkersManager.onChange()', change)
      this._markers._onDocumentChange(change);
      this._recordDirtyTextProperties(change);
    }

    _recordDirtyTextProperties (change) {
      const textProperties = this._textProperties;
      // mark all updated props per se as dirty
      substance.forEach(change.updated, (val, id) => {
        if (textProperties._hasProperty(id)) {
          this._dirtyProps[id] = true;
          // ATTENTION: see note about events above
          this.emit('text-property:changed', id);
        }
      });
    }

    /*
      Trigger rerendering of all dirty text properties.
    */
    _updateProperties () {
      // console.log('MarkersManager._updateProperties()')
      Object.keys(this._dirtyProps).forEach((path) => {
        let textPropertyComponent = this._textProperties.getTextProperty(path);
        if (textPropertyComponent) {
          this._updateTextProperty(textPropertyComponent);
        }
      });
      this._dirtyProps = {};
    }

    /*
      Here a dirty text property is rerendered via calling setState()
    */
    _updateTextProperty (textPropertyComponent) {
      let path = textPropertyComponent.getPath();
      let markers = this.getMarkers(path, {
        surfaceId: textPropertyComponent.getSurfaceId(),
        containerId: textPropertyComponent.getContainerId()
      });
      // console.log('## providing %s markers for %s', markers.length, path)
      textPropertyComponent.setState({
        markers: markers
      });
    }
  }

  class GlobalEventHandler extends substance.AbstractGlobalEventHandler {
    constructor (editorState) {
      super();

      this.editorState = editorState;
    }

    getSelection () {
      return this.editorState.selection
    }
  }

  class KeyboardManager extends substance.AbstractKeyboardManager {
    constructor (bindings, commandCallback, contextProvider) {
      super();

      this.contextProvider = contextProvider;
      this.bindings = {};

      bindings.forEach(({ key, spec }) => {
        if (!spec.command) throw new Error("'spec.command' is required")
        let hook = () => {
          return commandCallback(spec.command)
        };
        const type = spec.type || 'keydown';
        if (type !== 'textinput') {
          key = substance.parseKeyCombo(key);
        }
        // initializing on-the-fly
        if (!this.bindings[type]) { this.bindings[type] = {}; }
        if (!this.bindings[type][key]) { this.bindings[type][key] = []; }
        this.bindings[type][key].push(hook);
      });
    }

    _getBindings (type, key) {
      let bindingsByType = this.bindings[type];
      if (bindingsByType) {
        return bindingsByType[key]
      }
    }

    _getContext () {
      return this.contextProvider.context
    }
  }

  class CommandManager {
    constructor (appState, deps, commands, contextProvider) {
      this.appState = appState;
      this.commands = commands;
      this.contextProvider = contextProvider;

      appState.addObserver(deps, this.reduce, this, { stage: 'update' });
    }

    dispose () {
      this.appState.off(this);
    }

    reduce () {
      const appState = this.appState;
      const commandStates = this._getCommandStates();
      appState.set('commandStates', commandStates);
    }

    _getCommandStates () {
      const context = this.contextProvider.context;
      const params = new substance.HandlerParams(context);
      return this.commands.reduce((m, command) => {
        m[command.getName()] = command.getCommandState(params, context);
        return m
      }, {})
    }

    executeCommand (commandName, params = {}) {
      const appState = this.appState;
      const cmdState = appState.commandStates[commandName];
      if (!cmdState || cmdState.disabled) {
        return false
      } else {
        const cmd = this.commands.get(commandName);
        const context = this.contextProvider.context;
        params = Object.assign(new substance.HandlerParams(context), params);
        params.commandState = cmdState;
        cmd.execute(params, context);
        return true
      }
    }
  }

  const DISABLED = Object.freeze({
    disabled: true
  });

  /*
    Experimental CommandManager that makes use of the XML schema
    to inhibit commands which are not allowed at the current position.
  */
  class SchemaDrivenCommandManager extends CommandManager {
    constructor (...args) {
      super(...args);

      this._initialize();
    }

    _initialize () {
      // EXPERIMENTAL: categorizing commands to be able to disable commands according to schema rules
      const annotationCommands = [];
      const insertCommands = [];
      const switchTypeCommands = [];
      const otherCommands = [];
      this.commands.forEach(command => {
        if (command.isAnnotationCommand()) {
          annotationCommands.push(command);
        } else if (command.isInsertCommand()) {
          insertCommands.push(command);
        } else if (command.isSwitchTypeCommand()) {
          switchTypeCommands.push(command);
        } else {
          otherCommands.push(command);
        }
      });
      this._annotationCommands = annotationCommands;
      this._insertCommands = insertCommands;
      this._switchTypeCommands = switchTypeCommands;
      this._otherCommands = otherCommands;

      this._allDisabled = _disabled(Array.from(this.commands.values()));
    }

    _getCommandStates () {
      const context = this.contextProvider.context;
      const appState = context.appState;
      const params = new substance.HandlerParams(context);
      const doc = appState.document;
      const sel = appState.selection;
      const selectionState = appState.selectionState;
      const isBlurred = appState.isBlurred;
      const noSelection = !sel || sel.isNull() || !sel.isAttached();

      const commandStates = Object.assign({}, this._allDisabled);
      // all editing commands are disabled if
      // - this editorSession is blurred,
      // - or the selection is null,
      // - or the selection is inside a custom editor
      if (!isBlurred && !noSelection && !sel.isCustomSelection()) {
        const path = sel.start.path;
        const node = doc.get(path[0]);

        // TODO: is this really necessary. It rather seems to be
        // a workaround for other errors, i.e., the selection pointing
        // to a non existing node
        // If really needed we should document why, and in which case.
        if (!node) {
          throw new Error('FIXME: explain when this happens')
        }

        const nodeProp = _getNodeProp(node, path);
        const isInsideText = nodeProp ? nodeProp.isText() : false;

        // annotations can only be applied on PropertySelections inside
        // text, and not on an inline-node
        if (isInsideText && sel.isPropertySelection() && !selectionState.isInlineNodeSelection) {
          let targetTypes = nodeProp.targetTypes || [];
          Object.assign(commandStates, _disabledIfDisallowedTargetType(this._annotationCommands, targetTypes, params, context));
        }

        // for InsertCommands the selection must be inside a ContainerEditor
        let container = _getContainer(node);
        if (container && container.isContainer()) {
          let contentProp = _getNodeProp(container, container.getContentPath());
          if (contentProp) {
            let targetTypes = contentProp.targetTypes || [];
            Object.assign(commandStates, _disabledIfDisallowedTargetType(this._insertCommands, targetTypes, params, context));
            Object.assign(commandStates, _disabledIfDisallowedTargetType(this._switchTypeCommands, targetTypes, params, context));
          }
        }
      }

      // other commands must check their own preconditions
      Object.assign(commandStates, _getCommandStates(this._otherCommands, params, context));

      return commandStates
    }
  }

  function _getContainer (node) {
    let containerRoot = node.getContainerRoot();
    if (containerRoot) {
      return containerRoot.getParent()
    }
  }

  function _getNodeProp (node, path) {
    if (path.length === 2) {
      let propName = substance.last(path);
      let prop = node.getSchema().getProperty(propName);
      if (!prop) console.error('Could not find property for path', path, node);
      return prop
    }
  }

  function _disabled (commands) {
    return commands.reduce((m, c) => {
      m[c.getName()] = DISABLED;
      return m
    }, {})
  }

  function _disabledIfDisallowedTargetType (commands, targetTypes, params, context) {
    return commands.reduce((m, cmd) => {
      const type = cmd.getType();
      const name = cmd.getName();
      if (targetTypes.indexOf(type) > -1) {
        m[name] = cmd.getCommandState(params, context);
      } else {
        m[name] = DISABLED;
      }
      return m
    }, {})
  }

  function _getCommandStates (commands, params, context) {
    return commands.reduce((m, command) => {
      m[command.getName()] = command.getCommandState(params, context);
      return m
    }, {})
  }

  const UPDATE_DELAY = 200;

  class FindAndReplaceManager {
    constructor (editorSession, appState, markersManager) {
      this._editorSession = editorSession;
      this._appState = appState;
      this._markersManager = markersManager;
      this._dirty = new Set();

      this._updateSearchDebounced = substance.debounce(this._updateSearch.bind(this), UPDATE_DELAY);

      // EXPERIMENTAL: we use the MarkersManager to detect changes on text-properties
      markersManager.on('text-property:registered', this._onTextPropertyChanged, this);
      markersManager.on('text-property:deregistered', this._onTextPropertyChanged, this);
      markersManager.on('text-property:changed', this._onTextPropertyChanged, this);

      appState.addObserver(['document'], this._onDocumentChange, this, { stage: 'render' });
    }

    openDialog (enableReplace) {
      enableReplace = Boolean(enableReplace);
      let state = this._getState();
      if (state.enabled) {
        // update state if 'showReplace' has changed
        if (state.showReplace !== enableReplace) {
          state.showReplace = Boolean(enableReplace);
          this._updateState(state);
        }
      } else {
        state.enabled = true;
        state.showReplace = Boolean(enableReplace);
        // resetting dirty flags as we do a full search initially
        this._dirty = new Set();
        this.search();
      }
    }

    closeDialog () {
      let state = this._getState();
      if (!state.enabled) return
      state.enabled = false;
      this._clearHighlights();
      // Note: recovering the selection here
      this._updateState(state, 'recoverSelection');
    }

    search () {
      let state = this._getState();
      if (state.pattern) {
        this._searchAndHighlight();
      } else {
        this._clear();
      }
      state.cursor = -1;
      this._updateState(state);
      // ATTENTION: scrolling to the first match (if available)
      // this needs to be done after rolling out the state update
      // so that the markers have been rendered already
      if (state.count > 0) {
        this.next();
      }
    }

    next () {
      let state = this._getState();
      this._nav('forward');
      this._updateState(state);
    }

    previous () {
      let state = this._getState();
      this._nav('back');
      this._updateState(state);
    }

    setSearchPattern (pattern) {
      let state = this._getState();
      if (state.pattern !== pattern) {
        state.pattern = pattern;
        this.search();
      }
    }

    setReplacePattern (replacePattern) {
      let state = this._getState();
      if (state.replacePattern !== replacePattern) {
        state.replacePattern = replacePattern;
        this._updateState(state);
      }
    }

    replaceNext () {
      let state = this._getState();
      // ATTENTION: special handling after manual changes, while search dialog is open
      // in this case we do a forced 'next()' when using 'replaceNext()'
      if (state._forceNav) {
        state._forceNav = false;
        this.next();
        return
      }
      if (state.replacePattern) {
        let hasReplaced = false;
        if (state.cursor >= 0) {
          let m = this._getMatchAt(state.cursor);
          if (m) {
            // ATTENTION: we are not changing the search result on changes with action type: 'replace'
            // Instead we are doing it here so that
            this._editorSession.transaction(tx => {
              this._replace(tx, m, state);
            }, { action: 'replace' });
            // updating the result for the current text property
            // and propagating changes so that so that text properties are updated
            this._updateSearchForProperty(String(m.path));
            this._appState.propagateUpdates();
            // set the cursor back and scroll to the next
            state.cursor--;
            this._nav('forward');
            this._updateState(state);
            hasReplaced = true;
          }
        }
        if (!hasReplaced) {
          // otherwise seek to the next match position first
          this.next();
        }
      }
    }

    replaceAll () {
      let state = this._getState();
      if (!state.matches) return
      let allMatches = [];
      state.matches.forEach(_matches => {
        allMatches = allMatches.concat(_matches);
      });
      this._editorSession.transaction(tx => {
        for (let idx = allMatches.length - 1; idx >= 0; idx--) {
          this._replace(tx, allMatches[idx], state);
        }
      }, { action: 'replace-all' });
      state.matches = new Map();
      state.count = 0;
      state.cursor = -1;
      this._updateState(state);
    }

    toggleCaseSensitivity () {
      this._toggleOption('caseSensitive');
    }

    toggleRegexSearch () {
      this._toggleOption('regexSearch');
    }

    toggleFullWordSearch () {
      this._toggleOption('fullWord');
    }

    _getState () {
      return this._appState.get('findAndReplace') || FindAndReplaceManager.defaultState()
    }

    _toggleOption (optionName) {
      let state = this._getState();
      state[optionName] = !state[optionName];
      this.search();
    }

    _updateState (state, recoverSelection) {
      const appState = this._appState;
      // HACK: touching appState.selection because we want that the applications recovers the selection
      if (recoverSelection) {
        appState._setDirty('selection');
      }
      // console.log('Updating appState.findAndReplace', state)
      appState.set('findAndReplace', state);
      appState.propagateUpdates();
    }

    _searchAndHighlight () {
      // re-start the search
      this._clearHighlights();
      this._search();
      this._addHighlights();
    }

    _search () {
      let state = this._getState();
      let matches = new Map();
      let count = 0;
      let pattern = state.pattern;
      let opts = state;
      if (pattern) {
        let tps = this._getTextProperties();
        for (let tp of tps) {
          // console.log('... searching for matches in ', tp.getPath())
          let _matches = this._searchInProperty(tp, pattern, opts);
          // if (_matches.length > 0) console.log('found %s matches', _matches.length)
          count += _matches.length;
          matches.set(String(tp.getPath()), _matches);
        }
      }
      state.matches = matches;
      state.count = count;
    }

    _updateSearch () {
      let state = this._getState();
      if (!state.enabled || !state.pattern || this._dirty.size === 0) return

      let count = state.count;
      let matches = state.matches;
      for (let key of this._dirty) {
        this._updateSearchForProperty(key);
      }
      state.count = count;
      state.matches = matches;
      // HACK: need to make sure that the selection is recovered here
      this._updateState(state, 'recoverSelection');
      this._dirty = new Set();
    }

    _updateSearchForProperty (key) {
      let markersManager = this._markersManager;
      let state = this._getState();
      let matches = state.matches;
      let count = state.count;
      let _matches = matches.get(key);
      if (_matches) {
        count -= _matches.length;
      }
      let path = key.split(',');
      markersManager.clearPropertyMarkers(path, m => m.type === 'find-marker');
      let tp = this._getTextProperty(key);
      if (tp) {
        _matches = this._searchInProperty(tp, state.pattern, state);
        count += _matches.length;
        matches.set(key, _matches);
        this._addHighlightsForProperty(path, _matches);
      } else {
        matches.delete(key);
      }
      state.count = count;
    }

    _searchInProperty (tp, pattern, opts) {
      let path = tp.getPath();
      return _findInText(tp.getText(), pattern, opts).map(m => {
        // add an id so that we can find it later, e.g. for scroll-to
        m.id = substance.uuid();
        m.path = path;
        m.textProperty = tp;
        return m
      })
    }

    /*
      In case of a regexp search the replacement string allows for the following patterns
      - "$$": Inserts a "$".
      - "$&": Inserts the matched substring.
      - "$`": Inserts the portion of the string that precedes the matched substring.
      - "$'": Inserts the portion of the string that follows the matched substring.
      - "$n": Where n is a positive integer less than 100, inserts the nth parenthesized submatch string, provided the first argument was a RegExp object. Note that this is 1-indexed.
    */
    _replace (tx, m, options) {
      tx.setSelection({
        type: 'property',
        path: m.path,
        startOffset: m.start,
        endOffset: m.end
      });
      let newText;
      // TODO: we should allow to use regex in replace string too
      // for that we would take the string from the match
      // and apply native String replace to g
      if (options.regexSearch) {
        let text = substance.documentHelpers.getTextForSelection(tx, tx.selection);
        let findRe = new RegExp(options.pattern);
        newText = text.replace(findRe, options.replacePattern);
      } else {
        newText = options.replacePattern;
      }
      tx.insertText(newText);
    }

    _clear () {
      let state = this._getState();
      this._clearHighlights();
      state.matches = new Map();
      state.count = 0;
    }

    _clearHighlights () {
      const markersManager = this._markersManager;
      const state = this._getState();
      if (state.matches) {
        state.matches.forEach((_, key) => {
          let path = key.split(',');
          markersManager.clearPropertyMarkers(path, m => m.type === 'find-marker');
        });
      }
    }

    _addHighlights () {
      const state = this._getState();
      if (state.matches) {
        state.matches.forEach((matches, key) => {
          let path = key.split(',');
          this._addHighlightsForProperty(path, matches);
        });
      }
    }

    // TODO: don't know yet how we want to update Markers incrementally
    _addHighlightsForProperty (path, matches) {
      let markersManager = this._markersManager;
      matches.forEach(m => {
        markersManager.addPropertyMarker(path, {
          type: 'find-marker',
          id: m.id,
          start: {
            path,
            offset: m.start
          },
          end: {
            path,
            offset: m.end
          }
        });
      });
    }

    _getTextProperties () {
      // HACK: accessing TextPropertyIndex via private member of markersManager
      return this._markersManager._textProperties.getSorted()
    }

    _getTextProperty (key) {
      // HACK: accessing TextPropertyIndex via private member of markersManager
      return this._markersManager._textProperties.getTextProperty(key)
    }

    _nav (direction) {
      let state = this._getState();
      let [cursor, match] = this._getNext(direction);
      if (match) {
        state.cursor = cursor;
        this._scrollToMatch(match);
      }
    }

    _getNext (direction) {
      // TODO: support a selection relative navigation
      // as a first iteration we will do this independently from the selection
      let state = this._getState();
      let idx;
      if (direction === 'forward') {
        idx = Math.min(state.count - 1, state.cursor + 1);
      } else {
        idx = Math.max(0, state.cursor - 1);
      }
      return [ idx, this._getMatchAt(idx) ]
    }

    _getMatchAt (idx) {
      // Note: because we are storing matching grouped by properties
      // this is a but nasty
      let state = this._getState();
      if (state.matches) {
        for (let [, matches] of state.matches) {
          if (idx >= matches.length) {
            idx -= matches.length;
          } else {
            return matches[idx]
          }
        }
      }
    }

    _scrollToMatch (match) {
      let state = this._getState();
      // HACKIDHACK: instead of relying on rerendering, we toggle the hightlight here
      // which is also much faster, and still pretty safe, because we throw markers on every change
      if (state.marker) state.marker.el.removeClass('sm-active');
      let tp = match.textProperty;
      let marker = tp.find(`.sm-find-marker[data-id="${match.id}"]`);
      // FIXME: when doing replace it seems that we are not good yet with navigating through the matches
      // this guard should not be necessary if everything is working
      if (marker) {
        marker.el.addClass('sm-active');
        state.marker = marker;
        tp.send('scrollElementIntoView', marker.el);
      }
    }

    _onTextPropertyChanged (path) {
      this._dirty.add(String(path));
    }

    _onDocumentChange (change) {
      // skip changes caused by replaceNext() and replaceAll()
      if (change.info.action === 'replace' || change.info.action === 'replace-all') return
      // HACK: this is a bit hacky but should work. When the user has changed the text we leave a mark in the state
      // so that we can force a 'next()' when 'replaceNext()' is called
      let state = this._getState();
      state._forceNav = true;
      // Note: when running tests updating the search result synchronously
      if (substance.platform.test) {
        this._updateSearch();
      } else {
        // otherwise this is done debounced
        this._updateSearchDebounced();
      }
    }

    static defaultState () {
      return {
        enabled: false,
        pattern: '',
        showReplace: false,
        replacePattern: '',
        caseSensitive: false,
        fullWord: false,
        regexSearch: false,
        matches: null,
        count: 0,
        cursor: 0
      }
    }
  }

  function _createRegExForPattern (pattern) {
    return pattern.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, '\\$&') // eslint-disable-line no-useless-escape
  }

  function _findInText (text, pattern, opts = {}) {
    if (!opts.regexSearch) {
      pattern = _createRegExForPattern(pattern);
    }
    if (opts.fullWord) {
      pattern = '\\b' + pattern + '\\b';
    }
    let matches = [];
    try {
      let matcher = new RegExp(pattern, opts.caseSensitive ? 'g' : 'gi');
      let match;
      while ((match = matcher.exec(text))) {
        matches.push({
          start: match.index,
          end: matcher.lastIndex
        });
      }
    } catch (err) {}
    return matches
  }

  // NOTE: Rewriting former EditorSession.

  function EditorSessionMixin (DocumentSession) {
    class EditorSession extends DocumentSession {
      constructor (docSession, config, contextProvider, initialState = {}) {
        super(docSession.getDocument(), config);

        if (!contextProvider) contextProvider = { context: { editorSession: this } };
        let doc = docSession.getDocument();

        // HACK: this is still not good. The problem is, that we create a DocumentSession very very early, when loading the archive
        // an editor session is created on top of it, replacing the original document session in the child context, and forwarding events.
        this._documentSession = docSession;

        this.config = config;
        this.contextProvider = contextProvider;

        let editorState = new EditorState(Object.assign({
          document: doc,
          selection: substance.Selection.nullSelection,
          selectionState: {},
          focusedSurface: null,
          commandStates: {},
          hasUnsavedChanges: false,
          isBlurred: false,
          overlayId: null,
          findAndReplace: FindAndReplaceManager.defaultState()
        }, initialState));
        let surfaceManager = new SurfaceManager(editorState);
        let markersManager = new MarkersManager(editorState);
        let globalEventHandler = new GlobalEventHandler(editorState);
        let keyboardManager = new KeyboardManager(config.getKeyboardShortcuts(), (commandName, params) => {
          return this.executeCommand(commandName, params)
        }, contextProvider);
        let commandManager = new SchemaDrivenCommandManager(editorState,
          // update commands when document or selection have changed
          ['document', 'selection'],
          config.getCommands(),
          contextProvider
        );
        let findAndReplaceManager = new FindAndReplaceManager(this, editorState, markersManager);

        this.editorState = editorState;
        this.surfaceManager = surfaceManager;
        this.markersManager = markersManager;
        this.globalEventHandler = globalEventHandler;
        this.keyboardManager = keyboardManager;
        this.commandManager = commandManager;
        this.findAndReplaceManager = findAndReplaceManager;

        doc.on('document:changed', this._onDocumentChange, this);

        // EXPERIMENTAL:
        // registering a 'reducer' that resets overlayId whenever the selection changes
        editorState.addObserver(['selection'], this._resetOverlayId, this, { stage: 'update' });
      }

      dispose () {
        this.getDocument().off(this);
        this.editorState.off(this);
        this.editorState.dispose();
      }

      initialize () {
        // TODO: is this the right place?
        // initial reduce step
        this.commandManager.reduce();
      }

      // HACK: see above; we need to propagate events to the original document session too
      emit (...args) {
        this._documentSession.emit(...args);
        super.emit(...args);
      }

      getConfigurator () {
        return this.config
      }

      getContext () {
        return this.contextProvider.context
      }

      getSelection () {
        return this.editorState.selection
      }

      getSelectionState () {
        return this.editorState.selectionState
      }

      getCommandStates () {
        return this.editorState.commandStates
      }

      getFocusedSurface () {
        return this.editorState.focusedSurface
      }

      isBlurred () {
        return Boolean(this.editorState.isBlurred)
      }

      hasUnsavedChanges () {
        return Boolean(this.editorState.hasUnsavedChanges)
      }

      setSelection (sel) {
        // console.log('EditorSession.setSelection()', sel)
        if (!sel) sel = substance.Selection.nullSelection;
        if (sel && substance.isPlainObject(sel)) {
          sel = this.getDocument().createSelection(sel);
        }
        if (sel && !sel.isNull()) {
          if (!sel.surfaceId) {
            let fs = this.getFocusedSurface();
            if (fs) {
              sel.surfaceId = fs.id;
            }
          }
        }
        if (!sel.isCustomSelection()) {
          if (!sel.surfaceId) {
            _addSurfaceId(sel, this);
          }
          if (!sel.containerId) {
            _addContainerId(sel, this);
          }
        }
        this.editorState.selection = sel;
        this.editorState.propagateUpdates();
        return sel
      }

      transaction (fn, info) {
        const editorState = this.editorState;
        // NOTE: using this to reveal problems with propagation of document changes
        // if (editorState.isDirty('document')) throw new Error('FIXME: the previous change has not been propagated yet', editorState.getUpdate('document'))

        let tx = this._transaction.tx;
        // HACK: setting the state of 'tx' here
        // TODO: find out a way to pass a tx state for the transaction
        // then we could derive this state from the editorState
        let selBefore = editorState.selection;
        tx.selection = selBefore;
        let change = this._recordChange(fn, info);
        if (change) {
          let selAfter = tx.selection;
          this._setSelection(selAfter);
          change.before = { selection: selBefore };
          change.after = { selection: selAfter };
          // console.log('EditorSession.transaction()', change)
          this._commit(change, info);
          editorState.propagateUpdates();
        }
        return change
      }

      undo () {
        let change = super.undo();
        if (change) this._setSelection(change.after.selection);
        this.editorState.propagateUpdates();
      }

      redo () {
        let change = super.redo();
        if (change) this._setSelection(change.after.selection);
        this.editorState.propagateUpdates();
      }

      onUpdate (...args) {
        console.error('DEPRECATED: use EditorState API');
        return this._registerObserver('update', args)
      }

      onPreRender (...args) {
        console.error('DEPRECATED: use EditorState API');
        return this._registerObserver('pre-render', args)
      }

      onRender (...args) {
        if (_shouldDisplayDeprecatedWarning()) {
          console.error('DEPRECATED: use EditorState API');
        }
        return this._registerObserver('render', args)
      }

      onPostRender (...args) {
        if (_shouldDisplayDeprecatedWarning()) {
          console.error('DEPRECATED: use EditorState API');
        }
        return this._registerObserver('post-render', args)
      }

      onPosition (...args) {
        if (_shouldDisplayDeprecatedWarning()) {
          console.error('DEPRECATED: use EditorState API');
        }
        return this._registerObserver('position', args)
      }

      onFinalize (...args) {
        if (_shouldDisplayDeprecatedWarning()) {
          console.error('DEPRECATED: use EditorState API');
        }
        return this._registerObserver('finalize', args)
      }

      // ATTENTION: while we want to get rid of the former event registration
      // we still need this to avoid breaking legacy code
      off (...args) {
        if (args.length === 1) {
          let observer = args[0];
          this.editorState.removeObserver(observer);
        }
        super.off(...args);
      }

      _onDocumentChange (change, info) {
        const editorState = this.editorState;
        // ATTENTION: ATM we are using a DocumentChange to implement node states
        // Now it happens, that something that reacts on document changes (particularly a CitationManager)
        // updates the node state during a flow.
        // HACK: In that case we 'merge' the state update into the already propagated document change
        if (editorState.isDirty('document') && info.action === 'node-state-update') {
          let propagatedChange = editorState.getUpdate('document').change;
          Object.assign(propagatedChange.updated, change.updated);
        } else {
          this.editorState._setUpdate('document', { change, info });
          this.editorState.hasUnsavedChanges = true;
        }
      }

      executeCommand (commandName, params) {
        return this.commandManager.executeCommand(commandName, params)
      }

      _registerObserver (stage, args) {
        let resource, handler, observer, opts;
        if (!substance.isString(args[0])) {
          ([handler, observer, opts] = args);
          resource = '@any';
        } else {
          ([resource, handler, observer, opts] = args);
        }
        let options = { stage };
        if (opts) options[resource] = opts;
        this.editorState.addObserver([resource], handler, observer, options);
      }

      _setSelection (sel) {
        const doc = this.getDocument();
        if (!sel) {
          sel = substance.Selection.nullSelection;
        } else {
          sel.attach(doc);
        }
        this.editorState.selection = sel;
        return sel
      }

      _transformSelection (change) {
        var oldSelection = this.getSelection();
        var newSelection = substance.operationHelpers.transformSelection(oldSelection, change);
        return newSelection
      }

      _applyRemoteChange (change) {
        // console.log('EditorSession: applying remote change');
        if (change.ops.length > 0) {
          super._applyRemoteChange(change);
          this._setSelection(this._transformSelection(change));
          this.editorState.propagateUpdates();
        }
      }

      _resetOverlayId () {
        const overlayId = this.editorState.overlayId;
        // overlayId === path.join('.') => if selection is value &&
        // Overlays of value components (ManyRelationshipComponent, SingleRelationship)
        // need to remain open if the selection is a value selection
        let sel = this.getSelection();
        if (sel && sel.customType === 'value') {
          let valueId = String(sel.data.path);
          if (overlayId !== valueId) {
            this.editorState.set('overlayId', valueId);
          }
        } else {
          this.editorState.set('overlayId', null);
        }
      }
    }

    return EditorSession
  }

  function _addSurfaceId (sel, editorSession) {
    if (sel && !sel.isNull() && !sel.surfaceId) {
      // TODO: We could check if the selection is valid within the given surface
      let surface = editorSession.getFocusedSurface();
      if (surface) {
        sel.surfaceId = surface.id;
      }
    }
  }

  function _addContainerId (sel, editorSession) {
    if (sel && !sel.isNull() && sel.surfaceId && !sel.containerId) {
      let surface = editorSession.surfaceManager.getSurface(sel.surfaceId);
      if (surface) {
        let containerId = surface.getContainerId();
        if (containerId) {
          // console.log('Adding containerId', containerId)
          sel.containerId = containerId;
        }
      }
    }
  }

  const _exceptions = [
    /TextPropertyEditor/,
    /IsolatedNodeComponent/,
    /IsolatedInlineNodeComponent/,
    /TextInput/
  ];
  function _shouldDisplayDeprecatedWarning () {
    let caller = _getCaller(2);
    for (let e of _exceptions) {
      if (e.exec(caller)) return false
    }
    return true
  }

  function _getCaller (level) {
    let stack = new Error().stack;
    let lines = stack.split(/\n/);
    let line = lines[2 + level];
    return line
  }

  class AnnotationComponent extends substance.AnnotationComponent {
    getClassNames () {
      return `sc-annotation sm-${this.props.node.type}`
    }
  }

  const ENABLED = Object.freeze({ disabled: false });

  class FindAndReplaceCommand extends substance.Command {
    getCommandState (params, context) {
      switch (this.config.action) {
        case 'open-find':
        case 'open-replace': {
          return ENABLED
        }
        case 'find-next':
        case 'find-previous': {
          let fnrState = context.appState.findAndReplace;
          if (fnrState && fnrState.count > 0) {
            return ENABLED
          } else {
            return substance.Command.DISABLED
          }
        }
      }
    }

    execute (params, context) {
      let fnr = context.findAndReplaceManager;
      switch (this.config.action) {
        case 'open-find': {
          fnr.openDialog();
          break
        }
        case 'open-replace': {
          fnr.openDialog('replace');
          break
        }
        case 'find-next': {
          fnr.next();
          break
        }
        case 'find-previous': {
          fnr.previous();
          break
        }
      }
    }
  }

  const UPDATE_DELAY$1 = 300;

  class FindAndReplaceDialog extends substance.Component {
    constructor (...args) {
      super(...args);

      // debounce updates when patterns change, but not during tests
      if (!substance.platform.test) {
        this._updatePattern = substance.debounce(this._updatePattern.bind(this), UPDATE_DELAY$1);
        this._updateReplacePattern = substance.debounce(this._updateReplacePattern.bind(this), UPDATE_DELAY$1);
      }
    }

    didMount () {
      this.context.appState.addObserver(['findAndReplace'], this._onUpdate, this, { stage: 'render' });
    }

    dispose () {
      this.context.appState.removeObserver(this);
    }

    render ($$) {
      let state = this._getState();
      let el = $$('div').addClass('sc-find-and-replace-dialog');
      el.append(
        this._renderHeader($$),
        this._renderFindSection($$),
        this._renderReplaceSection($$)
      );
      if (!state.enabled) {
        el.addClass('sm-hidden');
      }
      el.on('keydown', this._onKeydown);
      return el
    }

    _renderTitle ($$) {
      const state = this._getState();
      let title = state.showReplace ? this.getLabel(`find-replace-title-${this.props.viewName}`) : this.getLabel(`find-title-${this.props.viewName}`);
      let options = [];
      if (state.caseSensitive) options.push('case-sensitive-title');
      if (state.fullWord) options.push('whole-word-title');
      if (state.regexSearch) options.push('regex-title');
      if (options.length > 0) title += ' (' + options.map(o => this.getLabel(o)).join(', ') + ')';
      return $$('div').addClass('se-title').append(title)
    }

    _renderHeader ($$) {
      const state = this._getState();
      const Button = this.getComponent('button');
      return $$('div').addClass('se-header').append(
        this._renderTitle($$),
        $$('div').addClass('se-group sm-options').append(
          $$(Button, {
            tooltip: this.getLabel('find-case-sensitive'),
            active: state.caseSensitive,
            theme: this.props.theme
          }).addClass('sm-case-sensitive').append('Aa')
            .on('click', this._toggleCaseSensitivity),
          $$(Button, {
            tooltip: this.getLabel('find-whole-word'),
            active: state.fullWord,
            theme: this.props.theme
          }).addClass('sm-whole-word').append('Abc|')
            .on('click', this._toggleFullWordSearch),
          $$(Button, {
            tooltip: this.getLabel('find-regex'),
            active: state.regexSearch,
            theme: this.props.theme
          }).addClass('sm-regex-search').append('.*')
            .on('click', this._toggleRegexSearch),
          $$(Button, {
            tooltip: this.getLabel('close'),
            theme: this.props.theme
          }).addClass('sm-close')
            .append(
              this.context.iconProvider.renderIcon($$, 'close')
            )
            .on('click', this._close)
        )
      )
    }

    _renderFindSection ($$) {
      const state = this._getState();
      const Button = this.getComponent('button');
      return $$('div').addClass('se-section').addClass('sm-find').append(
        $$('div').addClass('se-group sm-input').append(
          this._renderPatternInput($$),
          this._renderStatus($$)
        ),
        $$('div').addClass('se-group sm-actions').append(
          $$(Button, {
            tooltip: this.getLabel('find-next'),
            theme: this.props.theme,
            disabled: state.count < 1
          }).addClass('sm-next')
            .append(this.getLabel('next'))
            .on('click', this._findNext),
          $$(Button, {
            tooltip: this.getLabel('find-previous'),
            theme: this.props.theme,
            disabled: state.count < 1
          }).addClass('sm-previous')
            .append(this.getLabel('previous'))
            .on('click', this._findPrevious)
        )
      )
    }

    _renderReplaceSection ($$) {
      let state = this._getState();
      if (state.showReplace) {
        const Button = this.getComponent('button');
        return $$('div').addClass('se-section').addClass('sm-replace').append(
          $$('div').addClass('se-group sm-input').append(
            this._renderReplacePatternInput($$)
          ),
          $$('div').addClass('se-group sm-actions').append(
            $$(Button, {
              tooltip: this.getLabel('replace'),
              theme: this.props.theme,
              disabled: state.count < 1
            }).addClass('sm-replace')
              .append(this.getLabel('replace'))
              .on('click', this._replaceNext),
            $$(Button, {
              tooltip: this.getLabel('replace-all'),
              theme: this.props.theme,
              disabled: state.count < 1
            }).addClass('sm-replace-all')
              .append(this.getLabel('replace-all'))
              .on('click', this._replaceAll)
          )
        )
      }
    }

    _renderPatternInput ($$) {
      let state = this._getState();
      return $$('input').ref('pattern')
        .attr({
          type: 'text',
          placeholder: this.getLabel('find'),
          'tabindex': 500
        })
        .val(state.pattern)
        .on('keydown', this._onPatternKeydown)
        .on('input', this._updatePattern)
    }

    _renderReplacePatternInput ($$) {
      let state = this._getState();
      return $$('input').ref('replacePattern')
        .attr({
          type: 'text',
          placeholder: this.getLabel('replace'),
          'tabindex': 500
        })
        .val(state.replacePattern)
        .on('keydown', this._onReplacePatternKeydown)
        .on('input', this._updateReplacePattern)
    }

    _renderStatus ($$) {
      let state = this._getState();
      let el = $$('span').addClass('se-status');
      if (state.count > 0) {
        let current = state.cursor === -1 ? '?' : String(state.cursor + 1);
        el.append(`${current} of ${state.count}`);
      } else if (state.pattern) {
        el.append(this.getLabel('no-result'));
      }
      return el
    }

    _grabFocus () {
      let state = this._getState();
      let input = state.showReplace ? this.refs.replacePattern : this.refs.pattern;
      input.el.focus();
    }

    _getState () {
      return this.context.appState.get('findAndReplace')
    }

    _getManager () {
      return this.context.findAndReplaceManager
    }

    _close () {
      this._getManager().closeDialog();
    }

    _findNext () {
      this._getManager().next();
    }

    _findPrevious () {
      this._getManager().previous();
    }

    _replaceNext () {
      this._getManager().replaceNext();
    }

    _replaceAll () {
      this._getManager().replaceAll();
    }

    _updatePattern () {
      // console.log('FindAndReplaceDialog._updatePattern()', this.refs.pattern.val())
      this._getManager().setSearchPattern(this.refs.pattern.val());
    }

    _updateReplacePattern () {
      this._getManager().setReplacePattern(this.refs.replacePattern.val());
    }

    _toggleCaseSensitivity () {
      this._getManager().toggleCaseSensitivity();
    }

    _toggleFullWordSearch () {
      this._getManager().toggleFullWordSearch();
    }

    _toggleRegexSearch () {
      this._getManager().toggleRegexSearch();
    }

    _onUpdate () {
      // if this dialog is made visible, auto-focus the respective pattern input field
      // TODO: maybe we should let the app control this
      let wasHidden = this.el.hasClass('sm-hidden');
      this.rerender();
      let isHidden = this.el.hasClass('sm-hidden');
      if (wasHidden && !isHidden) {
        this._grabFocus();
      }
    }

    _onKeydown (e) {
      if (e.keyCode === substance.keys.ESCAPE) {
        e.stopPropagation();
        e.preventDefault();
        this._close();
      }
    }

    _onPatternKeydown (e) {
      if (e.keyCode === substance.keys.ENTER) {
        e.stopPropagation();
        e.preventDefault();
        this._findNext();
      }
    }

    _onReplacePatternKeydown (e) {
      if (e.keyCode === substance.keys.ENTER) {
        e.stopPropagation();
        e.preventDefault();
        this._replaceNext();
      }
    }
  }

  var FindAndReplacePackage = {
    name: 'find-and-replace',
    configure: function (config, userConfig) {
      config.addComponent('find-and-replace-dialog', FindAndReplaceDialog);
      config.addComponent('find-marker', AnnotationComponent);

      config.addCommand('open-find', FindAndReplaceCommand, {
        commandGroup: 'find-and-replace',
        action: 'open-find'
      });
      config.addCommand('open-replace', FindAndReplaceCommand, {
        commandGroup: 'find-and-replace',
        action: 'open-replace'
      });
      config.addKeyboardShortcut('CommandOrControl+F', { command: 'open-find' });
      // there are different conventions for opening replace
      if (substance.platform.isMac) {
        config.addKeyboardShortcut('CommandOrControl+Alt+F', { command: 'open-replace' });
      } else {
        config.addKeyboardShortcut('CommandOrControl+H', { command: 'open-replace' });
      }
      config.addLabel('find-and-replace-title', {
        en: 'Find and replace'
      });
      config.addLabel('find', {
        en: 'Find'
      });
      config.addLabel('find-next', {
        en: 'Next match'
      });
      config.addLabel('find-previous', {
        en: 'Previous match'
      });
      config.addLabel('find-case-sensitive', {
        en: 'Match Case'
      });
      config.addLabel('find-whole-word', {
        en: 'Match Whole Word'
      });
      config.addLabel('find-regex', {
        en: 'Use Regular Expression'
      });
      config.addLabel('replace', {
        en: 'Replace'
      });
      config.addLabel('replace-all', {
        en: 'Replace All'
      });
      config.addLabel('next', {
        en: 'Next'
      });
      config.addLabel('previous', {
        en: 'Previous'
      });
      config.addLabel('find-title-manuscript', {
        en: 'Find in Article'
      });
      config.addLabel('find-title-metadata', {
        en: 'Find in Metadata'
      });
      config.addLabel('no-result', {
        en: 'No results'
      });
      config.addLabel('find-replace-title-manuscript', {
        en: 'Find and replace in article'
      });
      config.addLabel('find-replace-title-metadata', {
        en: 'Find and replace in metadata'
      });
      config.addLabel('case-sensitive-title', {
        en: 'Case Sensitive'
      });
      config.addLabel('whole-word-title', {
        en: 'Whole Word'
      });
      config.addLabel('regex-title', {
        en: 'Regex'
      });
      config.addIcon('close', { 'fontawesome': 'fa-close' });
    }
  }

  class ValueModel {
    constructor (api, path) {
      this._api = api;
      this._path = path;
    }

    get id () {
      return String(this._path)
    }

    getValue () {
      return this._api._getValue(this._path)
    }

    setValue (val) {
      this._api._setValue(this._path, val);
    }

    isEmpty () {
      return substance.isNil(this.getValue())
    }

    get _value () { return this.getValue() }
  }

  class BooleanModel extends ValueModel {
    get type () { return 'boolean-model' }

    // Note: Nil is interpreted as false, and false is thus also interpreted as isEmpty()
    isEmpty () {
      return !this.getValue()
    }
  }

  class NumberModel extends ValueModel {
    get type () { return 'number-model' }
  }

  class StringModel extends ValueModel {
    get type () { return 'string-model' }

    isEmpty () {
      let value = this.getValue();
      return substance.isNil(value) || value.length === 0
    }
  }

  class TextModel extends StringModel {
    get type () { return 'text-model' }
  }

  class ObjectModel extends ValueModel {
    get type () { return 'object-model' }
  }

  class ChildModel extends ValueModel {
    constructor (api, path, targetTypes) {
      super(api, path);

      this._targetTypes = targetTypes;
    }

    get type () { return 'child-model' }

    getChild () {
      let id = this.getValue();
      if (id) {
        return this._api.getModelById(id)
      }
    }

    isEmpty () {
      let child = this.getChild();
      return (!child || child.isEmpty())
    }
  }

  function isFlowContentEmpty (api, path) {
    let ids = api._getValue(path);
    if (ids.length === 0) return true
    // otherwise considered only empty if container has only one empty child node
    if (ids > 1) return false
    let first = api.getModelById(ids[0]);
    // being robust agains broken refs
    if (first && first.isEmpty) {
      return first.isEmpty()
    }
  }

  class _ContainerModel extends ValueModel {
    constructor (api, path, targetTypes) {
      super(api, path);

      this._targetTypes = targetTypes;
    }

    get length () { return this.getValue().length }

    getValue () {
      return super.getValue() || []
    }

    isEmpty () {
      return isFlowContentEmpty(this._api, this._path)
    }

    _getItems () {
      return this.getValue().map(id => this._api.getModelById(id))
    }
  }

  class ChildrenModel extends _ContainerModel {
    constructor (api, path, targetTypes) {
      super(api, path);

      this._targetTypes = targetTypes;
    }

    get type () { return 'children-model' }

    getChildren () {
      return this._getItems()
    }

    appendChild (child) {
      this._api._appendChild(this._path, child);
    }

    removeChild (child) {
      this._api._removeChild(this._path, child);
    }
  }

  class _RelationshipModel extends ValueModel {
    constructor (api, path, targetTypes) {
      super(api, path);

      this._targetTypes = targetTypes;
    }

    getAvailableTargets () {
      return _getAvailableRelationshipOptions(this._api, this._targetTypes)
    }
  }

  function _getAvailableRelationshipOptions (api, targetTypes) {
    let items = targetTypes.reduce((items, targetType) => {
      let collection = api.getCollectionForType(targetType);
      return items.concat(collection.getItems())
    }, []);
    return items.map(item => _getRelationshipOption(api, item.id))
  }

  function _getRelationshipOption (api, id) {
    return {
      id,
      toString () {
        return api.renderEntity(api.getModelById(id))
      }
    }
  }

  class SingleRelationshipModel extends _RelationshipModel {
    get type () { return 'single-relationship-model' }

    toggleTarget (target) {
      let currentTargetId = this.getValue();
      let newTargetId;
      if (currentTargetId === target.id) {
        newTargetId = undefined;
      } else {
        newTargetId = target.id;
      }
      this._api._setValue(this._path, newTargetId);
    }
  }

  class ManyRelationshipModel extends _RelationshipModel {
    get type () { return 'many-relationship-model' }

    getValue () {
      return super.getValue() || []
    }

    isEmpty () {
      return this.getValue().length === 0
    }

    toggleTarget (target) {
      this._api._toggleRelationship(this._path, target.id);
    }
  }

  class AnyModel extends ValueModel {
    get type () { return 'any-model' }
  }

  function createValueModel (api, type, path, targetTypes) {
    let valueModel;
    switch (type) {
      case 'boolean': {
        valueModel = new BooleanModel(api, path);
        break
      }
      case 'number': {
        valueModel = new NumberModel(api, path);
        break
      }
      case 'string': {
        valueModel = new StringModel(api, path);
        break
      }
      case 'text': {
        valueModel = new TextModel(api, path);
        break
      }
      case 'object': {
        valueModel = new ObjectModel(api, path);
        break
      }
      case 'child': {
        valueModel = new ChildModel(api, path, targetTypes);
        break
      }
      case 'children': {
        valueModel = new ChildrenModel(api, path, targetTypes);
        break
      }
      case 'many-relationship': {
        valueModel = new ManyRelationshipModel(api, path, targetTypes);
        break
      }
      case 'single-relationship': {
        valueModel = new SingleRelationshipModel(api, path, targetTypes);
        break
      }
      default:
        valueModel = new AnyModel(api, path);
    }
    return valueModel
  }

  class NodeModelProperty {
    constructor (api, node, nodeProperty) {
      this._api = api;
      this._node = node;
      this._nodeProperty = nodeProperty;
      this._valueModel = this._createValueModel();
    }

    get name () { return this._nodeProperty.name }

    get type () { return this._valueModel.type }

    get model () { return this._valueModel }

    get targetTypes () { return this._nodeProperty.targetTypes || [] }

    isRequired () {
      return this._api._isPropertyRequired(this._node.type, this.name)
    }
    isEmpty () {
      return this._valueModel.isEmpty()
    }
    _createValueModel () {
      const api = this._api;
      const nodeProperty = this._nodeProperty;
      const path = [this._node.id, this.name];
      let type = nodeProperty.type;
      if (nodeProperty.isReference()) {
        if (nodeProperty.isArray()) {
          if (nodeProperty.isOwned()) {
            type = 'children';
          } else {
            type = 'many-relationship';
          }
        } else {
          if (nodeProperty.isOwned()) {
            type = 'child';
          } else {
            type = 'single-relationship';
          }
        }
      }
      return createValueModel(api, type, path, nodeProperty.targetTypes)
    }
  }

  class AbstractModel {
    constructor (api) {
      this._api = api;
    }

    getProperties () {
      return this._properties
    }

    getProperty (propName) {
      let properties = this.getProperties();
      return properties.find(prop => {
        return prop.name === propName
      })
    }

    getPropertyValue (propName) {
      const prop = this.getProperty(propName);
      return prop.valueModel
    }
  }

  class NodeModel extends AbstractModel {
    constructor (api, node) {
      super(api);
      if (!node) throw new Error("'node' is required")
      this._node = node;
      this._properties = [];
      this._propertiesByName = new Map();
      this._initialize();
    }

    get type () { return this._node.type }

    get id () { return this._node.id }

    isEmpty () {
      const node = this._node;
      // TODO: what does isEmpty() mean on a general node?
      // ATM we assume that this only makes sense for TextNodes and Containers
      if (node.isText()) {
        return node.isEmpty()
      } else if (node.isContainer()) {
        return isFlowContentEmpty(this._api, node.getContentPath())
      }
      return false
    }

    _initialize () {
      const api = this._api;
      const node = this._node;
      const nodeSchema = node.getSchema();
      for (let nodeProperty of nodeSchema) {
        if (nodeProperty.name === 'id') continue
        let modelProperty = new NodeModelProperty(api, node, nodeProperty);
        this._properties.push(modelProperty);
        this._propertiesByName.set(modelProperty.name, modelProperty);
      }
    }

    _getPropertyModel (name) {
      return this._propertiesByName.get(name)
    }
  }

  const MODELCLASS_CACHE = new Map();

  class NodeModelFactory {
    static create (api, node) {
      let ModelClass = MODELCLASS_CACHE.get(node.type);
      if (!ModelClass) {
        class _GeneratedModel extends NodeModel {}
        let nodeSchema = node.getSchema();
        for (let prop of nodeSchema) {
          // skip id and type
          if (prop.name === 'id') continue
          _GeneratedModel.prototype[_getter(prop.name)] = function () {
            return this._getPropertyModel(prop.name)
          };
        }
        ModelClass = _GeneratedModel;
        MODELCLASS_CACHE.set(node.type, ModelClass);
      }
      return new ModelClass(api, node)
    }
  }

  function _getter (name) {
    return ['get', name[0].toUpperCase(), name.slice(1)].join('')
  }

  class AbstractAPI {
    getModelById (id) {
      let node = this._getDocument().get(id);
      if (node) {
        return this._getModelForNode(node)
      }
    }

    _getDocument () {
      throw new Error('This method is abstract')
    }

    _getDocumentSession () {
      throw new Error('This method is abstract')
    }

    _getValue (path) {
      return this._getDocument().get(path)
    }

    _getModelForNode (node) {
      return NodeModelFactory.create(this, node)
    }

    // TODO: rethink. this should come from some configuration
    // Note: we do not want to use the node schema here, because
    // we want to treat violations in a soft manner
    // _isPropertyRequired (type, propertyName) {
    //   let REQUIRED = REQUIRED_PROPERTIES[type]
    //   if (REQUIRED) return REQUIRED.has(propertyName)
    //   return false
    // }
    _isPropertyRequired (type, propertyName) { // eslint-disable-line
      return false
    }

    // EXPERIMENTAL: want to be able to retrieve a higher-level API
    // This can be overridden to provide some context specific API,
    // e.g. such as a TableAPI.
    _getEditorAPI (context) {
      throw new Error('This method is abstract')
    }

    _setValue (path, value) {
      this._getDocumentSession().transaction(tx => {
        tx.set(path, value);
        tx.setSelection(_customSelection(path));
      });
    }

    _toggleRelationship (path, id) {
      this._getDocumentSession().transaction(tx => {
        let ids = tx.get(path);
        let idx = ids.indexOf(id);
        if (idx === -1) {
          tx.update(path, {type: 'insert', pos: ids.length, value: id});
        } else {
          tx.update(path, {type: 'delete', pos: idx, value: id});
        }
        tx.setSelection(_customSelection(path));
      });
    }

    _addModel (data) {
      let node;
      this._getDocumentSession().transaction(tx => {
        node = tx.create(data);
        // TODO: it would be good to set the selection here
        // e.g. to the first text property
        tx.setSelection(null);
      });
      return this._getModelForNode(node)
    }

    _removeModel (model) {
      let node;
      this._getDocumentSession().transaction((tx) => {
        node = tx.delete(model.id);
        tx.setSelection(null);
      });
      return this._getModelForNode(node)
    }

    _appendChild (path, child) {
      let node;
      this._getDocumentSession().transaction((tx) => {
        node = tx.create(child);
        let children = tx.get(path);
        tx.update(path, {type: 'insert', pos: children.length, value: node.id});
        tx.setSelection(_customSelection(path));
      });
      return this._getModelForNode(node)
    }

    _removeChild (path, child) {
      let node;
      this._getDocumentSession().transaction((tx) => {
        node = tx.delete(child.id);
        let children = tx.get(path);
        let idx = children.indexOf(child.id);
        if (idx > -1) {
          tx.update(path, {type: 'delete', pos: idx, value: child.id});
        }
        tx.setSelection(_customSelection(path));
      });
      return this._getModelForNode(node)
    }

    _clearFlowContent (tx, path) {
      let ids = tx.get(path);
      if (ids && ids.length > 0) {
        // first clear the content
        for (let idx = ids.length - 1; idx >= 0; idx--) {
          let id = ids[idx];
          tx.update(path, { type: 'delete', pos: idx, value: id });
          substance.documentHelpers.deleteNode(tx, tx.get(id));
        }
      }
    }
  }

  function _customSelection (path) {
    return {
      type: 'custom',
      customType: 'value',
      data: {
        path,
        propertyName: path[1]
      },
      surfaceId: path[0]
    }
  }

  function addModelObserver (model, fn, comp, options = {}) {
    let stage = options.stage || 'render';
    // NodeModels and alike
    if (model._node) {
      // NOTE: here we exploit internal knowledge about node types and only register
      // for updates that are relevant on this level
      // E.g., for an XMLElementNode we are only interested in changes to `<id>._childNodes`
      // TODO: allow to register for multiple paths, e.g. `childNodes` and `attributes`
      let node = model._node;
      let selector;
      if (node._elementType === 'element') {
        selector = {
          path: [node.id, '_childNodes']
        };
      } else {
        selector = {
          path: [node.id]
        };
      }
      comp.context.appState.addObserver(['document'], fn, comp, {
        stage,
        document: selector
      });
    // PropertyModels
    } else if (model._path) {
      comp.context.appState.addObserver(['document'], fn, comp, {
        stage,
        document: {
          path: model._path
        }
      });
    } else if (model._isCompositeModel) {
      console.error('FIXME: Implement addObserver() for CompositeModel');
    }
  }

  class ValueComponent extends substance.Component {
    didMount () {
      const appState = this.context.appState;
      const path = this._getPath();
      appState.addObserver(['document'], this._rerenderOnModelChange, this, {
        stage: 'render',
        document: { path }
      });
    }

    dispose () {
      const appState = this.context.appState;
      appState.removeObserver(this);
    }

    _rerenderOnModelChange () {
      // console.log('Rerendering ValueComponent after model update:', this._getPath())
      this.rerender();
    }

    _getPath () {
      return this.props.model._path
    }
  }

  class CheckboxInput extends substance.Component {
    render ($$) {
      const isChecked = Boolean(this.props.value);
      const icon = isChecked ? 'fa-check-square-o' : 'fa-square-o';
      let el = $$('div').addClass('sc-checkbox')
        .on('click', this._onClick);
      el.append(
        // TODO: use icon provider
        $$(substance.FontAwesomeIcon, { icon: icon }).addClass('se-icon')
      );
      return el
    }

    _onClick (e) {
      e.preventDefault();
      e.stopPropagation();
      this.send('toggleValue');
    }
  }

  class BooleanComponent extends ValueComponent {
    getActionHandlers () {
      return {
        toggleValue: this._toggleValue
      }
    }

    render ($$) {
      const model = this.props.model;
      const value = model.getValue();
      let el = $$('div').addClass('sc-boolean');
      if (!this.context.editable) {
        el.addclass('sm-readonly');
      }
      el.append(
        $$(CheckboxInput, { value }).ref('checkbox')
      );
      return el
    }

    _toggleValue () {
      if (this.context.editable) {
        const model = this.props.model;
        this.props.model.setValue(!model.getValue());
      }
    }
  }

  function getComponentForModel (context, model) {
    let componentRegistry = context.componentRegistry;
    let ComponentClass = componentRegistry.get(model.type);
    if (!ComponentClass) {
      let node = model._node;
      if (node) {
        let superTypes = node.getSchema().getSuperTypes();
        for (let superType of superTypes) {
          ComponentClass = componentRegistry.get(superType);
          if (ComponentClass) break
        }
      }
    }
    if (!ComponentClass) {
      throw new Error(`No Component class registered for model type ${model.type}.`)
    }
    return ComponentClass
  }

  class ChildComponent extends ValueComponent {
    render ($$) {
      const child = this.props.model.getChild();
      let ComponentClass = getComponentForModel(this.context, child);
      return $$(ComponentClass, {
        model: child,
        node: child._node
      // FIXME: there seems to be an issue with forwarding components:
      // it seems that in this case not all involved components get disposed correctly
      }).ref('child')
    }
  }

  class ChildrenModelComponent extends ValueComponent {
    render ($$) {
      let el = $$('div').addClass('sc-children');
      if (!this.context.editable) {
        el.addClass('sm-readonly');
      }
      el.append(
        this._renderChildren($$)
      );
      return el
    }

    _renderChildren ($$) {
      // TODO: we need a good UX pattern for canonically created editors
      // for hierarchical nodes
      // For example, 'ref-contrib' nodes are not used using
      // a general N-to-M-relationship but as parent-child relationship.
      // I.e. a ref-contrib should only be used by one 'reference' node
      const model = this.props.model;
      let children = model.getChildren();
      return children.map(child => {
        return $$('div').addClass('se-child').html(
          this.context.api.renderEntity(child)
        )
      })
    }
  }

  /*
    Note: this implementation is different to the core implementation
    in that regard that it serializes child nodes before their parents
  */
  class JSONConverterNew {
    importDocument (doc, json) {
      if (!json.nodes) {
        throw new Error('Invalid JSON format.')
      }
      // the json should just be an array of nodes
      var nodes = json.nodes;
      doc.import(tx => {
        nodes.forEach(node => tx.create(node));
      });
      return doc
    }

    exportDocument (doc) {
      var schema = doc.getSchema();
      var json = {
        schema: {
          name: schema.name
        },
        nodes: []
      };
      let visited = {};

      function _export (node) {
        if (!node) return
        if (visited[node.id]) return
        visited[node.id] = true;
        let nodeSchema = node.getSchema();
        nodeSchema.getOwnedProperties().forEach(prop => {
          let val = node[prop.name];
          if (substance.isArray(val)) {
            val.forEach(id => {
              _export(doc.get(id));
            });
          } else {
            _export(doc.get(val));
          }
        });
        json.nodes.push(node.toJSON());
      }

      substance.forEach(doc.getNodes(), node => _export(node));

      return json
    }
  }

  const INLINENODES = ['a', 'b', 'big', 'i', 'small', 'tt', 'abbr', 'acronym', 'cite', 'code', 'dfn', 'em', 'kbd', 'strong', 'samp', 'time', 'var', 'bdo', 'br', 'img', 'map', 'object', 'q', 'script', 'span', 'sub', 'sup', 'button', 'input', 'label', 'select', 'textarea'].reduce((m, n) => { m[n] = true; return m }, {});

  class ClipboardNew {
    copy (clipboardData, context) {
      // content specific manipulation API
      let api = context.api;
      let snippet = api.copy();
      this._setClipboardData(clipboardData, context, snippet);
    }

    cut (clipboardData, context) {
      let api = context.api;
      let snippet = api.cut();
      this._setClipboardData(clipboardData, context, snippet);
    }

    paste (clipboardData, context, options = {}) {
      let types = {};
      for (let i = 0; i < clipboardData.types.length; i++) {
        types[clipboardData.types[i]] = true;
      }
      let html = types['text/html'] ? clipboardData.getData('text/html') : '';
      let success = false;
      if (html && !options.plainTextOnly) {
        success = this._pasteHtml(html, context, options);
      }
      if (!success) {
        // in all other cases we fall back to plain-text
        let plainText = types['text/plain'] ? clipboardData.getData('text/plain') : '';
        this._pasteText(plainText, context, options);
      }
    }

    _setClipboardData (clipboardData, context, snippet) {
      let plainText = this._createClipboardText(context, snippet);
      let html = this._createClipboardHtml(context, snippet);
      clipboardData.setData('text/plain', plainText);
      clipboardData.setData('text/html', html);
    }

    _createClipboardText (context, snippet) {
      let configurator = context.configurator;
      let textExporter = configurator.getExporter('text');
      return textExporter.exportNode(snippet.getContainer())
    }

    _createClipboardHtml (context, snippet) {
      let htmlExporter = context.configurator.getExporter('html');
      let elements = htmlExporter.convertContainer(snippet.getContainer());
      // special treatment for a text snippet
      let snippetHtml;
      if (elements.length === 1 && elements[0].attr('data-id') === substance.documentHelpers.TEXT_SNIPPET_ID) {
        snippetHtml = elements[0].innerHTML;
      } else {
        snippetHtml = elements.map(el => {
          return el.outerHTML
        }).join('');
      }
      let jsonConverter = new JSONConverterNew();
      let jsonStr = JSON.stringify(jsonConverter.exportDocument(snippet));
      let substanceContent = `<script id="substance-clipboard" type="application/json">${jsonStr}</script>`;
      let html = '<html><head>' + substanceContent + '</head><body>' + snippetHtml + '</body></html>';
      return html
    }

    _pasteHtml (html, context, options = {}) {
      let htmlDoc;
      try {
        htmlDoc = substance.DefaultDOMElement.parseHTML(html);
      } catch (err) {
        console.error('Could not parse HTML received from the clipboard', err);
        return false
      }

      // when copying from a substance editor we store JSON in a script tag in the head
      // If the import fails e.g. because the schema is incompatible
      // we fall back to plain HTML import
      let snippet;
      if (html.search(/script id=.substance-clipboard./) >= 0) {
        let substanceData = htmlDoc.find('#substance-clipboard');
        if (substanceData) {
          let jsonStr = substanceData.textContent;
          try {
            snippet = this._importFromJSON(context, jsonStr);
          } finally {
            if (!snippet) {
              console.error('Could not convert clipboard content.');
            }
          }
        }
      }
      if (!snippet) {
        let state = {};
        Object.assign(state, this._detectApplicationType(html, htmlDoc));
        // Under windows and in Microsoft Word we can exploit the fact
        // that the paste content is wrapped inside <!--StartFragment--> and <!--EndFragment-->
        if (substance.platform.isWindows || state.isMicrosoftWord) {
          // very strange: this was not working at some day
          // let match = /<!--StartFragment-->(.*)<!--EndFragment-->/.exec(html)
          // ... but still this
          const START_FRAGMENT = '<!--StartFragment-->';
          const END_FRAGMENT = '<!--EndFragment-->';
          let mStart = html.indexOf(START_FRAGMENT);
          if (mStart >= 0) {
            let mEnd = html.indexOf(END_FRAGMENT);
            let fragment = html.slice(mStart + START_FRAGMENT.length, mEnd);
            htmlDoc = substance.DefaultDOMElement.parseHTML(fragment);
          }
        }
        // Note: because we are parsing the HTML not as snippet
        // the parser will always create a full HTML document
        // and there will always be a <body>
        // In case, the clipboard HTML is just a snippet
        // the body will contain the parsed snippet
        let body = htmlDoc.find('body');
        body = this._sanitizeBody(state, body);
        if (!body) {
          console.error('Invalid HTML.');
          return false
        }
        body = this._wrapIntoParagraph(body);
        snippet = context.appState.document.createSnippet();
        let htmlImporter = context.configurator.getImporter('html');
        htmlImporter.setDocument(snippet);
        let container = snippet.get(substance.documentHelpers.SNIPPET_ID);
        body.getChildren().forEach(el => {
          let node = htmlImporter.convertElement(el);
          if (node) {
            container.show(node.id);
          }
        });
      }
      return context.api.paste(snippet, options)
    }

    _pasteText (text, context) {
      context.api.insertText(text);
    }

    _importFromJSON (context, jsonStr) {
      let snippet = context.appState.document.newInstance();
      let jsonData = JSON.parse(jsonStr);
      let converter = new JSONConverterNew();
      converter.importDocument(snippet, jsonData);
      return snippet
    }

    _detectApplicationType (html, htmlDoc) {
      let state = {};
      let generatorMeta = htmlDoc.find('meta[name="generator"]');
      let xmnlsw = htmlDoc.find('html').getAttribute('xmlns:w');
      if (generatorMeta) {
        let generator = generatorMeta.getAttribute('content');
        if (generator.indexOf('LibreOffice') > -1) {
          state.isLibreOffice = true;
        }
      } else if (xmnlsw) {
        if (xmnlsw.indexOf('office:word') > -1) {
          state.isMicrosoftWord = true;
        }
      } else if (html.indexOf('docs-internal-guid') > -1) {
        state.isGoogleDoc = true;
      }
      return state
    }

    _sanitizeBody (state, body) {
      // Remove <meta> element
      body.findAll('meta').forEach(el => el.remove());
      // Some word processors are exporting new lines instead of spaces
      // for these editors we will replace all new lines with space
      if (state.isLibreOffice || state.isMicrosoftWord) {
        let bodyHtml = body.getInnerHTML();
        body.setInnerHTML(bodyHtml.replace(/\r\n|\r|\n/g, ' '));
      }
      if (state.isGoogleDoc) {
        body = this._fixupGoogleDocsBody(state, body);
      }
      return body
    }

    _fixupGoogleDocsBody (state, body) {
      if (!body) return
      // Google Docs has a strange convention to use a bold tag as
      // container for the copied elements
      // HACK: we exploit the fact that this element has an id with a
      // specific format, e.g., id="docs-internal-guid-5bea85da-43dc-fb06-e327-00c1c6576cf7"
      let bold = body.find('b');
      if (bold && /^docs-internal/.exec(bold.id)) {
        body = bold;
      }
      // transformations to turn formatations encoded via styles
      // into semantic HTML tags
      body.findAll('span').forEach(span => {
        // Google Docs uses spans with inline styles
        // insted of inline nodes
        // We are scanning each span for certain inline styles:
        // font-weight: 700 -> <b>
        // font-style: italic -> <i>
        // vertical-align: super -> <sup>
        // vertical-align: sub -> <sub>
        // TODO: improve the result for other editors by fusing adjacent annotations of the same type
        let nodeTypes = [];
        if (span.getStyle('font-weight') === '700') nodeTypes.push('b');
        if (span.getStyle('font-style') === 'italic') nodeTypes.push('i');
        if (span.getStyle('vertical-align') === 'super') nodeTypes.push('sup');
        if (span.getStyle('vertical-align') === 'sub') nodeTypes.push('sub');
        // remove the style so the element becomes cleaner
        span.removeAttribute('style');
        createInlineNodes(span.getParent(), true);

        function createInlineNodes (parentEl, isRoot) {
          if (nodeTypes.length > 0) {
            let el = parentEl.createElement(nodeTypes[0]);
            if (nodeTypes.length === 1) el.append(span.textContent);
            if (isRoot) {
              parentEl.replaceChild(span, el);
            } else {
              parentEl.appendChild(el);
            }
            nodeTypes.shift();
            createInlineNodes(el);
          }
        }
      });

      // Union siblings with the same tags, e.g. we are turning
      // <b>str</b><b><i>ong</i></b> to <b>str<i>ong</i></b>
      let tags = ['b', 'i', 'sup', 'sub'];
      tags.forEach(tag => {
        body.findAll(tag).forEach(el => {
          let previousSiblingEl = el.getPreviousSibling();
          if (previousSiblingEl && el.tagName === previousSiblingEl.tagName) {
            let parentEl = el.getParent();
            let newEl = parentEl.createElement(tag);
            newEl.setInnerHTML(previousSiblingEl.getInnerHTML() + el.getInnerHTML());
            parentEl.replaceChild(el, newEl);
            parentEl.removeChild(previousSiblingEl);
          }

          // Union siblings and child with the same tags, e.g. we are turning
          // <i>emph</i><b><i>asis</i></b> to <i>emph<b>asis</b></i>
          // Note that at this state children always have the same text content
          // e.g. there can't be cases like <b><i>emph</i> asis</b> so we don't treat them
          if (previousSiblingEl && previousSiblingEl.tagName && el.getChildCount() > 0 && el.getChildAt(0).tagName === previousSiblingEl.tagName) {
            let parentEl = el.getParent();
            let childEl = el.getChildAt(0);
            let newEl = parentEl.createElement(previousSiblingEl.tagName);
            let newChildEl = newEl.createElement(tag);
            newChildEl.setTextContent(childEl.textContent);
            newEl.appendChild(newChildEl);
            parentEl.replaceChild(el, newEl);
          }
        });
      });

      return body
    }

    // if the content only
    _wrapIntoParagraph (body) {
      let childNodes = body.getChildNodes();
      let shouldWrap = false;
      for (let i = 0; i < childNodes.length; i++) {
        const c = childNodes[i];
        if (c.isTextNode()) {
          if (!(/^\s+$/.exec(c.textContent))) {
            shouldWrap = true;
            break
          }
        } else if (INLINENODES[c.tagName]) {
          shouldWrap = true;
          break
        }
      }
      if (shouldWrap) {
        let p = body.createElement('p');
        p.append(childNodes);
        body.append(p);
      }
      return body
    }
  }

  class ModelProperty {
    constructor (name, valueModel) {
      this._name = name;
      this._valueModel = valueModel;
    }

    get name () {
      return this._name
    }

    get valueModel () {
      return this._valueModel
    }

    get _isModelProperty () { return true }
  }

  class CompositeModel extends AbstractModel {
    constructor (api, ...properties) {
      super(api);
      this._properties = properties;
    }

    get type () { return 'composite-model' }

    get _isCompositeModel () { return true }

    setProperties (...properties) {
      this._properties = properties.map(p => {
        if (p._isModelProperty) {
          return p
        } else {
          return new ModelProperty(p.name, p.model)
        }
      });
    }
  }

  class CompositeComponent extends substance.Component {
    render ($$) {
      const model = this.props.model;
      let el = $$('div')
        .addClass(this.getClassNames());

      let properties = model.getProperties();
      properties.forEach(property => {
        let valueModel = property.valueModel;
        let ModelComponent = this._getPropertyComponent(property);
        el.append(
          $$(ModelComponent, {
            model: valueModel,
            label: property.name
          }).addClass(`sm-${property.name}`)
        );
      });
      return el
    }

    _getPropertyComponent (property) {
      return this.getComponent(property.valueModel.type)
    }

    getClassNames () {
      return `sc-composite sm-${this.props.model.type}`
    }
  }

  class DynamicCollection {
    constructor (api, type) {
      this._api = api;
      this._type = type;
    }

    get isCollection () {
      return true
    }

    get type () {
      return this._type
    }

    getItems () {
      const api = this._api;
      const doc = api._getDocument();
      const index = doc.getIndex('type');
      const nodesById = index.get(this._type);
      const items = substance.map(nodesById, node => {
        return api._getModelForNode(node)
      });
      return items
    }

    addItem (item) {
      const api = this._api;
      const model = api._addModel(item);
      return model
    }

    removeItem (item) {
      const api = this._api;
      const model = api._removeModel(item);
      return model
    }
  }

  class InternalEditingAPI extends substance.Editing {
    copySelection (tx) {
      substance.copySelection(tx, tx.selection);
    }

    createTextNode (tx, container, text) {
      throw new Error('This method is abstract')
    }

    createListNode (tx, container, params) {
      throw new Error('This method is abstract')
    }

    insertInlineNode (tx, node) {
      let sel = tx.selection;
      let text = '\uFEFF';
      this.insertText(tx, text);
      sel = tx.selection;
      let endOffset = tx.selection.end.offset;
      let startOffset = endOffset - text.length;
      // TODO: introduce a coordinate operation for that
      tx.set([node.id, 'start', 'path'], sel.path);
      tx.set([node.id, 'start', 'offset'], startOffset);
      tx.set([node.id, 'end', 'path'], sel.path);
      tx.set([node.id, 'end', 'offset'], endOffset);
      return node
    }

    paste (tx, content) {
      if (!content) return
      if (substance.isString(content)) {
        substance.paste(tx, {text: content});
      } else if (content._isDocument) {
        substance.paste(tx, { doc: content });
      } else {
        throw new Error('Illegal content for paste.')
      }
    }
  }

  /*
    EXPERIMENTAL: trying to come up with a unified API for low-level manipulations
    This is very much what we have done so far via Editing.js

    In the way of the former editorSession, this API
    takes all information available from the application state (turle graphics style).

    TODO: I want to use this as part of the low-level API instead of
    the former EditingInterface / Editing hard-wired in Surfaces
  */
  class EditorAPI extends AbstractAPI {
    constructor (...args) {
      super(...args);

      this._impl = this._createInternalEditorAPI();
    }

    annotate (annotationData) {
      const sel = this._getSelection();
      if (sel && (sel.isPropertySelection() || sel.isContainerSelection())) {
        this._getEditorSession().transaction(tx => {
          this._impl.annotate(tx, annotationData);
        }, { action: 'annotate' });
      }
    }

    break () {
      const sel = this._getSelection();
      if (sel && !sel.isNull()) {
        this._getEditorSession().transaction(tx => {
          this._impl.break(tx);
        }, { action: 'break' });
      }
    }

    copy () {
      const sel = this._getSelection();
      const doc = this._getDocument();
      if (sel && !sel.isNull() && !sel.isCollapsed()) {
        return substance.copySelection(doc, sel)
      }
    }

    cut () {
      const sel = this._getSelection();
      if (sel && !sel.isNull() && !sel.isCollapsed()) {
        let snippet = this.copy();
        this.deleteSelection();
        return snippet
      }
    }

    deleteSelection (options) {
      const sel = this._getSelection();
      if (sel && !sel.isNull() && !sel.isCollapsed()) {
        this._getEditorSession().transaction(tx => {
          this._impl.delete(tx, 'right', options);
        }, { action: 'deleteSelection' });
      }
    }

    deleteCharacter (direction) {
      const sel = this._getSelection();
      if (!sel || sel.isNull()) ; else if (!sel.isCollapsed()) {
        this.deleteSelection();
      } else {
        this._getEditorSession().transaction(tx => {
          this._impl.delete(tx, direction);
        }, { action: 'deleteCharacter' });
      }
    }

    insertText (text) {
      const sel = this._getSelection();
      if (sel && !sel.isNull()) {
        this._getEditorSession().transaction(tx => {
          this._impl.insertText(tx, text);
        }, { action: 'insertText' });
      }
    }

    // insert an inline node with given data at the current selection
    insertInlineNode (inlineNode) {
      const sel = this._getSelection();
      if (sel && !sel.isNull() && sel.isPropertySelection()) {
        this._getEditorSession().transaction(tx => {
          return this._impl.insertInlineNode(tx, inlineNode)
        }, { action: 'insertInlineNode' });
      }
    }

    insertBlockNode (blockNode) {
      const sel = this._getSelection();
      if (sel && !sel.isNull()) {
        this._getEditorSession().transaction(tx => {
          return this._impl.insertBlockNode(tx, blockNode)
        }, { action: 'insertBlockNode' });
      }
    }

    paste (content, options) {
      const sel = this._getSelection();
      if (sel && !sel.isNull() && !sel.isCustomSelection()) {
        // TODO: here we need to transform the content
        // so that a paste is compliant with the schema
        // First: detect the target context (container vs text)
        // let targetType = sel.containerId ? 'container' : 'text'
        // if snippet contains more than one node it is 'container'
        // if it contains only one textitsh node it is 'text
        this._getEditorSession().transaction(tx => {
          return this._impl.paste(tx, content, options)
        }, { action: 'paste' });
        return true
      }
    }

    switchTextType (nodeData) {
      const sel = this._getSelection();
      if (sel && !sel.isNull()) {
        this._getEditorSession().transaction(tx => {
          return this._impl.switchTextType(tx, nodeData)
        }, { action: 'switchTextType' });
      }
    }

    toggleList (params) {
      const sel = this._getSelection();
      if (sel && !sel.isNull()) {
        this._getEditorSession().transaction(tx => {
          return this._impl.toggleList(tx, params)
        }, { action: 'toggleList' });
      }
    }

    indent () {
      const sel = this._getSelection();
      if (sel && !sel.isNull()) {
        this._getEditorSession().transaction(tx => {
          return this._impl.indent(tx)
        }, { action: 'indent' });
      }
    }

    dedent () {
      const sel = this._getSelection();
      if (sel && !sel.isNull()) {
        this._getEditorSession().transaction(tx => {
          return this._impl.dedent(tx)
        }, { action: 'dedent' });
      }
    }

    _getSelection () {
      throw new Error('This method is abstract')
    }

    _getDocument () {
      throw new Error('This method is abstract')
    }

    _getEditorSession () {
      throw new Error('This method is abstract')
    }

    _createInternalEditorAPI () {
      return new InternalEditingAPI()
    }
  }

  // Note: at this higher level, 'Container' is not a very good name because ot is not very specific
  // We should come up with a name that makes clear that this is something that could be editied in a classical 'word-processor'.
  // I.e. the content consists of a sequence of TextBlocks as well as blocks with other typically structured content.
  // As a working title I'd suggest to use the term 'flow content' which is used in HTML for exactly this type of content
  class FlowContentModel extends _ContainerModel {
    get type () { return 'flow-content-model' }

    get id () { return this._path[0] }

    getItems () {
      return this._getItems()
    }

    addItem (item) {
      this._api._appendChild(this._path, item);
    }

    removeItem (item) {
      this._api._removeChild(this._path, item);
    }
  }

  /*
    This file contains derivations of core classes that
    are necessary to be compatible with the AppState and the Model API.
  */

  class SurfaceNew extends ModifiedSurface(substance.Surface) {}

  // TODO: try to provide basic Surface and ContainerEditor implementations
  // making it easier to use a different data binding mechanism
  class TextPropertyEditorNew extends ModifiedSurface(substance.TextPropertyEditor) {
    // overriding event registration
    didMount () {
      super.didMount();

      let appState = this.context.appState;
      appState.addObserver(['selection'], this._onSelectionChanged, this, {
        stage: 'render'
      });
    }

    dispose () {
      super.dispose();

      this.context.appState.off(this);
    }

    render ($$) {
      let el = super.render($$);
      if (this.isEditable()) {
        el.addClass('sm-editable');
      } else {
        el.addClass('sm-readonly');
        // HACK: removing contenteditable if not editable
        // TODO: we should fix substance.TextPropertyEditor to be consistent with props used in substance.Surface
        el.setAttribute('contenteditable', false);
      }
      return el
    }
  }

  /*
    Customized ContainerEditor that produces a fall-back display
    for nodes which are not supported yet.
  */
  // TODO: try to provide basic Surface and ContainerEditor implementations
  // making it easier to use a different data binding mechanism
  class ContainerEditorNew extends ModifiedSurface(substance.ContainerEditor) {
    // overriding event registration
    didMount () {
      super.didMount();

      let appState = this.context.appState;
      appState.addObserver(['selection'], this._onSelectionChanged, this, {
        stage: 'render'
      });
      appState.addObserver(['document'], this._onContainerChanged, this, {
        stage: 'render',
        document: {
          path: this.container.getContentPath()
        }
      });
    }

    dispose () {
      super.dispose();

      this.context.appState.off(this);
    }

    // overriding this to control editability
    render ($$) {
      let el = super.render($$);

      if (this.isEditable()) {
        el.addClass('sm-editable');
      } else {
        el.addClass('sm-readonly');
        // HACK: removing contenteditable if not editable
        // TODO: we should fix substance.TextPropertyEditor to be consistent with props used in substance.Surface
        el.setAttribute('contenteditable', false);
      }

      return el
    }

    // overriding the default implementation, to control the behavior
    // for nodes without explicitly registered component
    _getNodeComponentClass (node) {
      let ComponentClass = this.getComponent(node.type, 'not-strict');
      if (ComponentClass) {
        // text components are used directly
        if (node.isText() || this.props.disabled) {
          return ComponentClass
        // other components are wrapped into an IsolatedNodeComponent
        // except the component is itself a customized IsolatedNodeComponent
        } else if (ComponentClass.prototype._isCustomNodeComponent || ComponentClass.prototype._isIsolatedNodeComponent) {
          return ComponentClass
        } else {
          return this.getComponent('isolated-node')
        }
      } else {
        // for text nodes without an component registered explicitly
        // we use the default text component
        if (node.isText()) {
          return this.getComponent('text-node')
        // otherwise component for unsupported nodes
        } else {
          return this.getComponent('unsupported')
        }
      }
    }

    _getNodeProps (node) {
      let props = super._getNodeProps(node);
      let model = this.context.api.getModelById(node.id);
      props.model = model;
      return props
    }
  }

  function _monkeyPatchSurfaceProps (parent, props) {
    let newProps = Object.assign({}, props);
    if (props.model && !props.node) {
      const model = props.model;
      if (model.type === 'flow-content-model') {
        newProps.containerId = model.id;
      } else {
        newProps.node = model._node;
      }
    }
    // TODO: we should revisit this in Substance
    if (props.editable === false || !parent.context.editable) {
      newProps.editing = 'readonly';
    }
    return newProps
  }

  class IsolatedInlineNodeComponentNew extends substance.IsolatedInlineNodeComponent {
    constructor (parent, props, options) {
      super(parent, props, options);
      if (!props.model) throw new Error("Property 'model' is required and must be a NodeModel")
      if (!props.model._node) throw new Error('Provided model must container a DocumentNode')
    }
    _getContentProps () {
      let props = super._getContentProps();
      props.model = this.props.model;
      return props
    }
  }

  class IsolatedNodeComponentNew extends substance.IsolatedNodeComponent {
    constructor (parent, props, options) {
      super(parent, props, options);
      if (!props.model) throw new Error("Property 'model' is required and must be a NodeModel")
      if (!props.model._node) throw new Error('Provided model must container a DocumentNode')

      // HACK: overriding 'closed' IsolatedNodeComponents per se
      // TODO: on the long term we need to understand if it may be better to open
      // IsolatedNodes by default and only close them if needed.
      // The UX is improved much also in browsers like FF.
      // Still we need to evaluate this decision in the near future.
      this.blockingMode = 'open';
    }

    _getContentProps () {
      let props = super._getContentProps();
      props.model = this.props.model;
      return props
    }

    // overriding the core implementation to select the node on all unhandled clicks.
    onClick (event) {
      event.stopPropagation();
      event.preventDefault();
      this.selectNode();
    }
  }
  /*
    Overriding the original implementation
    - 1. to be able to pass down Model instances to inline nodes and annotations
    - 2. to change the way how place-holders are rendered
  */
  class TextPropertyComponentNew extends substance.TextPropertyComponent {
    render ($$) {
      let path = this.getPath();

      let el = this._renderContent($$)
        .addClass('sc-text-property')
        .attr({
          'data-path': path.join('.')
        })
        .css({
          'white-space': 'pre-wrap'
        });

      if (this.isEmpty()) {
        el.addClass('sm-empty');
        if (this.props.placeholder) {
          el.setAttribute('data-placeholder', this.props.placeholder);
        }
      }

      if (!this.props.withoutBreak) {
        el.append($$('br'));
      }

      return el
    }

    _getFragmentProps (node) {
      let props = super._getFragmentProps(node);
      let model = this.context.api.getModelById(node.id);
      props.model = model;
      return props
    }

    _getUnsupportedInlineNodeComponentClass () {
      return this.getComponent('unsupported-inline-node')
    }
  }

  function ModifiedSurface (Surface) {
    class _ModifiedSurface extends Surface {
      constructor (parent, props, options) {
        super(parent, _monkeyPatchSurfaceProps(parent, props), options);
      }

      didMount () {
        const surfaceManager = this.getSurfaceManager();
        if (surfaceManager && this.isEditable()) {
          surfaceManager.registerSurface(this);
        }
        const globalEventHandler = this.getGlobalEventHandler();
        if (globalEventHandler) {
          globalEventHandler.addEventListener('keydown', this._muteNativeHandlers, this);
        }
      }

      dispose () {
        const surfaceManager = this.getSurfaceManager();
        if (surfaceManager && this.isEditable()) {
          surfaceManager.unregisterSurface(this);
        }
        const globalEventHandler = this.getGlobalEventHandler();
        if (globalEventHandler) {
          globalEventHandler.removeEventListener('keydown', this._muteNativeHandlers);
        }
      }

      setProps (newProps) {
        return super.setProps(_monkeyPatchSurfaceProps(this.parent, newProps))
      }

      render ($$) {
        // NOTE: experimenting with additional event handlers
        // After we are sure that we want this we should add this to the core implementation
        let el = super.render($$);
        if (!this.isDisabled()) {
          if (!this.isReadonly()) {
            // Mouse Events
            el.on('click', this.onClick);
          }
        }
        return el
      }

      _initializeClipboard () {
        return new ClipboardNew()
      }

      _onCopy (e) {
        e.preventDefault();
        e.stopPropagation();
        let clipboardData = e.clipboardData;
        this.clipboard.copy(clipboardData, this.context);
      }

      _onCut (e) {
        e.preventDefault();
        e.stopPropagation();
        let clipboardData = e.clipboardData;
        this.clipboard.cut(clipboardData, this.context);
      }

      _onPaste (e) {
        e.preventDefault();
        e.stopPropagation();
        let clipboardData = e.clipboardData;
        // TODO: allow to force plain-text paste
        this.clipboard.paste(clipboardData, this.context);
      }

      // mostly copied from 'Substance.Surface.onMouseDown()'
      // trying to improve the mouse handling
      // not letting bubble up handled events
      onMouseDown (event) {
        if (!this._shouldConsumeEvent(event)) {
          // console.log('skipping mousedown', this.id)
          return false
        }
        // stopping propagation because now the event is considered to be handled
        event.stopPropagation();

        // EXPERIMENTAL: trying to 'reserve' a mousedown event
        // so that parents know that they shouldn't react
        // This is similar to event.stopPropagation() but without
        // side-effects.
        // Note: some browsers do not do clicks, selections etc. on children if propagation is stopped
        if (event.__reserved__) {
          // console.log('%s: mousedown already reserved by %s', this.id, event.__reserved__.id)
          return
        } else {
          // console.log('%s: taking mousedown ', this.id)
          event.__reserved__ = this;
        }

        // NOTE: this is here to make sure that this surface is contenteditable
        // For instance, IsolatedNodeComponent sets contenteditable=false on this element
        // to achieve selection isolation
        if (this.isEditable()) {
          this.el.setAttribute('contenteditable', true);
        }

        // TODO: what is this exactly?
        if (event.button !== 0) {
          return
        }

        // special treatment for triple clicks
        if (!(substance.platform.isIE && substance.platform.version < 12) && event.detail >= 3) {
          let sel = this.getEditorSession().getSelection();
          if (sel.isPropertySelection()) {
            this._selectProperty(sel.path);
            event.preventDefault();
            event.stopPropagation();
            return
          } else if (sel.isContainerSelection()) {
            this._selectProperty(sel.startPath);
            event.preventDefault();
            event.stopPropagation();
            return
          }
        }
        // 'mouseDown' is triggered before 'focus' so we tell
        // our focus handler that we are already dealing with it
        // The opposite situation, when the surface gets focused e.g. using keyboard
        // then the handler needs to kick in and recover a persisted selection or such
        this._state.skipNextFocusEvent = true;

        // this is important for the regular use case, where the mousup occurs within this component
        this.el.on('mouseup', this.onMouseUp, this);
        // NOTE: additionally we need to listen to mousup on document to catch events outside the surface
        // TODO: it could still be possible not to receive this event, if mouseup is triggered on a component that consumes the event
        if (substance.platform.inBrowser) {
          let documentEl = substance.DefaultDOMElement.wrapNativeElement(window.document);
          documentEl.on('mouseup', this.onMouseUp, this);
        }
      }

      onMouseUp (e) {
        // console.log('Surface.onMouseUp', this.id)
        this.el.off('mouseup', this.onMouseUp, this);
        if (substance.platform.inBrowser) {
          let documentEl = substance.DefaultDOMElement.wrapNativeElement(window.document);
          documentEl.off('mouseup', this.onMouseUp, this);
        }
        // console.log('Surface.onMouseup', this.id);
        // ATTENTION: filtering events does not make sense here,
        // as we need to make sure that pick the selection even
        // when the mouse is released outside the surface
        // if (!this._shouldConsumeEvent(e)) return
        e.stopPropagation();
        // ATTENTION: this delay is necessary for cases the user clicks
        // into an existing selection. In this case the window selection still
        // holds the old value, and is set to the correct selection after this
        // being called.
        this._delayed(() => {
          let sel = this.domSelection.getSelection();
          this._setSelection(sel);
        });
      }

      onClick (event) {
        if (!this._shouldConsumeEvent(event)) {
          // console.log('skipping mousedown', this.id)
          return false
        }
        // stop bubbling up here
        event.stopPropagation();
      }
    }
    return _ModifiedSurface
  }

  /*
    Customized ContainerEditor for FlowContentModels.
  */
  class FlowContentComponent extends ContainerEditorNew {
    // overriding event registration
    didMount () {
      // ATTENTION: we are not calling super here, because we want to deviate from the default implementation
      if (this.context.editable) {
        let appState = this.context.appState;
        appState.addObserver(['selection'], this._onSelectionChanged, this, {
          stage: 'render'
        });
        appState.addObserver(['document'], this._onContainerChanged, this, {
          stage: 'render',
          document: {
            path: this.container.getContentPath()
          }
        });

        const surfaceManager = this.getSurfaceManager();
        if (surfaceManager) {
          surfaceManager.registerSurface(this);
        }
        const globalEventHandler = this.getGlobalEventHandler();
        if (globalEventHandler) {
          globalEventHandler.addEventListener('keydown', this._muteNativeHandlers, this);
        }
        this._attachPlaceholder();
      }
    }

    dispose () {
      // ATTENTION: we are not calling super here, because we want to deviate from the default implementation
      this.context.appState.off(this);
      const surfaceManager = this.getSurfaceManager();
      if (surfaceManager) {
        surfaceManager.unregisterSurface(this);
      }
      const globalEventHandler = this.getGlobalEventHandler();
      if (globalEventHandler) {
        globalEventHandler.removeEventListener('keydown', this._muteNativeHandlers);
      }
    }

    render ($$) {
      let el = super.render($$).addClass('sc-flow-content');
      return el
    }

    // overriding the default implementation, to control the behavior
    // for nodes without explicitly registered component
    _getNodeComponentClass (node) {
      let ComponentClass = this.getComponent(node.type, 'not-strict');
      if (ComponentClass) {
        // text components are used directly
        if (node.isText() || this.props.disabled || !this.context.editable) {
          return ComponentClass
        // other components are wrapped into an IsolatedNodeComponent
        // except the component is itself a customized IsolatedNodeComponent
        } else if (ComponentClass.prototype._isCustomNodeComponent || ComponentClass.prototype._isIsolatedNodeComponent) {
          return ComponentClass
        } else {
          return this.getComponent('isolated-node')
        }
      } else {
        // LEGACY: for text nodes without an component registered explicitly we use the default text component
        // TODO: try to get rid of this
        if (node.isText()) {
          return this.getComponent('text-node')
        // otherwise component for unsupported nodes
        } else {
          return this.getComponent('unsupported')
        }
      }
    }

    _getNodeProps (node) {
      let props = super._getNodeProps(node);
      let model = this.context.api.getModelById(node.id);
      props.model = model;
      // TODO: get placeholder message using this.getLabel()
      props.placeholder = `Enter ${this.props.label}`;
      return props
    }
  }

  function OverlayMixin (Component) {
    class OverlayComponent extends Component {
      didMount () {
        super.didMount();

        let appState = this.context.appState;

        appState.addObserver(['overlayId'], this._rerenderWhenOverlayIdHasChanged, this, { stage: 'render' });
      }

      dispose () {
        super.dispose();

        this.context.appState.removeObserver(this);
      }

      _getOverlayId () {
        return this.getId()
      }

      _canShowOverlay () {
        return this.context.appState.overlayId === this._getOverlayId()
      }

      _toggleOverlay () {
        this.send('toggleOverlay', this._getOverlayId());
      }

      _rerenderWhenOverlayIdHasChanged () {
        // console.log('Rerendering overlay component because overlay id has changed', this._getOverlayId()')
        this.rerender();
      }
    }
    return OverlayComponent
  }

  class MultiSelectInput extends OverlayMixin(substance.Component) {
    render ($$) {
      const selected = this.props.selected;
      const isEmpty = selected.length === 0;
      const selectedLabels = selected.map(item => item.toString());
      const isExpanded = this._canShowOverlay();
      const label = isEmpty ? this.getLabel('multi-select-default-value') : selectedLabels.join('; ');

      const el = $$('div').addClass('sc-multi-select-input');
      if (isEmpty) el.addClass('sm-empty');
      el.addClass(isExpanded ? 'sm-expanded' : 'sm-collapsed');
      el.append(
        $$('div').addClass('se-label').text(label)
      );

      if (isExpanded) {
        el.addClass('sm-active');
        el.append(
          this.renderValues($$)
        );
      }
      el.on('click', this._toggleOverlay)
        .on('dblclick', this._prevent)
        .on('mousedown', this._prevent);

      return el
    }

    renderValues ($$) {
      const label = this.props.label;
      const selected = this.props.selected;
      const selectedIdx = selected.map(item => item.id);
      const options = this._getOptions();
      const editorEl = $$('div').addClass('se-select-editor').append(
        $$('div').addClass('se-arrow'),
        $$('div').addClass('se-select-label')
          .append(label)
      );
      options.forEach(option => {
        const isSelected = selectedIdx.indexOf(option.id) > -1;
        const icon = isSelected ? 'checked-item' : 'unchecked-item';
        editorEl.append(
          $$('div').addClass('se-select-item').addClass(isSelected ? 'sm-selected' : '').append(
            this.context.iconProvider.renderIcon($$, icon).addClass('se-icon'),
            $$('div').addClass('se-item-label')
              // TODO: I would like to have this implementation more agnostic of a specific data structure
              .append(option.toString()).ref(option.id)
          ).on('click', this._toggleItem.bind(this, option))
        );
      });
      return editorEl
    }

    _getOverlayId () {
      return this.props.overlayId || this.getId()
    }

    _getOptions () {
      return this.getParent().getAvailableOptions()
    }

    _toggleItem (option, event) {
      event.stopPropagation();
      event.preventDefault();
      this.send('toggleOption', option);
    }

    _toggleOverlay (event) {
      event.preventDefault();
      event.stopPropagation();
      super._toggleOverlay();
    }

    _prevent (event) {
      event.stopPropagation();
      event.preventDefault();
    }
  }

  class ManyRelationshipComponent extends ValueComponent {
    didMount () {
      // TODO: in case of relationships it is unfortunately not that simple to detect
      // a change that is relevant to rerendering
      // 1. a target id has been added / set
      // 2. one of the target ids has changed
      // 3. one of the target ids has been deleted
      // 4. a new available target has been added
      // the last is pretty much impossible to detect in a general way
      // but we can live with that as long this is queried everytime the
      // component is rendered
      this.context.appState.addObserver(['document'], this._rerenderOnModelChangeIfNecessary, this, { stage: 'render' });
    }

    dispose () {
      this.context.appState.removeObserver(this);
    }

    render ($$) {
      const label = this.getLabel('select-item') + ' ' + this.props.label;
      const options = this.getAvailableOptions();
      let selected = this._getSelectedOptions(options);
      let el = $$('div').addClass('sc-many-relationship');
      if (this.context.editable) {
        el.append(
          $$(MultiSelectInput, {
            label,
            selected,
            overlayId: this.props.model.id
          }).ref('select')
        );
      } else {
        const selectedLabels = [];
        // ATTENTION: doing this with a for loop as it can happen
        // that an item is undefined (if id is not avaiable)
        for (let item of selected) {
          if (item) {
            selectedLabels.push(item.toString());
          }
        }
        let label = selectedLabels.join('; ');
        el.addClass('sm-readonly').append(label);
      }
      return el
    }

    getActionHandlers () {
      return {
        toggleOption: this._toggleTarget,
        toggleOverlay: this._toggleOverlay
      }
    }

    getAvailableOptions () {
      let model = this.props.model;
      return model.getAvailableTargets()
    }

    _getSelectedOptions (options) {
      // pick all selected items from options this makes life easier for the MutliSelectComponent
      // because it does not need to map via ids, just can check equality
      let targetIds = this.props.model.getValue();
      let selected = targetIds.map(id => options.find(item => item.id === id)).filter(Boolean);
      return selected
    }

    _toggleTarget (target) {
      if (this.context.editable) {
        this.props.model.toggleTarget(target);
      }
    }

    _toggleOverlay () {
      const appState = this.context.appState;
      let overlayId = appState.overlayId;
      let modelId = this.props.model.id;
      if (overlayId === modelId) {
        this.getParent().send('toggleOverlay');
      } else {
        // ATTENTION: At the moment a reducer maps value selections to appState.overlayId
        // i.e. we must not call toggleOverlay
        // But if we decided to disable the reducer this would break if
        // we used the common implementation.
        // TODO: rethink this approach in general
        this.context.api.selectValue(this._getPath());
        appState.set('overlayId', modelId, 'propagateImmediately');
      }
    }

    _rerenderOnModelChangeIfNecessary (change) {
      let updateNeeded = Boolean(change.updated[this._getPath()]);
      if (!updateNeeded) {
        let ids = this.props.model.getValue();
        if (ids) {
          if (!substance.isArray(ids)) {
            ids = [ids];
          }
          for (let id of ids) {
            if (change.deleted[id] || change.updated[id]) {
              updateNeeded = true;
              break
            }
          }
        }
      }
      if (updateNeeded) {
        this._rerenderOnModelChange();
      }
    }

    _rerenderOnModelChange () {
      // console.log('Rerendering RelationshipComponent because model has changed', this._getPath())
      this.rerender();
    }
  }

  function removeModelObserver (comp) {
    comp.context.appState.removeObserver(comp);
  }

  class ModelComponent extends substance.Component {
    didMount () {
      addModelObserver(this.props.model, this.rerender, this);
    }

    dispose () {
      removeModelObserver(this);
    }
  }

  class TextInput extends SurfaceNew {
    render ($$) {
      const TextPropertyComponent = this.getComponent('text-property');
      const placeholder = this.props.placeholder;
      const path = this.props.path;
      const isEditable = this.isEditable();
      // TODO: we should refactor Substance.TextPropertyEditor so that it can be used more easily
      let el = SurfaceNew.prototype.render.apply(this, arguments);
      el.addClass('sc-text-input');
      // Attention: being disabled does not necessarily mean not-editable, whereas non-editable is always disabled
      // A Surface can also be disabled because it is blurred, for instance.
      if (isEditable) {
        el.addClass('sm-editable');
        if (!this.props.disabled) {
          el.addClass('sm-enabled');
          el.attr('contenteditable', true);
          // native spellcheck
          el.attr('spellcheck', this.props.spellcheck === 'native');
        }
      } else {
        el.addClass('sm-readonly');
      }
      let content = $$(TextPropertyComponent, {
        doc: this.getDocument(),
        tagName: 'div',
        placeholder,
        path
      }).ref('property').addClass('se-input');
      el.append(content);
      return el
    }

    // HACK: this is needed e.g. by SelectAllCommand
    get _isTextPropertyEditor () {
      return true
    }

    // HACK: this is needed e.g. by SelectAllCommand
    getPath () {
      return this.props.path
    }
  }

  class StringComponent extends substance.Component {
    render ($$) {
      let label = this.props.label;
      let placeholder = this.props.placeholder;
      let model = this.props.model;
      let path = model._path;
      let name = path.join('.');
      // TODO: use label provider for this
      placeholder = placeholder || 'Enter ' + label;
      let el = $$('div').addClass(this.getClassNames());
      el.append($$(TextInput, {
        name,
        path,
        placeholder
      }));
      return el
    }

    getClassNames () {
      return 'sc-string'
    }
  }

  class TextComponent extends StringComponent {
    getClassNames () {
      return 'sc-text'
    }
  }

  class ObjectComponent extends ValueComponent {
    render ($$) {
      let el = $$('div').addClass('sc-object');
      // TODO: implement a default editor for object type values
      return el
    }
  }

  class SingleRelationshipComponent extends ManyRelationshipComponent {
    _getSelectedOptions (options) {
      let targetId = this.props.model.getValue();
      if (!targetId) return []
      let selectedOption = options.find(item => {
        if (item) return item.id === targetId
      });
      let selected = selectedOption ? [selectedOption] : [];
      return selected
    }
  }

  /*
    TODO: try to get rid of this by switching to a pure model based approach
    ATM, we need this for legacy reasons: e.g. it is used by FlowContentComponent
    for text nodes without a registered model.

    ATTENTION: There is another mechanism which leads to rerendering of TextPropertyComponents (-> MarkersManager)
    HACK: To avoid double rendering of text nodes, we do not register for updates here
    TODO: rethink this.
  */
  class TextNodeComponent extends substance.Component {
    render ($$) {
      const TextPropertyComponent = this.getComponent('text-property');
      const node = this.props.node;
      const tagName = this.getTagName();
      const path = node.getPath();
      let el = $$(tagName)
        .addClass(this.getClassNames())
        .attr('data-id', node.id);
      el.append(
        $$(TextPropertyComponent, {
          doc: node.getDocument(),
          name: path.join('.'),
          path,
          placeholder: this.props.placeholder
        }).ref('text')
      );
      // TODO: ability to edit attributes
      return el
    }

    getTagName () {
      return 'div'
    }

    getClassNames () {
      // TODO: don't violate the 'sc-' contract
      return 'sc-text-node sc-' + this.props.node.type
    }
  }

  var ModelComponentPackage = {
    name: 'Model Components',
    configure (configurator) {
      // TODO: maybe we want to use just '<type>' as name instead of '<type>-model'
      configurator.addComponent('boolean-model', BooleanComponent);
      configurator.addComponent('string-model', StringComponent);
      configurator.addComponent('text-model', TextComponent);
      configurator.addComponent('flow-content-model', FlowContentComponent);
      configurator.addComponent('object-model', ObjectComponent);
      configurator.addComponent('single-relationship-model', SingleRelationshipComponent);
      configurator.addComponent('many-relationship-model', ManyRelationshipComponent);
      configurator.addComponent('child-model', ChildComponent);
      configurator.addComponent('children-model', ChildrenModelComponent);
      configurator.addComponent('composite-model', CompositeComponent);
      // LEGACY
      configurator.addComponent('text-node', TextNodeComponent);
    }
  }

  function NodeComponentMixin (Component) {
    return class NodeComponent extends Component {
      // constructor (parent, props, options) {
      //   super(parent, props, options)
      //   // TODO: at some point we do not want to allow old-school components anymore
      //   // if (!props.model) throw new Error("Property 'model' is required and must be a NodeModel")
      //   // if (!props.model._node) throw new Error('Provided model must container a DocumentNode')
      // }
      didMount () {
        super.didMount();
        const node = this.getNode();
        this.context.appState.addObserver(['document'], this.rerender, this, { document: { path: [node.id] } });
      }

      dispose () {
        super.dispose();

        this.context.appState.off(this);
      }

      getNode () {
        return this.props.node || this.props.model._node
      }
    }
  }

  class NodeComponent extends NodeComponentMixin(substance.Component) {}

  const STRING = { type: 'string', default: '' };

  function TEXT (...targetTypes) {
    return { type: 'text', targetTypes }
  }

  const STRING_ARRAY = { type: ['array', 'string'], default: [] };

  const BOOLEAN = { type: 'boolean', default: false };

  function MANY$1 (...targetTypes) {
    return { type: ['array', 'id'], targetTypes, default: [] }
  }

  function ONE$1 (...targetTypes) {
    return { type: 'id', targetTypes, default: null }
  }

  function CHILDREN (...targetTypes) {
    return { type: ['array', 'id'], targetTypes, default: [], owned: true }
  }

  // EXPERIMENTAL: similar to CHILDREN but only a single id, e.g. figure.content -> graphic
  // for now we make this non-optional
  function CHILD$1 (...targetTypes) {
    return { type: 'id', targetTypes, owned: true }
  }

  class AbstractScrollPane extends substance.Component {
    getActionHandlers () {
      return {
        'scrollSelectionIntoView': this._scrollSelectionIntoView
      }
    }
    /*
      Expose scrollPane as a child context
    */
    getChildContext () {
      return {
        scrollPane: this
      }
    }

    didMount () {
      if (substance.platform.inBrowser) {
        this.windowEl = substance.DefaultDOMElement.wrapNativeElement(window);
        this.windowEl.on('resize', this._onResize, this);
      }
      // FIXME: we need to define when exactly this must be executed
      // ATM this causes trouble when
      this.context.appState.addObserver(['@any'], this._afterRender, this, { stage: 'position' });
    }

    dispose () {
      if (this.windowEl) {
        this.windowEl.off(this);
      }
      this.context.appState.off(this);
    }

    getName () {
      return this.props.name
    }

    _computeOverlayHints () {
      let contentRect = this._getContentRect();
      let selectionRect = this._getSelectionRect();
      return {
        contentRect,
        selectionRect
      }
    }

    _reduceOverlayHints (hints) {
      // TODO: introduce a reducer for this
      this.context.appState.set('overlayHints', hints);
    }

    /*
      Determine selection rectangle relative to content element
      and emit a selection:positioned event with positioning hints
    */
    _position () {
      let hints = this._computeOverlayHints();
      if (hints) {
        this._reduceOverlayHints(hints);
        // TODO: this is problematic and needs to be approached in
        // a different way.
        // Now we use overlays not only for selection anchored popups
        // but also for menu dropdowns.
        // Only for cases where the overlay needs to be position with a selection
        // we should do that. I.e. I guess this should not be considered here at all
        // but rather done along with the selection rendering
        // this._scrollSelectionIntoView(hints.selectionRect)
      }
    }

    _afterRender () {
      this._position();
    }

    _onResize () {
      this._position();
    }

    /*
      Determine mouse bounds relative to content element
      and emit context-menu:opened event with positioning hints
    */
    _onContextMenu (e) {
      e.preventDefault();
      let mouseBounds = this._getMouseBounds(e);
      this.emit('context-menu:opened', {
        mouseBounds: mouseBounds
      });
    }

    _scrollSelectionIntoView () {
      // console.log('AbstractScrollPane._scrollSelectionIntoView()')
      let hints = this.context.appState.get('overlayHints');
      if (!hints) {
        // console.log('...no hints')
        return
      }
      let selectionRect = hints.selectionRect;
      if (!selectionRect) {
        // console.log('...no selection rect')
        return
      }
      let upperBound = this.getScrollPosition();
      let lowerBound = upperBound + this.getHeight();
      let selTop = selectionRect.top;
      let selBottom = selectionRect.top + selectionRect.height;
      if ((selTop < upperBound && selBottom < upperBound) ||
          (selTop > lowerBound && selBottom > lowerBound)) {
        this.setScrollPosition(selTop);
      }
    }

    /**
      Returns the height of scrollPane (inner content overflows)
    */
    getHeight () {
      throw new Error('Abstract method')
    }

    /**
      Returns the cumulated height of a panel's content
    */
    getContentHeight () {
      throw new Error('Abstract method')
    }

    getContentElement () {
      // TODO: should be wrapped in DefaultDOMElement
      throw new Error('Abstract method')
    }

    /**
      Get the `.se-scrollable` element
    */
    getScrollableElement () {
      throw new Error('Abstract method')
    }

    /**
      Get current scroll position (scrollTop) of `.se-scrollable` element
    */
    getScrollPosition () {
      throw new Error('Abstract method')
    }

    setScrollPosition () {
      throw new Error('Abstract method')
    }

    /**
      Get offset relative to `.se-content`.

      @param {DOMNode} el DOM node that lives inside the
    */
    getPanelOffsetForElement(el) { // eslint-disable-line
      throw new Error('Abstract method')
    }

    /**
      Scroll to a given sub component.

      @param {String} componentId component id, must be present in data-id attribute
    */
    scrollTo(componentId, onlyIfNotVisible) { // eslint-disable-line
      throw new Error('Abstract method')
    }

    _getContentRect () {
      return this.getContentElement().getNativeElement().getBoundingClientRect()
    }

    /*
      Get selection rectangle relative to panel content element
    */
    _getSelectionRect () {
      return substance.getSelectionRect(this._getContentRect())
    }

    _getMouseBounds (e) {
      return substance.getRelativeMouseBounds(e, this.getContentElement().getNativeElement())
    }
  }

  /**
    Wraps content in a scroll pane.

    @class ScrollPane
    @component

    @prop {String} scrollbarType 'native' or 'substance' for a more advanced visual scrollbar. Defaults to 'native'
    @prop {String} [scrollbarPosition] 'left' or 'right' only relevant when scrollBarType: 'substance'. Defaults to 'right'
    @prop {ui/Highlights} [highlights] object that maintains highlights and can be manipulated from different sources
    @prop {ui/TOCProvider} [tocProvider] object that maintains table of content entries

    @example

    ```js
    $$(BodyScrollPane).append(
      content,
      $$(ContextMenu)
      $$(Overlay)
    )
    ```
  */
  class BodyScrollPane extends AbstractScrollPane {
    /*
      Expose scrollPane as a child context
    */
    getChildContext () {
      return {
        scrollPane: this
      }
    }

    getName () {
      return 'body'
    }

    render ($$) {
      let el = $$('div');
      if (this.props.contextMenu === 'custom') {
        el.on('contextmenu', this._onContextMenu);
      }
      el.append(this.props.children);
      return el
    }

    /**
      Returns the height of scrollPane (inner content overflows)
    */
    getHeight () {
      if (substance.platform.inBrowser) {
        return window.innerHeight
      } else {
        return 0
      }
    }

    /**
      Returns the cumulated height of a panel's content
    */
    getContentHeight () {
      if (substance.platform.inBrowser) {
        return document.body.scrollHeight
      } else {
        return 0
      }
    }

    getContentElement () {
      if (substance.platform.inBrowser) {
        return substance.DefaultDOMElement.wrapNativeElement(window.document.body)
      } else {
        return null
      }
    }

    // /**
    //   Get the `.se-scrollable` element
    // */
    getScrollableElement () {
      if (substance.platform.inBrowser) {
        return document.body
      } else {
        return null
      }
    }

    /**
      Get current scroll position (scrollTop) of `.se-scrollable` element
    */
    getScrollPosition () {
      if (substance.platform.inBrowser) {
        return document.body.scrollTop
      } else {
        return 0
      }
    }

    setScrollPosition (scrollPos) {
      if (substance.platform.inBrowser) {
        document.body.scrollTop = scrollPos;
      }
    }

    /**
      Get offset relative to `.se-content`.

      @param {DOMNode} el DOM node that lives inside the
    */
    getPanelOffsetForElement(el) { // eslint-disable-line
      console.warn('TODO: implement');
    }

    /**
      Scroll to a given sub component.

      @param {String} componentId component id, must be present in data-id attribute
    */
    scrollTo(componentId, onlyIfNotVisible) { // eslint-disable-line
      console.warn('TODO: implement');
    }
  }

  class Button extends substance.Component {
    render ($$) {
      let el = $$('button')
        .addClass('sc-button');

      if (this.props.icon) {
        el.append(this.renderIcon($$));
      }
      if (this.props.label) {
        el.append(this.renderLabel($$));
      }
      if (this.props.tooltip) {
        el.attr('title', this.props.tooltip);
      }
      if (this.props.dropdown) {
        el.append(this.renderDropdownIcon($$));
      }
      if (this.props.active) {
        el.addClass('sm-active');
      }
      if (this.props.theme) {
        el.addClass('sm-theme-' + this.props.theme);
      }

      if (this.props.disabled) {
        // make button inaccessible
        el.attr('tabindex', -1)
          .attr('disabled', true);
      } else {
        // make button accessible for tab-navigation
        el.attr('tabindex', 1);
      }

      // Ability to inject additional elements (should be avoided!)
      el.append(this.props.children);
      return el
    }

    renderIcon ($$) {
      let iconEl = this.context.iconProvider.renderIcon($$, this.props.icon);
      return iconEl
    }

    renderDropdownIcon ($$) {
      let iconEl = this.context.iconProvider.renderIcon($$, 'dropdown');
      iconEl.addClass('se-dropdown');
      return iconEl
    }

    renderLabel ($$) {
      return $$('span').addClass('se-label').append(
        this.getLabel(this.props.label)
      )
    }

    getLabel (name) {
      let labelProvider = this.context.labelProvider;
      return labelProvider.getLabel(name, this.props.commandState)
    }
  }

  function stopEvent (e) {
    e.stopPropagation();
  }

  function stopAndPreventEvent (e) {
    stopEvent(e);
    e.preventDefault();
  }

  /**
    @param {object} props.toolPanel a ToolPanel specifcation
    @param {string} props.theme
  */
  class ToolPanel extends substance.Component {
    render($$) { // eslint-disable-line
      throw new Error('This method is abstract')
    }
    /*
      Defines the components used to render certain entry types

      Override to customize.
    */
    getEntryTypeComponents () {
      return {
        'tool-group': this.getComponent('tool-group'),
        'tool-dropdown': this.getComponent('tool-dropdown'),
        'tool-prompt': this.getComponent('tool-prompt'),
        'tool-separator': this.getComponent('tool-separator')
      }
    }

    renderEntries ($$) {
      const toolPanelSpec = this.props.toolPanel;
      const commandStates = this.props.commandStates;
      const theme = this.getTheme();
      const entryTypeComponents = this.getEntryTypeComponents();
      return toolPanelSpec.map(entry => {
        let ComponentClass = entryTypeComponents[entry.type];
        if (!ComponentClass) throw new Error('Toolpanel entry type not found')
        let props = Object.assign({}, entry, {
          commandStates,
          theme
        });
        let el = $$(ComponentClass, props);
        // only add a reference if there is a name
        if (entry.name) el.ref(entry.name);
        return el
      })
    }

    hasEnabledTools () {
      let entriesContainer = this.refs.entriesContainer;
      let entries = entriesContainer.childNodes;
      let hasEnabledTools = false;
      entries.forEach((entry) => {
        if (entry.hasEnabledTools()) {
          hasEnabledTools = true;
        }
      });
      return hasEnabledTools
    }

    getActiveToolGroupNames () {
      throw new Error('Abstract method')
    }

    showDisabled () {
      return false
    }

    /*
      Override if you just want to use a different style
    */
    getToolStyle () {
      throw new Error('Abstract method')
    }

    getTheme () {
      return this.props.theme || 'dark'
    }
  }

  // TODO: refactor this. I don't like how this is coupled to ScrollPane
  class ContextMenu extends ToolPanel {
    didMount () {
      super.didMount();
      if (!this.context.scrollPane) {
        throw new Error('Requires a scrollPane context')
      }
      this.context.scrollPane.on('context-menu:opened', this._onContextMenuOpened, this);
    }

    dispose () {
      super.dispose();
      this.context.scrollPane.off(this);
    }

    render ($$) {
      let el = $$('div').addClass('sc-context-menu sm-hidden');
      el.addClass('sm-theme-' + this.getTheme());
      el.append(
        $$('div').addClass('se-active-tools').append(
          this.renderEntries($$)
        ).ref('entriesContainer')
      );
      return el
    }

    show (hints) {
      this.el.removeClass('sm-hidden');
      this._position(hints);
    }

    hide () {
      this.el.addClass('sm-hidden');
    }

    /*
      Positions the content menu relative to the scrollPane
    */
    _onContextMenuOpened (hints) {
      let mouseBounds = hints.mouseBounds;
      this.el.removeClass('sm-hidden');
      let contextMenuWidth = this.el.htmlProp('offsetWidth');

      // By default, context menu are aligned left bottom to the mouse coordinate clicked
      this.el.css('top', mouseBounds.top);
      let leftPos = mouseBounds.left;
      // Must not exceed left bound
      leftPos = Math.max(leftPos, 0);
      // Must not exceed right bound
      let maxLeftPos = mouseBounds.left + mouseBounds.right - contextMenuWidth;
      leftPos = Math.min(leftPos, maxLeftPos);
      this.el.css('left', leftPos);
    }

    getTheme () {
      return this.props.theme || 'dark'
    }
  }

  /**
    @param {string} props.text
  */
  class Tooltip extends substance.Component {
    render ($$) {
      let el = $$('div').addClass('sc-tooltip');
      el.append(this.props.text);
      return el
    }
  }

  class FormRowComponent extends substance.Component {
    render ($$) {
      const label = this.props.label;
      const issues = this.props.issues || [];
      const hasIssues = issues.length > 0;
      const children = this.props.children;

      const el = $$('div').addClass('sc-form-row');

      if (label) {
        const labelEl = $$('div').addClass('se-label').append(label);

        if (hasIssues) {
          // TODO: use issue.key and labelProvider here
          let tooltipText = issues.map(issue => issue.message).join(', ');
          labelEl.append(
            $$('div').addClass('se-warning').append(
              $$(substance.FontAwesomeIcon, { icon: 'fa-warning' }).addClass('se-icon'),
              $$(Tooltip, {text: tooltipText})
            )
          );
        }

        el.append(labelEl);
      }

      if (hasIssues) {
        el.addClass('sm-warning');
      }

      el.append(
        $$('div').addClass('se-editor').append(children)
      );

      return el
    }
  }

  const _ManagedComponentCache = new Map();

  /*
    Example:
    ```
    $$(Managed(Toolbar), { bindings: ['commandState'] })
    ```
    `commandStates` will be taken from the app-state, and merged with the other props.
    When `commandStates` is changed, Toolbar automatically will be rerendered automatically via extendProps.
  */
  function Managed (ComponentClass) {
    if (_ManagedComponentCache.has(ComponentClass)) return _ManagedComponentCache.get(ComponentClass)

    // an anonymous class that takes care of mapping props that start with $
    class ManagedComponent extends substance.Component {
      constructor (...args) {
        super(...args);

        if (!this.context.appState) {
          throw new Error("'context.appState' is required for Managed Components.")
        }
        this._config = this._compileManagedProps(this.props);
        this._props = this._deriveManagedProps(this.props);
      }

      didMount () {
        if (this._config) {
          this._register();
        }
      }

      willReceiveProps (newProps) {
        let config = this._compileManagedProps(newProps);
        let props = this._deriveManagedProps(newProps);
        if (!this._config && config) {
          this._register();
        } else if (this._config && !config) {
          this._deregister();
        }
        this._config = config;
        this._props = props;
      }

      dispose () {
        this.context.appState.off(this);
      }

      render ($$) {
        return $$(ComponentClass, this._props).ref('managed')
      }

      _register () {
        const { stage, names } = this._config;
        this.context.appState.addObserver(names, this._onUpdate, this, { stage });
      }

      _deregister () {
        this.context.appState.off(this);
      }

      _onUpdate () {
        this._props = this._deriveManagedProps();
        this.refs.managed.extendProps(this._props);
      }

      _compileManagedProps (props) {
        let stage = 'render';
        let names = props.bindings || [];
        if (names.length > 0) {
          return { stage, names }
        } else {
          return null
        }
      }

      _deriveManagedProps (props) {
        const state = this.context.appState;
        const config = this._config;
        if (config) {
          let derivedProps = Object.assign({}, props);
          delete derivedProps.bindings;
          config.names.forEach(name => {
            derivedProps[name] = state.get(name);
          });
          return derivedProps
        } else {
          return props
        }
      }
    }

    _ManagedComponentCache.set(ComponentClass, ManagedComponent);

    return ManagedComponent
  }

  /**
    @param {boolean} props.label whether to render a label
    @param {string} props.commandName the associated command
    @param {object} props.commandState the current state of the associated command
    @param {string} props.keyboardShortcut the associated keyboard shortcut
  */
  class MenuItem extends substance.Component {
    render ($$) {
      let commandState = this.props.commandState;
      let el = $$('button')
        .addClass('sc-menu-item')
        .addClass('sm-' + this.props.commandName)
        .append(
          this._renderIcon($$),
          this._renderLabel($$),
          this._renderKeyboardShortcut($$)
        )
        .on('click', this._onClick);

      if (this.props.label) {
        el.append(this.renderLabel($$));
      }
      if (commandState.active) {
        el.addClass('sm-active');
      }
      if (commandState.disabled) {
        // make button inaccessible
        el.attr('tabindex', -1)
          .attr('disabled', true);
      } else {
        // make button accessible for tab-navigation
        el.attr('tabindex', 1);
      }
      return el
    }

    _renderLabel ($$) {
      return $$('div').addClass('se-label').append(
        this._getLabel()
      )
    }

    _renderIcon ($$) {
      return $$('div').addClass('se-icon').append(
        this.context.iconProvider.renderIcon($$, this.props.commandName)
      )
    }

    _renderKeyboardShortcut ($$) {
      const name = this.props.commandName;
      const config = this.context.config;
      const keyboardShortcut = config.getKeyboardShortcutsByCommandName(name);
      return $$('div').addClass('se-keyboard-shortcut').append(
        keyboardShortcut || ''
      )
    }

    executeCommand (params) {
      if (!this.props.commandState.disabled) {
        this.send('executeCommand', this.props.commandName, this.props.commandState, params);
      }
    }

    _getLabel () {
      let labelProvider = this.context.labelProvider;
      return labelProvider.getLabel(this.props.commandName, this.props.commandState)
    }

    _onClick (e) {
      e.preventDefault();
      e.stopPropagation();
      this.executeCommand();
    }
  }

  /*
    @param {array} props.items
    @param {object} props.commandStates
  */
  class Menu extends substance.Component {
    render ($$) {
      const items = this.props.items;
      const commandStates = this.props.commandStates;

      let el = $$('div').addClass('sc-menu');
      items.forEach(itemSpec => {
        const commandName = itemSpec.commandName;
        if (commandName) {
          const commandState = commandStates[commandName];
          el.append(
            $$(MenuItem, {
              commandName,
              commandState
            })
          );
        } else if (itemSpec.type === 'separator') {
          el.append(
            $$('div').addClass('separator')
          );
        } else {
          throw new Error('Invalid menu item specification: ' + JSON.stringify(itemSpec))
        }
      });
      return el
    }
  }

  const DISABLED$1 = { disabled: true };

  /*
    A component that renders a group of tools.

    @param {string} props.name
    @param {boolean} props.showDisabled
    @param {string} props.style
    @param {string} props.theme
    @param {array} props.items array of item specifications
    @param {object} props.commandStates
  */
  class ToolGroup extends substance.Component {
    render ($$) {
      const {
        name, showDisabled, style, theme,
        items, commandStates
      } = this.props;

      let el = $$('div')
        .addClass(this._getClassNames())
        .addClass('sm-' + name);

      items.forEach(toolSpec => {
        const commandName = toolSpec.commandName;
        let commandState = commandStates[commandName] || DISABLED$1;
        if (this.isToolEnabled(toolSpec, commandState) || showDisabled) {
          let ToolClass = this._getToolClass(toolSpec);
          el.append(
            $$(ToolClass, {
              commandName,
              name: commandName,
              commandState,
              style,
              theme
            }).ref(commandName)
          );
        }
      });

      return el
    }

    /*
      Determine wether a tool should be shown or not
    */
    isToolEnabled (toolSpec, commandState) {
      let disabled = (
        !commandState ||
        commandState.disabled ||
        (this.props.contextual && !toolSpec.showInContext)
      );
      return !disabled
    }

    /*
      Returns true if at least one command is enabled
    */
    hasEnabledTools (commandStates) {
      if (!commandStates) {
        commandStates = this.props.commandStates;
      }
      let items = this.props.items;
      for (let i = 0; i < items.length; i++) {
        let itemSpec = items[i];
        let commandState = commandStates[itemSpec.commandName];
        if (this.isToolEnabled(itemSpec, commandState)) return true
      }
      return false
    }

    _getClassNames () {
      return 'sc-tool-group'
    }

    _getToolClass (toolSpec) {
      // use an ToolClass from toolSpec if configured inline in ToolGroup spec
      let ToolClass = toolSpec.ToolClass;
      // next try if there is a tool registered by the name
      if (!ToolClass) {
        ToolClass = this.context.toolRegistry.get(toolSpec.commandName);
      }
      // after all fall back to default classes
      if (!ToolClass) {
        if (this.props.style === 'descriptive') {
          ToolClass = this.getComponent('menu-item');
        } else {
          ToolClass = this.getComponent('toggle-tool');
        }
      }
      return ToolClass
    }
  }

  /**
    A component that renders a group of menu items.
  */
  class MenuGroup extends ToolGroup {
    _getToolClass (toolSpec) {
      return toolSpec.ToolClass || this.getComponent('menu-item')
    }

    _getClassNames () {
      return 'sc-menu-group'
    }
  }

  /**
    ModalDialog component

    @class
    @component

    @prop {String} width 'small', 'medium', 'large' and 'full'

    @example

    ```js
    var form = $$(ModalDialog, {
      width: 'medium',
      textAlign: 'center'
    });
    ```
  */
  class ModalDialog extends substance.Component {
    render ($$) {
      let el = $$('div').addClass('sc-modal-dialog');
      let width = this.props.width || 'large';

      // TODO: don't think that this is good enough. Right the modal is closed by any unhandled click.
      // Need to be discussed.
      el.on('click', this._closeModal);
      el.on('keydown', this._onKeydown);

      if (this.props.width) {
        el.addClass('sm-width-' + width);
      }

      if (this.props.transparent) {
        el.addClass('sm-transparent-bg');
      }

      el.append(
        $$('div').addClass('se-body').append(
          this.props.children
        )
      );
      return el
    }

    _onKeydown (e) {
      e.stopPropagation();
    }

    _closeModal (e) {
      e.preventDefault();
      e.stopPropagation();
      // wrap the target so that we can use DOMElement API
      let targetEl = substance.DefaultDOMElement.wrap(e.target);
      let closeSurfaceClick = targetEl.hasClass('sc-modal-dialog');
      if (closeSurfaceClick) {
        this.send('closeModal');
      }
    }
  }

  /**
    @param {object} overlayHints hints derived from the rendered selection.
  */
  class Overlay extends ToolPanel {
    didMount () {
      super.didMount();

      this._positionOverlay();

      // TODO: avoid using appState directly, instead use a Managed component
      this.context.appState.addObserver(['overlayHints'], this._positionOverlay, this, { stage: 'finalize' });
    }

    dispose () {
      super.dispose();

      this.context.appState.removeObserver(this);
    }

    didUpdate () {
      super.didUpdate();

      this._positionOverlay();
    }

    render ($$) {
      let el = $$('div').addClass('sc-overlay');
      el.addClass('sm-hidden');
      el.addClass('sm-theme-' + this.getTheme());
      el.append(
        $$('div').addClass('se-active-tools').append(
          this.renderEntries($$)
        ).ref('entriesContainer')
      );
      return el
    }

    renderEntries (...args) {
      return super.renderEntries(...args)
    }

    _positionOverlay () {
      let hints = this.context.appState.get('overlayHints');

      if (hints && this.hasEnabledTools()) {
        this.el.removeClass('sm-hidden');
        let overlayWidth = this.el.htmlProp('offsetWidth');
        let selRect = hints.selectionRect;
        if (selRect) {
          let selectionMaxWidth = selRect.width;
          // By default, Overlays are aligned center/bottom to the selection
          this.el.css('top', selRect.top + selRect.height);
          let leftPos = selRect.left + selectionMaxWidth / 2 - overlayWidth / 2;
          // Must not exceed left bound
          leftPos = Math.max(leftPos, 0);
          // Must not exceed right bound
          let maxLeftPos = selRect.left + selectionMaxWidth + selRect.right - overlayWidth;
          leftPos = Math.min(leftPos, maxLeftPos);
          this.el.css('left', leftPos);
        } else {
          this.el.addClass('sm-hidden');
        }
      } else {
        this.el.addClass('sm-hidden');
      }
    }
  }

  class PinnedMessage extends substance.Component {
    render ($$) {
      const icon = this.props.icon;
      const label = this.props.label;

      const el = $$('div').addClass('sc-pinned-message');
      const wrapper = $$('div').addClass('se-msg-wrap');

      if (icon) {
        wrapper.append(
          $$(substance.FontAwesomeIcon, {icon: icon}).addClass('se-icon')
        );
      }

      if (label) {
        wrapper.append(
          $$('div').addClass('se-msg')
            .append(label)
        );
      }

      el.append(wrapper);

      return el
    }
  }

  /**
    Wraps content in a scroll pane.

    NOTE: It is best practice to put all overlays as direct childs of the ScrollPane
          to reduce the chance that positioning gets messed up (position: relative)

    @prop {String} scrollbarType 'native' or 'substance' for a more advanced visual scrollbar. Defaults to 'native'
    @prop {String} [scrollbarPosition] 'left' or 'right' only relevant when scrollBarType: 'substance'. Defaults to 'right'
    @prop {ui/Highlights} [highlights] object that maintains highlights and can be manipulated from different sources
    @prop {ui/TOCProvider} [tocProvider] object that maintains table of content entries

    @example

    ```js
    $$(ScrollPane, {
      scrollbarType: 'substance', // defaults to native
      scrollbarPosition: 'left', // defaults to right
      onScroll: this.onScroll.bind(this),
      highlights: this.contentHighlights,
      tocProvider: this.tocProvider
    })
    ```
  */
  class ScrollPane extends AbstractScrollPane {
    didMount () {
      super.didMount();

      // TODO: these should come from AppState
      if (this.refs.scrollbar && this.props.highlights) {
        this.props.highlights.on('highlights:updated', this.onHighlightsUpdated, this);
      }

      if (this.refs.scrollbar) {
        if (substance.platform.inBrowser) {
          this.domObserver = new window.MutationObserver(this._onContentChanged.bind(this));
          this.domObserver.observe(this.el.getNativeElement(), {
            subtree: true,
            attributes: true,
            characterData: true,
            childList: true
          });
        }
      }
    }

    dispose () {
      super.dispose();

      if (this.props.highlights) {
        this.props.highlights.off(this);
      }
      if (this.domObserver) {
        this.domObserver.disconnect();
      }
    }

    render ($$) {
      let el = $$('div')
        .addClass('sc-scroll-pane');

      if (substance.platform.isFF) {
        el.addClass('sm-firefox');
      }

      // When noStyle is provided we just use ScrollPane as a container, but without
      // any absolute positioned containers, leaving the body scrollable.
      if (!this.props.noStyle) {
        el.addClass('sm-default-style');
      }

      // Initialize Substance scrollbar (if enabled)
      if (this.props.scrollbarType === 'substance') {
        el.addClass('sm-substance-scrollbar');
        el.addClass('sm-scrollbar-position-' + this.props.scrollbarPosition);

        el.append(
          // TODO: is there a way to pass scrollbar highlights already
          // via props? Currently the are initialized with a delay
          $$(substance.Scrollbar, {
            scrollPane: this
          }).ref('scrollbar')
            .attr('id', 'content-scrollbar')
        );

        // Scanline is debugging purposes, display: none by default.
        el.append(
          $$('div').ref('scanline').addClass('se-scanline')
        );
      }

      el.append(
        $$('div').ref('scrollable').addClass('se-scrollable').append(
          this.renderContent($$)
        ).on('scroll', this.onScroll)
      );
      return el
    }

    renderContent ($$) {
      let contentEl = $$('div').ref('content').addClass('se-content');
      contentEl.append(this.props.children);
      if (this.props.contextMenu === 'custom') {
        contentEl.on('contextmenu', this._onContextMenu);
      }
      return contentEl
    }

    _onContentChanged () {
      this._contentChanged = true;
    }

    _afterRender () {
      super._afterRender();

      if (this.refs.scrollbar && this._contentChanged) {
        this._contentChanged = false;
        this._updateScrollbar();
      }
    }

    _updateScrollbar () {
      if (this.refs.scrollbar) {
        this.refs.scrollbar.updatePositions();
      }
    }

    onHighlightsUpdated (highlights) {
      this.refs.scrollbar.extendProps({
        highlights: highlights
      });
    }

    onScroll () {
      let scrollPos = this.getScrollPosition();
      let scrollable = this.refs.scrollable;
      if (this.props.onScroll) {
        this.props.onScroll(scrollPos, scrollable);
      }
      // Update TOCProvider given
      if (this.props.tocProvider) {
        this.props.tocProvider.markActiveEntry(this);
      }
      this.emit('scroll', scrollPos, scrollable);
    }

    /**
      Returns the height of scrollPane (inner content overflows)
    */
    getHeight () {
      let scrollableEl = this.getScrollableElement();
      return scrollableEl.height
    }

    /**
      Returns the cumulated height of a panel's content
    */
    getContentHeight () {
      let contentEl = this.refs.content.el.getNativeElement();
      // Important to use scrollHeight here (e.g. to consider overflowing
      // content, that stretches the content area, such as an overlay or
      // a context menu)
      return contentEl.scrollHeight
    }

    /**
      Get the `.se-content` element
    */
    getContentElement () {
      return this.refs.content.el
    }

    /**
      Get the `.se-scrollable` element
    */
    getScrollableElement () {
      return this.refs.scrollable.el
    }

    /**
      Get current scroll position (scrollTop) of `.se-scrollable` element
    */
    getScrollPosition () {
      let scrollableEl = this.getScrollableElement();
      return scrollableEl.getProperty('scrollTop')
    }

    setScrollPosition (scrollPos) {
      // console.log('ScrollPane.setScrollPosition()')
      let scrollableEl = this.getScrollableElement();
      scrollableEl.setProperty('scrollTop', scrollPos);
    }

    /**
      Get offset relative to `.se-content`.

      @param {DOMNode} el DOM node that lives inside the
    */
    getPanelOffsetForElement (el) {
      let contentContainerEl = this.refs.content.el;
      let rect = substance.getRelativeBoundingRect(el, contentContainerEl);
      return rect.top
    }

    /**
      Scroll to a given sub component.

      @param {String} componentId component id, must be present in data-id attribute
    */
    scrollTo (selector, onlyIfNotVisible) {
      // console.log('ScrollPane.scrollTo()', selector)
      let scrollableEl = this.getScrollableElement();
      let el = scrollableEl.find(selector);
      if (el) {
        this.scrollElementIntoView(el, onlyIfNotVisible);
      } else {
        console.warn(`No match found for selector '${selector}' in scrollable container`);
      }
    }

    scrollElementIntoView (el, onlyIfNotVisible) {
      // console.log('ScrollPane.scrollTo()', selector)
      let scrollableEl = this.getScrollableElement();
      const offset = this.getPanelOffsetForElement(el);
      let shouldScroll = true;
      if (onlyIfNotVisible) {
        const height = scrollableEl.height;
        const oldOffset = scrollableEl.getProperty('scrollTop');
        shouldScroll = (offset < oldOffset || oldOffset + height < offset);
      }
      if (shouldScroll) {
        this.setScrollPosition(offset);
      }
    }

    _onResize (...args) {
      super._onResize(...args);
      this._updateScrollbar();
    }

    _onContextMenu (e) {
      super._onContextMenu(e);
      this._updateScrollbar();
    }
  }

  /**
    @param {string} props.commandName
    @param {object} props.commandState
    @param {string} props.theme
    @param {string} props.keyboardShortcut
  */
  class ToggleTool extends substance.Component {
    render ($$) {
      let el = $$('div')
        .addClass('sc-toggle-tool')
        .addClass(this.getClassNames());
      el.append(
        this.renderButton($$)
      );
      el.append(
        $$(Tooltip, {
          text: this._getTooltipText()
        })
      );
      return el
    }

    renderButton ($$) {
      const { active, disabled } = this.props.commandState;
      const Button = this.getComponent('button');
      let btn = $$(Button, {
        icon: this._getIconName(),
        active,
        disabled,
        theme: this.props.theme
      }).on('click', this.onClick);
      return btn
    }

    getClassNames () {
      return `sm-${this._getName()}`
    }

    onClick (e) {
      e.preventDefault();
      e.stopPropagation();
      if (!this.props.commandState.disabled) {
        // no props by default
        this.executeCommand();
      }
    }

    executeCommand (params) {
      this.send('executeCommand', this.props.commandName, params);
    }

    _getTooltipText () {
      const label = this._getLabel();
      const name = this._getName();
      // TODO: instead of letting this tool lookup keyboard shortcutm it should
      const config = this.context.config;
      const keyboardShortcut = config.getKeyboardShortcutsByCommandName(name);
      if (keyboardShortcut) {
        return [label, ' (', keyboardShortcut, ')'].join('')
      } else {
        return label
      }
    }

    _getName () {
      return this.props.commandName
    }

    _getLabel () {
      return this.context.labelProvider.getLabel(this._getName())
    }

    _getIconName () {
      return this._getName()
    }

    // Used by Configurator to detect that only Tool classes are registered
    get _isTool () {
      return true
    }
  }

  class ToolbarV2 extends ToolPanel {
    render ($$) {
      let el = $$('div').addClass('sc-toolbar');
      el.append(
        $$('div').addClass('se-active-tools').append(
          this.renderEntries($$)
        ).ref('entriesContainer')
      );
      return el
    }

    getTheme () {
      return this.props.theme || 'light'
    }
  }

  // TODO: use OverlayMixin to avoid code redundancy
  class ToolDropdown extends ToolGroup {
    constructor (...args) {
      super(...args);

      this._deriveState(this.props);
    }

    didMount () {
      this.context.appState.addObserver(['overlayId'], this.rerender, this, { stage: 'render' });
    }

    dispose () {
      this.context.appState.removeObserver(this);
    }

    willReceiveProps (newProps) {
      this._deriveState(newProps);
    }

    render ($$) {
      let el = $$('div').addClass('sc-tool-dropdown');
      el.addClass('sm-' + this.props.name);

      const appState = this.context.appState;
      const commandStates = this.props.commandStates;
      const toggleName = this._getToggleLabel();
      const showDisabled = this.props.showDisabled;
      const hasEnabledTools = this._hasEnabledTools;
      const showChoices = appState.overlayId === this.getId();
      const style = this.props.style;
      const theme = this.props.theme;

      // Only render this if there are enabled tools
      // except if the user decided to show disabled commands
      if (showDisabled || hasEnabledTools) {
        const Button = this.getComponent('button');
        const Menu = this.getComponent('menu');
        let toggleButtonProps = {
          dropdown: true,
          active: showChoices,
          theme,
          // Note: we are passing the command state allowing to render labels with template strings
          commandState: commandStates[toggleName]
        };
        if (style === 'minimal') {
          toggleButtonProps.icon = toggleName;
        } else if (style === 'descriptive') {
          toggleButtonProps.label = toggleName;
        } else {
          toggleButtonProps.icon = toggleName;
          toggleButtonProps.label = toggleName;
        }
        let toggleButton = $$(Button, toggleButtonProps).addClass('se-toggle')
          .on('click', this._toggleChoices);
        el.append(toggleButton);

        if (showChoices) {
          const items = this._getMenuItems();
          el.append(
            $$('div').addClass('se-choices').append(
              $$(Menu, {
                items,
                commandStates
              })
            )
          );
        } else if (style === 'minimal' || toggleName !== this.props.name) {
          // NOTE: tooltips are only rendered when explanation is needed
          el.append(
            this._renderToolTip($$)
          );
        }
      }
      return el
    }

    _renderToolTip ($$) {
      let labelProvider = this.context.labelProvider;
      return $$(Tooltip, {
        text: labelProvider.getLabel(this.props.name)
      })
    }

    _deriveState (props) {
      const commandStates = props.commandStates;
      const items = props.items;
      let activeCommandName;
      let hasEnabledTools = false;
      this._items = items.map(toolSpec => {
        const commandName = toolSpec.commandName;
        let commandState = commandStates[commandName] || { disabled: true };
        if (!activeCommandName && commandState.active) activeCommandName = commandName;
        if (!commandState.disabled) hasEnabledTools = true;
        return {
          name: commandName,
          toolSpec,
          commandState
        }
      });
      this._activeCommandName = activeCommandName;
      this._hasEnabledTools = hasEnabledTools;
    }

    /*
      This can be overridden to control the label
    */
    _getToggleLabel () {
      return this._activeCommandName || this.props.name
    }

    _getMenuItems () {
      const showDisabled = this.props.showDisabled;
      let menuItems = [];
      this._items.forEach(item => {
        // ATTENTION: not showing the disabled ones is violating the users choice
        // given via configuration 'showDisabled'
        if (showDisabled || this.isToolEnabled(item.toolSpec, item.commandState)) {
          menuItems.push({
            commandName: item.name
          });
        }
      });
      return menuItems
    }

    _toggleChoices (event) {
      event.preventDefault();
      event.stopPropagation();
      this.send('toggleOverlay', this.getId());
    }
  }

  class ToolPromptV2 extends ToolGroup {
    _getClassNames () {
      return 'sc-tool-prompt'
    }
  }

  var BasePackage = {
    name: 'TextureBase',
    configure: function (configurator) {
      configurator.import(substance.ButtonPackage);
      configurator.import(substance.ScrollPanePackage);
      configurator.import(substance.BodyScrollPanePackage);
      configurator.import(substance.SplitPanePackage);
      configurator.import(substance.TabbedPanePackage);
      configurator.import(substance.ScrollbarPackage);
      configurator.import(substance.ContextMenuPackage);
      configurator.import(substance.OverlayPackage);
      configurator.import(substance.DropzonesPackage);
      configurator.import(substance.ToolPanelPackage);

      configurator.addComponent('annotation', AnnotationComponent);
      // customized built-ins
      configurator.addComponent('container-editor', ContainerEditorNew);
      configurator.addComponent('isolated-node', IsolatedNodeComponentNew);
      configurator.addComponent('inline-node', IsolatedInlineNodeComponentNew);
      configurator.addComponent('text-property', TextPropertyComponentNew);
      configurator.addComponent('text-property-editor', TextPropertyEditorNew);

      // replacing Substance components with custom ones
      configurator.addComponent('scroll-pane', ScrollPane, true);
      configurator.addComponent('body-scroll-pane', BodyScrollPane, true);

      configurator.addComponent('menu', Menu, true);
      configurator.addComponent('menu-group', MenuGroup, true);
      configurator.addComponent('menu-item', MenuItem, true);
      configurator.addComponent('modal', ModalDialog);
      configurator.addComponent('button', Button, true);
      configurator.addComponent('context-menu', ContextMenu, true);
      configurator.addComponent('overlay', Overlay, true);
      configurator.addComponent('toggle-tool', ToggleTool, true);
      configurator.addComponent('toolbar', ToolbarV2, true);
      configurator.addComponent('tool-dropdown', ToolDropdown, true);
      configurator.addComponent('tool-group', ToolGroup, true);
      configurator.addComponent('tool-prompt', ToolPromptV2, true);

      configurator.addLabel('text-types', {
        en: 'Text Type',
        de: 'Texttyp'
      });
      configurator.addLabel('container-selection', {
        en: 'Container',
        de: 'Container'
      });
      configurator.addLabel('@container', {
        en: 'Container',
        de: 'Container'
      });
    }
  }

  /*
    Attention: in contrast to Substance.SelectAllCommand, this implementation does not take the surface type into consideration.
    The problem is, that for that, appState.focusedSurface would need to be reduced in an earlier stage, which is impossible, as Surfaces
    are rendered during 'render' stage. So this is kind of an chicken-egg problem.
    In general, we should avoid making commandStates depend on rendered components.
  */
  class SelectAllCommand extends substance.Command {
    getCommandState (params) {
      let editorSession = params.editorSession;
      let isBlurred = editorSession.isBlurred();
      let sel = editorSession.getSelection();
      let disabled = (
        isBlurred ||
        !sel || sel.isNull()
      );
      return { disabled }
    }

    execute (params, context) {
      let editorSession = context.editorSession;
      let appState = context.appState;
      let focusedSurface = appState.focusedSurface;
      if (focusedSurface) {
        let sel = null;
        let surfaceId = focusedSurface.id;
        if (focusedSurface._isContainerEditor) {
          let container = focusedSurface.getContainer();
          let nodeIds = container.getContent();
          if (nodeIds.length === 0) return false
          let firstNodeId = nodeIds[0];
          let lastNodeId = substance.last(nodeIds);
          sel = editorSession.createSelection({
            type: 'container',
            startPath: [firstNodeId],
            startOffset: 0,
            endPath: [lastNodeId],
            endOffset: 1,
            containerId: container.id,
            surfaceId
          });
        } else if (focusedSurface._isTextPropertyEditor) {
          let path = focusedSurface.getPath();
          let doc = editorSession.getDocument();
          let text = doc.get(path);
          sel = editorSession.createSelection({
            type: 'property',
            path: path,
            startOffset: 0,
            endOffset: text.length,
            surfaceId
          });
        }
        if (sel) {
          editorSession.setSelection(sel);
        }
        return true
      }
      return false
    }
  }

  var EditorBasePackage = {
    name: 'EditorBase',
    configure: function (config) {
      // TODO: do we still need this?
      config.import(substance.InputPackage);

      config.addCommand('undo', substance.UndoCommand, { commandGroup: 'undo-redo' });
      config.addCommand('redo', substance.RedoCommand, { commandGroup: 'undo-redo' });
      config.addCommand('select-all', SelectAllCommand, { commandGroup: 'selection' });

      config.addIcon('insert', { 'fontawesome': 'fa-plus' });
      config.addIcon('undo', { 'fontawesome': 'fa-undo' });
      config.addIcon('redo', { 'fontawesome': 'fa-repeat' });
      config.addIcon('edit', { 'fontawesome': 'fa-cog' });
      config.addIcon('delete', { 'fontawesome': 'fa-times' });
      config.addIcon('expand', { 'fontawesome': 'fa-arrows-h' });
      config.addIcon('truncate', { 'fontawesome': 'fa-arrows-h' });

      config.addLabel('undo', {
        en: 'Undo',
        de: 'Rckgngig'
      });
      config.addLabel('redo', {
        en: 'Redo',
        de: 'Wiederherstellen'
      });
      config.addLabel('select-all', {
        en: 'Select All',
        de: 'Alles Auswhlen'
      });
      config.addLabel('close', {
        en: 'Close',
        de: 'Schlieen'
      });

      config.addKeyboardShortcut('CommandOrControl+Z', { command: 'undo' });
      config.addKeyboardShortcut('CommandOrControl+Shift+Z', { command: 'redo' });
      config.addKeyboardShortcut('CommandOrControl+A', { command: 'select-all' });
    }
  }

  const MANUSCRIPT_MODE = 'manuscript';
  const PREVIEW_MODE = 'preview';
  const METADATA_MODE = 'metadata';

  // Reference Types
  const JOURNAL_ARTICLE_REF = 'journal-article-ref';
  const BOOK_REF = 'book-ref';
  const CHAPTER_REF = 'chapter-ref';
  const CONFERENCE_PAPER_REF = 'conference-paper-ref';
  const DATA_PUBLICATION_REF = 'data-publication-ref';
  const PATENT_REF = 'patent-ref';
  const ARTICLE_REF = 'article-ref';
  const NEWSPAPER_ARTICLE_REF = 'newspaper-article-ref';
  const MAGAZINE_ARTICLE_REF = 'magazine-article-ref';
  const REPORT_REF = 'report-ref';
  const SOFTWARE_REF = 'software-ref';
  const THESIS_REF = 'thesis-ref';
  const WEBPAGE_REF = 'webpage-ref';

  const JATS_BIBR_TYPES_TO_INTERNAL = {
    'journal': JOURNAL_ARTICLE_REF,
    'book': BOOK_REF,
    'chapter': CHAPTER_REF,
    'confproc': CONFERENCE_PAPER_REF,
    'data': DATA_PUBLICATION_REF,
    'patent': PATENT_REF,
    'article': ARTICLE_REF,
    'newspaper': NEWSPAPER_ARTICLE_REF,
    'magazine': MAGAZINE_ARTICLE_REF,
    'report': REPORT_REF,
    'software': SOFTWARE_REF,
    'thesis': THESIS_REF,
    'webpage': WEBPAGE_REF
  };

  const INTERNAL_BIBR_TYPES_TO_JATS = Object.keys(JATS_BIBR_TYPES_TO_INTERNAL).reduce((map, jatsType) => {
    let internalType = JATS_BIBR_TYPES_TO_INTERNAL[jatsType];
    map[internalType] = jatsType;
    return map
  }, {});

  const JATS_BIBR_TYPES = Object.keys(JATS_BIBR_TYPES_TO_INTERNAL);

  const INTERNAL_BIBR_TYPES = Object.keys(INTERNAL_BIBR_TYPES_TO_JATS);

  // EXPERIMENTAL: properties that must not be empty
  // TODO: this should be configurable
  const REQUIRED_PROPERTIES = {
    'book-ref': new Set(['authors', 'title']),
    'chapter-ref': new Set(['title', 'containerTitle', 'authors']),
    'data-publication-ref': new Set(['title', 'containerTitle', 'authors']),
    'magazine-article-ref': new Set(['title', 'containerTitle', 'authors']),
    'newspaper-article-ref': new Set(['title', 'containerTitle', 'authors']),
    'patent-ref': new Set(['title', 'containerTitle', 'inventors']),
    'journal-article-ref': new Set(['title', 'containerTitle', 'authors']),
    'article-ref': new Set(['title', 'containerTitle', 'authors']),
    'conference-paper-ref': new Set(['title', 'authors']),
    'report-ref': new Set(['title', 'authors']),
    'softwareref': new Set(['title', 'authors']),
    'thesis-ref': new Set(['title', 'authors', 'year']),
    'webpage-ref': new Set(['title', 'containerTitle', 'authors']),
    'person': new Set(['surname', 'givenNames']),
    'ref-contrib': new Set(['name', 'givenNames']),
    'group': new Set(['name']),
    'organisation': new Set(['name']),
    'award': new Set(['institution']),
    'keyword': new Set(['name']),
    'subject': new Set(['name']),
    'figure': new Set(['title', 'caption'])
  };
  const LICENSES = [
    {
      id: 'http://creativecommons.org/licenses/by/4.0/',
      name: 'CC BY 4.0'
    },
    {
      id: 'https://creativecommons.org/licenses/by-sa/2.0/',
      name: 'CC BY-SA 2.0'
    }
  ];

  const CARD_MINIMUM_FIELDS = 3;

  // left side: node type
  // right side: ref-type
  const REF_TYPES = {
    'figure': 'fig',
    'repro-fig': 'fig',
    'fig-group': 'fig',
    'fn': 'fn',
    'ref': 'bibr',
    'table-figure': 'table',
    'table-wrap-group': 'table'
  };

  // TODO: how could this be configured?
  const RefTypeToManager = {
    'bibr': 'referenceManager',
    'fig': 'figureManager',
    'table': 'tableManager',
    'fn': 'footnoteManager'
  };

  // left side: ref-type
  // right side: [... node types]
  const XREF_TARGET_TYPES = Object.keys(REF_TYPES).reduce((m, type) => {
    const refType = REF_TYPES[type];
    if (!m[refType]) m[refType] = [];
    m[refType].push(type);
    return m
  }, {});

  function getXrefTargets (xref) {
    let idrefs = xref.getAttribute('rid');
    if (idrefs) {
      return idrefs.split(' ')
    } else {
      return []
    }
  }

  function getXrefLabel (xref) {
    // Note: we will store the label in the node state
    // when we generate it
    if (xref.state && xref.state.label) {
      return xref.state.label
    }
    // otherwise we take the text content or an empty string
    return xref.textContent || ' '
  }

  function _getCitationManagerForXref (xref, context) {
    return _getManagerByRefType(xref.getAttribute('ref-type'), context)
  }

  function _getManagerByRefType (refType, context) {
    const articleSession = context.api.getArticleSession();
    let managerName = RefTypeToManager[refType];
    if (managerName) {
      switch (managerName) {
        case 'figureManager':
          return articleSession.getFigureManager()
        case 'footnoteManager':
          return articleSession.getFootnoteManager()
        case 'referenceManager':
          return articleSession.getReferenceManager()
        case 'tableManager':
          return articleSession.getTableManager()
        default:
          //
      }
    }
  }

  function hasAvailableXrefTargets (refType, context) {
    const manager = _getManagerByRefType(refType, context);
    if (manager) {
      return manager.hasCitables()
    }
    return false
  }

  /*
    Computes available targets for a given xref node
    that the user can choose from.

    This implementation is very much tailored for the requirements
    in the UI, being a selection dialog.

    ```
    [
      {
        selected: true,
        node: TARGET_NODE
      }
      ,...
    ]
    ```
  */
  function getAvailableXrefTargets (xref, context) {
    let manager = _getCitationManagerForXref(xref, context);
    if (!manager) return []
    let selectedTargets = getXrefTargets(xref);
    // retrieve all possible nodes that this
    // xref could potentially point to,
    // so that we can let the user select from a list.
    let nodes = manager.getSortedCitables();
    // Determine broken targets (such that don't exist in the document)
    let brokenTargets = substance.without(selectedTargets, ...nodes.map(r => r.id));
    let targets = nodes.map((node) => {
      // ATTENTION: targets are not just nodes
      // but entries with some information
      return {
        selected: substance.includes(selectedTargets, node.id),
        node: node,
        id: node.id
      }
    });
    targets = brokenTargets.map(id => {
      return { selected: true, node: undefined, id }
    }).concat(targets);
    // Makes the selected targets go to top
    targets = substance.orderBy(targets, ['selected'], ['desc']);
    return targets
  }

  /*
    Index for Xrefs.

    @example
    Lets us look up existing xrefs by target

    To get all xrefs for a given target node (e.g. fn-1)

      var xIndex = doc.xrefIndex
      xIndex.get('fn-1')
  */
  class XrefIndex extends substance.DocumentIndex {
    constructor () {
      super();
      this.byTarget = new substance.TreeIndex.Arrays();
    }

    select (node) {
      return node.type === 'xref'
    }

    clear () {
      this.byTarget.clear();
    }

    // TODO: use object interface? so we can combine filters (path and type)
    get (targetId) {
      let ids = this.byTarget.get(targetId);
      // We need to return a clone, as the index may change while the result is used
      return ids ? ids.slice() : []
    }

    create (xref) {
      // const path = anno.start.path
      let targets = getXrefTargets(xref);
      targets.forEach((target) => {
        this.byTarget.add(target, xref.id);
      });
    }

    _delete (xrefId, targets) {
      targets.forEach((target) => {
        this.byTarget.remove(target, xrefId);
      });
    }

    delete (xref) {
      let targets = getXrefTargets(xref);
      this._delete(xref.id, targets);
    }

    update (node, path, newValue, oldValue) {
      if (path[2] === 'rid') {
        let targets = [];
        if (oldValue) {
          targets = oldValue.split(' ');
        }
        this._delete(node.id, targets);
        this.create(node);
      }
    }
  }

  /*
    EXPERIMENTAL: an 'Editing' interface that takes the XML schema into account.
    TODO: try to generalize this and add it to the 'app dev kit'
  */
  class TextureEditing extends substance.Editing {
    // EXPERIMENTAL: run validation after pasting
    // and throw if there are errors
    // We need to find out which is the best way regarding schema
    // strictness
    // While it would be fantastic to be 100% strict all the time
    // it could also be a way to introduce an issue system
    // and instead failing badly, just make the user aware of these
    // issues
    // TODO: in general we would need to 'pre-process'
    paste (tx, content) {
      if (!content) return
      /* istanbul ignore else  */
      if (substance.isString(content)) {
        substance.paste(tx, {text: content});
      } else if (content._isDocument) {
        substance.paste(tx, { doc: content });
      } else {
        throw new Error('Illegal content for paste.')
      }

      // FIXME: revisit on-the-fly validation
      // let res = validateXMLSchema(InternalArticleSchema, tx.getDocument().toXML())
      // if (!res.ok) {
      //   res.errors.forEach((err) => {
      //     console.error(err.msg, err.el)
      //   })
      //   throw new Error('Paste is violating the schema')
      // }
    }

    /*
      2.0 API suggestion (pass only id, not data)
    */
    insertInlineNode (tx, node) {
      let sel = tx.selection;
      let text = '\uFEFF';
      this.insertText(tx, text);
      sel = tx.selection;
      let endOffset = tx.selection.end.offset;
      let startOffset = endOffset - text.length;
      // TODO: introduce a coordinate operation for that
      tx.set([node.id, 'start', 'path'], sel.path);
      tx.set([node.id, 'start', 'offset'], startOffset);
      tx.set([node.id, 'end', 'path'], sel.path);
      tx.set([node.id, 'end', 'offset'], endOffset);
      return node
    }

    createTextNode (tx, container, text) {
      // FIXME: FIXME: bring back schema compliant tx.createTextNode()
      // let parentType = container.type
      // TODO: revisit on-the-fly schema check
      // let schema = InternalArticleSchema.getElementSchema(parentType)
      // if (schema.isAllowed('p')) {
      //   return tx.create({ type: 'p', content: text })
      // } else {
      //   throw new Error(`FIXME: which default element should be used in <${parentType}>`)
      // }
      return tx.create({ type: 'p', content: text })
    }

    createListNode (tx, container, params) {
      // FIXME: bring back schema compliant tx.createTextNode()
      // let parentType = container.type
      // let schema = InternalArticleSchema.getElementSchema(parentType)
      // if (schema.isAllowed('list')) {
      //   let el = tx.create({ type: 'list' })
      //   if (params.listType) {
      //     el.attr('list-type', params.listType)
      //   }
      //   return el
      // } else {
      //   throw new Error(`<list> is not allowed in <${parentType}>`)
      // }
      let el = tx.create({ type: 'list' });
      if (params.listType) {
        el.attr('list-type', params.listType);
      }
      return el
    }
  }

  /*
    Proposal for Substance 2.0 XMLEditingInterface
  */
  class TextureEditingInterface extends substance.EditingInterface {
    find (cssSelector) {
      return this.getDocument().find(cssSelector)
    }

    findAll (cssSelector) {
      return this.getDocument().findAll(cssSelector)
    }

    createElement (...args) {
      return this.getDocument().createElement(...args)
    }
  }

  // TODO: it would be better to use a general document implementation (like XMLDocument)
  // and come up with a new mechanism to bind indexes to the document instance
  // Helpers like findByType and such can be achieved differently
  class InternalArticleDocument extends substance.Document {
    _initialize () {
      super._initialize();

      // special index for xref lookup
      this.addIndex('xrefs', new XrefIndex());
    }

    getRootNode () {
      return this.get('article')
    }

    getXRefs () {
      let articleEl = this.get('article');
      return articleEl.findAll('xref')
    }

    getTitle () {
      return this.get('front').find('title').getText()
    }

    createEditingInterface () {
      return new TextureEditingInterface(this, { editing: new TextureEditing() })
    }

    createElement (type, data) {
      let nodeData = Object.assign({
        type
      }, data);
      return this.create(nodeData)
    }

    find (selector) {
      return this.get('article').find(selector)
    }

    findAll (selector) {
      return this.get('article').findAll(selector)
    }

    invert (change) {
      let inverted = change.invert();
      let info = inverted.info || {};
      switch (change.info.action) {
        case 'insertRows': {
          info.action = 'deleteRows';
          break
        }
        case 'deleteRows': {
          info.action = 'insertRows';
          break
        }
        case 'insertCols': {
          info.action = 'deleteCols';
          break
        }
        case 'deleteCols': {
          info.action = 'insertCols';
          break
        }
        default:
          //
      }
      inverted.info = info;
      return inverted
    }

    static createEmptyArticle (schema) {
      let doc = new InternalArticleDocument(schema);
      const $$ = (type, id) => {
        if (!id) id = type;
        return doc.create({type, id})
      };

      let articleRecord = doc.create({
        type: 'article-record',
        id: 'article-record',
        permission: $$('permission', 'article-permission').id
      });

      $$('article').append(
        $$('metadata').append(
          articleRecord,
          $$('authors'),
          $$('editors'),
          $$('groups'),
          $$('organisations'),
          $$('awards'),
          $$('keywords'),
          $$('subjects')
        ),
        $$('content').append(
          $$('front').append(
            $$('title'),
            $$('abstract')
          ),
          $$('body'),
          $$('back').append(
            $$('references'),
            $$('footnotes')
          )
        )
      );
      return doc
    }
  }

  class TableNode extends substance.XMLElementNode {
    constructor (...args) {
      super(...args);

      this._matrix = null;
      this._rowIds = new Set();
      this._cellIds = new Set();
      this._sha = Math.random();

      this._enableCaching();
    }

    get (cellId) {
      if (!this._cellIds.has(cellId)) throw new Error('Cell is not part of this table.')
      return this.document.get(cellId)
    }

    getCellMatrix () {
      if (!this._matrix) {
        let spanningCells = [];
        let matrix = this.getChildren().map((row, rowIdx) => {
          let cells = row.getChildren();
          for (let colIdx = 0; colIdx < cells.length; colIdx++) {
            let c = cells[colIdx];
            c.rowIdx = rowIdx;
            c.colIdx = colIdx;
            c.shadowed = false;
            if (c.colspan || c.rowspan) {
              spanningCells.push(c);
            }
          }
          return cells
        });
        spanningCells.forEach(c => {
          _shadowSpanned(matrix, c.rowIdx, c.colIdx, c.rowspan, c.colspan, c);
        });
        this._matrix = matrix;
      }
      return this._matrix
    }

    getRowCount () {
      return this.getChildCount()
    }

    getColumnCount () {
      if (this._childNodes.length === 0) return 0
      let firstRow = this.getChildAt(0);
      return firstRow.getChildCount()
    }

    getDimensions () {
      return [this.getRowCount(), this.getColumnCount()]
    }

    getCell (rowIdx, colIdx) {
      const matrix = this.getCellMatrix();
      let row = matrix[rowIdx];
      if (row) {
        return row[colIdx]
      }
    }

    _enableCaching () {
      // this hook is used to invalidate cached positions
      if (this.document) {
        this._rowIds = new Set(this._childNodes);
        let cellIds = this.getChildren().reduce((arr, row) => {
          return arr.concat(row._childNodes)
        }, []);
        this._cellIds = new Set(cellIds);
        this.document.data.on('operation:applied', this._onOperationApplied, this);
      }
    }

    _onOperationApplied (op) {
      if (!op.path) return
      let nodeId = op.path[0];
      let hasChanged = false;
      if (nodeId === this.id && op.path[1] === '_childNodes') {
        let update = op.getValueOp();
        if (update.isDelete()) {
          this._rowIds.delete(update.getValue());
        } else if (update.isInsert()) {
          let rowId = update.getValue();
          let row = this.document.get(rowId);
          row._childNodes.forEach(cellId => {
            this._cellIds.add(cellId);
          });
          this._rowIds.add(rowId);
        }
        hasChanged = true;
      } else if (this._rowIds.has(nodeId) && op.path[1] === '_childNodes') {
        let update = op.getValueOp();
        if (update.isDelete()) {
          this._cellIds.delete(update.getValue());
        } else if (update.isInsert()) {
          this._cellIds.add(update.getValue());
        }
        hasChanged = true;
      } else if (this._cellIds.has(nodeId) && (op.path[2] === 'rowspan' || op.path[2] === 'colspan')) {
        hasChanged = true;
      }
      if (hasChanged) {
        this._matrix = null;
        // HACK: using a quasi-sha to indicate that this table has been
        // changed structurally
        this._sha = Math.random();
      }
    }

    _hasShaChanged (sha) {
      return (this._sha !== sha)
    }

    _getSha () {
      return this._sha
    }
  }

  TableNode.schema = {
    type: 'table',
    _childNodes: CHILDREN('table-row')
  };

  function _shadowSpanned (matrix, row, col, rowspan, colspan, masterCell) {
    if (!rowspan && !colspan) return
    for (let i = row; i <= row + rowspan - 1; i++) {
      for (let j = col; j <= col + colspan - 1; j++) {
        if (i === row && j === col) continue
        let cell = matrix[i][j];
        cell.shadowed = true;
        cell.masterCell = masterCell;
      }
    }
  }

  class TableCellNode extends substance.XMLTextElement {
    constructor (...args) {
      super(...args);

      this.rowIdx = -1;
      this.colIdx = -1;
    }

    get rowspan () {
      return _parseSpan(this.getAttribute('rowspan'))
    }

    get colspan () {
      return _parseSpan(this.getAttribute('colspan'))
    }

    isShadowed () {
      return this.shadowed
    }

    getMasterCell () {
      return this.masterCell
    }
  }

  TableCellNode.type = 'table-cell';

  function _parseSpan (str) {
    let span = parseInt(str, 10);
    if (isFinite(span)) {
      return Math.max(span, 1)
    } else {
      return 1
    }
  }

  class XMLListNode extends substance.ListMixin(substance.XMLElementNode) {
    createListItem (text) {
      let item = this.getDocument().create({ type: 'list-item', content: text });
      item.attr('level', 1);
      return item
    }

    getItemsPath () {
      return [this.id, '_childNodes']
    }

    get items () { return this._childNodes }

    getItems () {
      return this.getChildren()
    }

    getItemAt (idx) {
      return this.getChildAt(idx)
    }

    getItemPosition (item) {
      return this.getChildPosition(item)
    }

    insertItemAt (pos, item) {
      return this.insertAt(pos, item)
    }

    appendItem (item) {
      return this.appendChild(item)
    }

    removeItemAt (pos) {
      this.removeAt(pos);
    }

    getLength () {
      return this.getChildCount()
    }

    getListTypeString () {
      return this.attr('list-type')
    }

    setListTypeString (listTypeStr) {
      this.attr('list-type', listTypeStr);
    }
  }

  XMLListNode.type = 'list';

  class XMLListItemNode extends substance.XMLTextElement {
    get level () {
      return this.getLevel()
    }

    getLevel () {
      return parseInt(this.attributes.level, 10)
    }

    setLevel (newLevel) {
      if (this.getLevel() !== newLevel) {
        this.setAttribute('level', newLevel);
      }
    }

    static isListItem () {
      return true
    }
  }

  XMLListItemNode.type = 'list-item';

  const RICH_TEXT_ANNOS = ['bold', 'italic', 'sup', 'sub'];

  class Article extends substance.XMLElementNode {}
  Article.schema = {
    type: 'article',
    _childNodes: CHILDREN('metadata', 'content')
  };

  class ArticleRecord extends substance.DocumentNode {}
  ArticleRecord.schema = {
    type: 'article-record',
    volume: STRING,
    issue: STRING,
    fpage: STRING,
    lpage: STRING,
    pageRange: STRING,
    elocationId: STRING,
    acceptedDate: STRING,
    publishedDate: STRING,
    receivedDate: STRING,
    revReceivedDate: STRING,
    revRequestedDate: STRING,
    permission: CHILD$1('permission')
  };

  class TranslatableTextElement extends substance.XMLTextElement {
    getTranslations () {
      const doc = this.getDocument();
      return this.translations.map(id => doc.get(id)).filter(Boolean)
    }
  }
  TranslatableTextElement.schema = {
    translations: CHILDREN('text-translation')
  };

  class TranslatableContainerElement extends substance.XMLContainerNode {
    getTranslations () {
      const doc = this.getDocument();
      return this.translations.map(id => doc.get(id)).filter(Boolean)
    }
  }
  TranslatableContainerElement.schema = {
    translations: CHILDREN('container-translation')
  };

  class Metadata extends substance.XMLElementNode {}
  Metadata.schema = {
    type: 'metadata',
    _childNodes: CHILDREN(
      'article-record', 'authors', 'editors', 'groups', 'organisations', 'awards', 'keywords', 'subjects'
    )
  };

  class Organisations extends substance.XMLElementNode {}
  Organisations.schema = {
    type: 'organisations',
    _childNodes: CHILDREN(...INTERNAL_BIBR_TYPES)
  };

  class Authors extends substance.XMLElementNode {}
  Authors.schema = {
    type: 'authors',
    _childNodes: CHILDREN('person')
  };

  class Editors extends substance.XMLElementNode {}
  Editors.schema = {
    type: 'editors',
    _childNodes: CHILDREN('person')
  };

  class DispQuote extends substance.XMLContainerNode {}
  DispQuote.schema = {
    type: 'disp-quote',
    attrib: 'text',
    _childNodes: CHILDREN('p')
  };

  class Figure extends substance.DocumentNode {
    getContent () {
      return this.getDocument().get(this.content)
    }
    getCaption () {
      return this.getDocument().get(this.caption)
    }
  }

  Figure.schema = {
    type: 'figure',
    content: CHILD$1('graphic'),
    title: TEXT(...RICH_TEXT_ANNOS),
    label: STRING,
    caption: CHILD$1('caption'),
    permission: CHILD$1('permission')
  };

  class TableFigure extends Figure {}
  TableFigure.schema = {
    type: 'table-figure',
    content: CHILD$1('table')
  };

  class Groups extends substance.XMLElementNode {}
  Groups.schema = {
    type: 'groups',
    _childNodes: CHILDREN('group')
  };

  class Awards extends substance.XMLElementNode {}
  Awards.schema = {
    type: 'awards',
    _childNodes: CHILDREN('award')
  };

  class Keywords extends substance.XMLElementNode {}
  Keywords.schema = {
    type: 'keywords'
  };

  class Subjects extends substance.XMLElementNode {}
  Subjects.schema = {
    type: 'subjects'
  };

  // TODO: as this node has a fixed layout, we might want to use a classical DocumentNode
  // But this needs support for CSS select
  class Content extends substance.XMLElementNode {}
  Content.schema = {
    type: 'content',
    _childNodes: CHILDREN('front', 'body', 'back')
  };

  class Front extends substance.XMLElementNode {}
  Front.schema = {
    type: 'front',
    _childNodes: CHILDREN('title', 'abstract')
  };

  class Back extends substance.XMLElementNode {}
  Back.schema = {
    type: 'back',
    _childNodes: CHILDREN('references', 'footnotes')
  };

  class Title extends TranslatableTextElement {}
  Title.schema = {
    type: 'title',
    content: TEXT(...RICH_TEXT_ANNOS)
  };

  class Abstract extends TranslatableContainerElement {}
  Abstract.type = 'abstract';

  // In contrast to TextureJATS, our internal <body> does not have <sec> but <heading> instead
  let TextureBody = TextureArticle.getNodeClass('body', 'strict');
  const bodyTargetTypes = substance.without(TextureBody.schema.getProperty('_childNodes').targetTypes, 'sec').concat(['heading']);

  class Body extends substance.XMLContainerNode {}
  Body.schema = {
    type: 'body',
    _childNodes: CHILDREN(...bodyTargetTypes)
  };

  class Heading extends substance.XMLTextElement {
    getLevel () {
      return Math.max(parseInt(this.getAttribute('level') || '1', 10), 1)
    }
    setLevel (level) {
      level = Math.max(1, level);
      this.setAttribute('level', String(level));
    }

    get level () {
      return this.getLevel()
    }
    set level (level) {
      this.setLevel(level);
    }
  }
  Heading.type = 'heading';

  class References extends substance.XMLElementNode {}
  References.schema = {
    type: 'references',
    _childNodes: CHILDREN(...INTERNAL_BIBR_TYPES)
  };

  class Footnotes extends substance.XMLElementNode {}
  Footnotes.schema = {
    type: 'footnotes',
    _childNodes: CHILDREN('fn')
  };

  // TODO: move all of this into InternalArticleSchema

  class BibliographicEntry extends substance.DocumentNode {}
  BibliographicEntry.schema = {
    type: 'bibr'
  };

  /*
    <element-citation publication-type="book">
      <publisher-loc>New York</publisher-loc>
      <publisher-name>Oxford University Press</publisher-name>
      <year>2006</year>
      <pub-id pub-id-type="isbn">978-0195301069</pub-id>
      <pub-id pub-id-type="doi">10.1093/acprof:oso/9780195301069.001.0001</pub-id>
      <person-group person-group-type="author">
        <name>
          <surname>Buzsaki</surname>
          <given-names>G</given-names>
        </name>
      </person-group>
      <source>Rhythms of the Brain</source>
    </element-citation>
  */
  class BookRef extends BibliographicEntry {}
  BookRef.schema = {
    type: 'book-ref',
    authors: CHILDREN('ref-contrib'), // <person-group person-group-type="author">
    editors: CHILDREN('ref-contrib'), // <person-group person-group-type="editor">
    translators: CHILDREN('ref-contrib'), // <person-group person-group-type="translator">
    title: TEXT(...RICH_TEXT_ANNOS), // <source>
    volume: STRING, // <volume>
    edition: STRING, // <editor>
    publisherLoc: STRING, // <publisher-loc>
    publisherName: STRING, // <publisher-name>
    year: STRING, // <year>
    month: STRING, // <month>
    day: STRING, // <day>
    pageCount: STRING, // <page-count>
    series: STRING, // <series>
    doi: STRING, // <pub-id pub-id-type="doi">
    isbn: STRING, // <pub-id pub-id-type="isbn">
    pmid: STRING // <pub-id pub-id-type="pmid">
  };

  /*
    <element-citation publication-type="chapter">
      <day>22</day>
      <fpage>180</fpage>
      <lpage>207</lpage>
      <month>08</month>
      <publisher-loc>Sunderland, MA</publisher-loc>
      <publisher-name>Sinauer Associates</publisher-name>
      <year>1989</year>
      <pub-id pub-id-type="isbn">978-0878936588</pub-id>
      <person-group person-group-type="author">
        <name>
          <surname>Coyne</surname>
          <given-names>JA</given-names>
        </name>
      </person-group>
      <person-group person-group-type="editor">
        <name>
          <surname>Otte</surname>
          <given-names>D</given-names>
        </name>
      </person-group>
      <source>Speciation and its consequences</source>
      <chapter-title>Two rules of speciation</chapter-title>
    </element-citation>
  */
  class ChapterRef extends BibliographicEntry {}
  ChapterRef.schema = {
    type: 'chapter-ref',
    title: TEXT(...RICH_TEXT_ANNOS), // <chapter-title>
    containerTitle: STRING, // <source>
    volume: STRING, // <volume>
    authors: CHILDREN('ref-contrib'), // <person-group person-group-type="author">
    editors: CHILDREN('ref-contrib'), // <person-group person-group-type="editor">
    translators: CHILDREN('ref-contrib'), // <person-group person-group-type="translator">
    edition: STRING, // <edition>
    publisherLoc: STRING, // <publisher-loc>
    publisherName: STRING, // <publisher-name>
    year: STRING, // <year>
    month: STRING, // <month>
    day: STRING, // <day>
    fpage: STRING, // <fpage>
    lpage: STRING, // <lpage>
    pageRange: STRING, // <page-range>
    elocationId: STRING, // <elocation-id>
    series: STRING, // <series>
    doi: STRING, // <pub-id pub-id-type="doi">
    isbn: STRING, // <pub-id pub-id-type="isbn">
    pmid: STRING // <pub-id pub-id-type="pmid">
  };

  /*
    <element-citation publication-type="confproc">
      <conf-name>Proceedings of the 17th Annual Meeting of International Society for Magnetic Resonance in Medicine</conf-name>
      <conf-loc>Hawaii, United States</conf-loc>
      <year>2009</year>
      <person-group person-group-type="author">
        <name>
          <surname>Leemans</surname>
          <given-names>A</given-names>
        </name>
      </person-group>
      <article-title>ExploreDTI: a graphical toolbox for processing, analyzing, and visualizing diffusion MR data</article-title>
    </element-citation>
  */
  class ConferencePaperRef extends BibliographicEntry {}
  ConferencePaperRef.schema = {
    type: 'conference-paper-ref', // publication-type="confproc"
    title: TEXT(...RICH_TEXT_ANNOS), // <article-title>
    authors: CHILDREN('ref-contrib'), // <person-group person-group-type="author">
    confName: STRING, // <conf-name>
    confLoc: STRING, // <conf-loc>
    containerTitle: STRING, // <source>
    year: STRING, // <year>
    month: STRING, // <month>
    day: STRING, // <day>
    fpage: STRING, // <fpage>
    lpage: STRING, // <lpage>
    pageRange: STRING, // <page-range>
    elocationId: STRING, // <elocation-id>
    doi: STRING // <pub-id pub-id-type="doi">
  };

  /*
    <element-citation publication-type="data">
      <day>01</day>
      <month>06</month>
      <year>2016</year>
      <pub-id pub-id-type="accession">GSE69545</pub-id>
      <person-group person-group-type="author">
        <name>
          <surname>Allison</surname>
          <given-names>KA</given-names>
        </name>
      </person-group>
      <source>NCBI Gene Expression Omnibus</source>
      <data-title>Affinity and Dose of TCR Engagement Yield Proportional Enhancer and Gene Activity in CD4+ T Cells</data-title>
    </element-citation>
  */
  class DataPublicationRef extends BibliographicEntry {}
  DataPublicationRef.schema = {
    type: 'data-publication-ref', // publication-type="data"
    title: TEXT(...RICH_TEXT_ANNOS), // <data-title>
    authors: CHILDREN('ref-contrib'), // <person-group person-group-type="author">
    containerTitle: STRING, // <source>
    year: STRING, // <year>
    month: STRING, // <month>
    day: STRING, // <day>
    accessionId: STRING, // <pub-id pub-id-type="accession">
    arkId: STRING, // // <pub-id pub-id-type="ark">
    archiveId: STRING, // <pub-id pub-id-type="archive">
    doi: STRING // <pub-id pub-id-type="doi">
  };

  /*
    <element-citation publication-type="journal">
      <day>06</day>
      <fpage>1141</fpage>
      <lpage>1144</lpage>
      <month>11</month>
      <volume>282</volume>
      <year>1998</year>
      <pub-id pub-id-type="doi">10.1126/science.282.5391.1141</pub-id>
      <pub-id pub-id-type="pmid">9804555</pub-id>
      <person-group person-group-type="author">
        <name>
          <surname>Baukrowitz</surname>
          <given-names>T</given-names>
        </name>
      </person-group>
      <source>Science</source>
      <article-title>PIP<sub id="sub-1">2</sub> and PIP as determinants ...</article-title>
    </element-citation>
  */
  class JournalArticleRef extends BibliographicEntry {}
  JournalArticleRef.schema = {
    type: 'journal-article-ref', // publication-type="journal"
    title: TEXT(...RICH_TEXT_ANNOS), // <article-title>
    authors: CHILDREN('ref-contrib'), // <person-group person-group-type="author">
    editors: CHILDREN('ref-contrib'), // <person-group person-group-type="editor">
    containerTitle: STRING, // <source>: label this 'Journal' or 'Publication' as in Zotero?
    volume: STRING, // <volume>
    issue: STRING, // <issue>
    year: STRING, // <year>
    month: STRING, // <month>
    day: STRING, // <day>
    fpage: STRING, // <fpage>
    lpage: STRING, // <lpage>
    pageRange: STRING, // <page-range>
    elocationId: STRING, // <elocation-id>
    doi: STRING, // <pub-id pub-id-type="doi">
    pmid: STRING // <pub-id pub-id-type="pmid">
  };

  /*
    <element-citation publication-type="article">
      <year>2016</year>
      <pub-id pub-id-type="doi">10.1101/029983</pub-id>
      <person-group person-group-type="author">
        <name>
          <surname>Bloss</surname>
          <given-names>CS</given-names>
        </name>
      </person-group>
      <source>bioRxiv</source>
      <article-title>A prospective randomized trial examining...</article-title>
    </element-citation>
  */
  class ArticleRef extends BibliographicEntry {}
  ArticleRef.schema = {
    type: 'article-ref', // publication-type="article"
    title: STRING, // <article-title>
    authors: CHILDREN('ref-contrib'), // <person-group person-group-type="author">
    editors: CHILDREN('ref-contrib'), // <person-group person-group-type="editor">
    containerTitle: STRING, // <source>
    year: STRING, // <year>
    month: STRING, // <month>
    day: STRING, // <day>
    elocationId: STRING, // <elocation-id>
    doi: STRING, // <pub-id pub-id-type="doi">
    pmid: STRING // <pub-id pub-id-type="pmid">
  };

  /*
    <element-citation publication-type="magazine">
      <person-group person-group-type="author">
        <name>
          <surname>Craig</surname>
          <given-names>DJ</given-names>
        </name>
      </person-group>
      <year>2017</year>
      <article-title>A voice for women and girls</article-title>
      <source>Columbia Magazine</source>
      <volume>Fall 2017</volume>
      <fpage>36</fpage>
      <lpage>38</lpage>
    </element-citation>
  */
  class MagazineArticleRef extends BibliographicEntry {}
  MagazineArticleRef.schema = {
    type: 'magazine-article-ref',
    title: TEXT(...RICH_TEXT_ANNOS), // <article-title>
    authors: CHILDREN('ref-contrib'), // <person-group person-group-type="author">
    containerTitle: STRING, // <source>
    year: STRING, // <year>
    month: STRING, // <month>
    day: STRING, // <month>
    volume: STRING, // <volume>
    fpage: STRING, // <fpage>
    lpage: STRING, // <lpage>
    pageRange: STRING, // <page-range>
    doi: STRING // <pub-id pub-id-type="doi">
  };

  /*
    <element-citation publication-type="newspaper">
      <day>27</day>
      <edition>International Edition</edition>
      <fpage>21</fpage>
      <month>4</month>
      <part-title>Film</part-title>
      <year>2018</year>
      <person-group person-group-type="author">
        <name>
          <surname>Rose</surname>
          <given-names>Steve</given-names>
        </name>
      </person-group>
      <source>The Guardian</source>
      <article-title>What if superheroes arent really the good guys?</article-title>
    </element-citation>
  */
  class NewspaperArticleRef extends BibliographicEntry {}
  NewspaperArticleRef.schema = {
    type: 'newspaper-article-ref', // publication-type="newspaper"
    title: TEXT(...RICH_TEXT_ANNOS), // <article-title>
    authors: CHILDREN('ref-contrib'), // <person-group person-group-type="author">
    containerTitle: STRING, // <source>
    year: STRING, // <year>
    month: STRING, // <month>
    day: STRING, // <day>
    volume: STRING, // <volume>
    fpage: STRING, // <fpage>
    lpage: STRING, // <lpage>
    pageRange: STRING, // <page-range>
    doi: STRING, // <pub-id pub-id-type="doi">
    edition: STRING, // <edition>
    partTitle: STRING // <part-title>
  };

  /*
    <element-citation publication-type="patent">
      <day>17</day>
      <month>03</month>
      <patent country="United States">US20100941530</patent>
      <year>2011</year>
      <person-group person-group-type="inventor">
        <name>
          <surname>Patterson</surname>
          <given-names>JB</given-names>
        </name>
      </person-group>
      <source>United States patent</source>
      <article-title>IRE-1alpha inhibitors</article-title>
    </element-citation>
  */
  class PatentRef extends BibliographicEntry {}
  PatentRef.schema = {
    type: 'patent-ref', // publication-type="patent"
    inventors: CHILDREN('ref-contrib'), // <person-group person-group-type="inventor">
    assignee: STRING, // <collab collab-type="assignee"><named-content>
    title: TEXT(...RICH_TEXT_ANNOS), // <article-title>
    containerTitle: STRING, // <source>
    year: STRING, // <year>
    month: STRING, // <month>
    day: STRING, // <day>
    patentNumber: STRING, // <patent>US20100941530</patent>
    patentCountry: STRING, // <patent country="United States"></patent>
    doi: STRING // <pub-id pub-id-type="doi">
  };

  class Permission extends substance.DocumentNode {
    isEmpty () {
      return !(this.copyrightStatement || this.copyrightYear || this.copyrightHolder || this.license || this.licenseText)
    }
  }

  Permission.schema = {
    type: 'permission',
    copyrightStatement: STRING,
    copyrightYear: STRING,
    copyrightHolder: STRING,
    // URL to license description  used as a unique license identifier
    // FIXME: bad naming. Use url, or licenseUrl?
    license: STRING,
    licenseText: TEXT(...RICH_TEXT_ANNOS)
  };

  /*
    <element-citation publication-type="report">
      <month>06</month>
      <publisher-loc>Monrovia, Liberia</publisher-loc>
      <publisher-name>NMCP, LISGIS, and ICF International</publisher-name>
      <year>2012</year>
      <person-group person-group-type="author">
        <collab>
          <named-content content-type="name">National Malaria Control Program - Ministry of Health and Social Welfare</named-content>
        </collab>
      </person-group>
      <person-group person-group-type="sponsor">
        <collab>
          <named-content content-type="name">United States Agency for International Development</named-content>
        </collab>
      </person-group>
      <source>Liberia Malaria Indicator Survey 2011</source>
    </element-citation>
  */
  class ReportRef extends BibliographicEntry {
    getGuid () {
      return this.isbn
    }
  }
  ReportRef.schema = {
    type: 'report-ref', // publication-type="report"
    authors: CHILDREN('ref-contrib'), // <person-group person-group-type="author">
    sponsors: CHILDREN('ref-contrib'), // <person-group person-group-type="sponsor">
    title: TEXT(...RICH_TEXT_ANNOS), // <source>
    year: STRING, // <year>
    month: STRING, // <month>
    day: STRING, // <day>
    publisherName: STRING, // <publisher-name>
    publisherLoc: STRING, // <publisher-loc>
    series: STRING, // <series>
    isbn: STRING, // <pub-id pub-id-type="isbn">
    doi: STRING // <pub-id pub-id-type="doi">
  };

  /*
    <element-citation publication-type="software">
      <day>19</day>
      <month>3</month>
      <publisher-name>Zenodo</publisher-name>
      <version>2.0.1</version>
      <year>2018</year>
      <pub-id pub-id-type="doi">10.5281/zenodo.1203712</pub-id>
      <person-group person-group-type="author">
        <name>
          <surname>Willner</surname>
          <given-names>Sven</given-names>
        </name>
        <name>
          <surname>Gieseke</surname>
          <given-names>Robert</given-names>
        </name>
      </person-group>
      <source>pyhector</source>
    </element-citation>
  */
  class SoftwareRef extends BibliographicEntry {}
  SoftwareRef.schema = {
    type: 'software-ref', // publication-type="software"
    title: TEXT(...RICH_TEXT_ANNOS), // <source>
    authors: CHILDREN('ref-contrib'), // <person-group person-group-type="author">
    version: STRING, // <version>
    publisherLoc: STRING, // <publisher-loc>
    publisherName: STRING, // <publisher-name>
    year: STRING, // <year>
    month: STRING, // <month>
    day: STRING, // <day>
    doi: STRING // <pub-id pub-id-type="doi">
  };

  /*
    <element-citation publication-type="thesis">
      <publisher-loc>Nijmegen, The Netherlands</publisher-loc>
      <publisher-name>Radboud University Nijmegen Medical Centre</publisher-name>
      <year>2006</year>
      <person-group person-group-type="author">
        <name>
          <surname>Schneider</surname>
          <given-names>P</given-names>
        </name>
      </person-group>
      <article-title>PhD thesis: Submicroscopic <italic id="italic-2">Plasmodium falciparum</italic> gametocytaemia and the contribution to malaria transmission</article-title>
    </element-citation>
  */
  class ThesisRef extends BibliographicEntry {}
  ThesisRef.schema = {
    type: 'thesis-ref', // publication-type="thesis"
    title: TEXT(...RICH_TEXT_ANNOS), // <article-title>
    authors: CHILDREN('ref-contrib'), // <person-group person-group-type="author">
    year: STRING, // <year>
    month: STRING, // <month>
    day: STRING, // <day>
    publisherLoc: STRING, // <publisher-loc>
    publisherName: STRING, // <publisher-name>
    doi: STRING // <pub-id pub-id-type="doi">
  };

  /*
    <element-citation publication-type="webpage">
      <day>10</day>
      <month>05</month>
      <uri>http://www.michaeleisen.org/blog/?p=1894</uri>
      <date-in-citation iso-8601-date="1995-09-10">1995-09-10</date-in-citation>
      <year>2016</year>
      <person-group person-group-type="author">
        <name>
          <surname>Eisen</surname>
          <given-names>M</given-names>
        </name>
      </person-group>
      <source>it is NOT junk</source>
      <article-title>The Imprinter of All Maladies</article-title>
    </element-citation>
  */
  class WebpageRef extends BibliographicEntry {}
  WebpageRef.schema = {
    type: 'webpage-ref', // publication-type="webpage"
    title: TEXT(...RICH_TEXT_ANNOS), // <article-title>
    // E.g. website name, where the page appeared
    containerTitle: STRING, // <source>
    authors: CHILDREN('ref-contrib'), // <person-group person-group-type="author">
    year: STRING, // <year>
    month: STRING, // <month>
    day: STRING, // <day>
    accessedDate: STRING, // <date-in-citation iso-8601-date="1995-09-10">
    uri: STRING // <uri>
  };

  class Person extends substance.DocumentNode {
    getBio () {
      return this.getDocument().get(this.bio)
    }
  }

  Person.schema = {
    type: 'person',
    surname: STRING,
    givenNames: STRING,
    alias: STRING,
    prefix: STRING,
    suffix: STRING,
    email: STRING,
    orcid: STRING,
    group: ONE$1('group'),
    affiliations: MANY$1('organisation'),
    awards: MANY$1('award'),
    bio: CHILD$1('bio'),
    equalContrib: BOOLEAN,
    corresp: BOOLEAN,
    deceased: BOOLEAN
  };

  /* Holds data for persons and instituions/groups in references */
  class RefContrib extends substance.DocumentNode {}
  RefContrib.schema = {
    type: 'ref-contrib',
    name: STRING, // either family name or institution name
    givenNames: STRING
  };

  class Award extends substance.DocumentNode {}
  Award.schema = {
    type: 'award',
    institution: STRING,
    fundRefId: STRING,
    awardId: STRING
  };

  class Group extends substance.DocumentNode {}
  Group.schema = {
    type: 'group',
    name: STRING,
    email: STRING,
    affiliations: MANY$1('organisation'),
    awards: MANY$1('award'),
    equalContrib: BOOLEAN,
    corresp: BOOLEAN
  };

  class Keyword extends substance.DocumentNode {}
  Keyword.schema = {
    type: 'keyword',
    name: STRING,
    category: STRING,
    language: STRING
  };

  class Organisation extends substance.DocumentNode {}
  Organisation.schema = {
    type: 'organisation',
    name: STRING,
    division1: STRING,
    division2: STRING,
    division3: STRING,
    // Consider switching to address-line1,2,3
    street: STRING,
    addressComplements: STRING,
    city: STRING,
    state: STRING,
    postalCode: STRING,
    country: STRING,
    phone: STRING,
    fax: STRING,
    email: STRING,
    uri: STRING
  };

  class Subject extends substance.DocumentNode {}
  Subject.schema = {
    type: 'subject',
    name: STRING,
    category: STRING,
    language: STRING
  };

  class ContainerTranslation extends substance.XMLContainerNode {}
  ContainerTranslation.schema = {
    type: 'container-translation',
    language: STRING
  };

  class TextTranslation extends substance.XMLTextElement {}
  TextTranslation.schema = {
    type: 'text-translation',
    content: TEXT(...RICH_TEXT_ANNOS),
    language: STRING
  };

  class TableRow extends substance.XMLElementNode {}
  TableRow.schema = {
    type: 'table-row',
    _childNodes: CHILDREN('table-cell')
  };

  class UnsupportedNode extends substance.DocumentNode {}
  UnsupportedNode.schema = {
    type: 'unsupported-node',
    data: 'string'
  };

  class UnsupportedInlineNode extends substance.InlineNode {}
  UnsupportedInlineNode.schema = {
    type: 'unsupported-inline-node',
    data: 'string'
  };

  const InternalArticleSchema = new substance.DocumentSchema({
    name: 'TextureInternalArticle',
    version: '0.1.0',
    DocumentClass: InternalArticleDocument,
    // HACK: still necessary
    // Instead we should find a general way
    defaultTextType: 'p'
  });

  InternalArticleSchema.addNodes([
    Article,
    ArticleRef,
    Body,
    // metadata
    Metadata,
    ArticleRecord,
    Organisations,
    Authors,
    Awards,
    Groups,
    Editors,
    Keywords,
    Subjects,
    // entities used in metadata
    Award,
    Group,
    Person,
    Organisation,
    Keyword,
    Subject,
    // content
    Abstract,
    Article,
    Back,
    Content,
    DispQuote,
    Figure,
    Footnotes,
    Front,
    Heading,
    XMLListNode,
    XMLListItemNode,
    References,
    TableNode,
    TableFigure,
    TableRow,
    TableCellNode,
    Title,
    // bibliography
    BibliographicEntry,
    BookRef,
    ChapterRef,
    ConferencePaperRef,
    DataPublicationRef,
    JournalArticleRef,
    MagazineArticleRef,
    NewspaperArticleRef,
    ReportRef,
    PatentRef,
    Permission,
    SoftwareRef,
    ThesisRef,
    WebpageRef,
    // entity used in bibliography
    RefContrib,
    // translations
    TextTranslation,
    ContainerTranslation,
    // others
    UnsupportedNode,
    UnsupportedInlineNode
  ]);

  // Elements taken from the JATS spec
  // TODO: make sure that we do not need to modify them, e.g. marking them as inline nodes
  InternalArticleSchema.addNodes([
    'bio',
    'caption',
    'code',
    'fn',
    'graphic',
    'label',
    'p',
    'tex-math',
    'bold',
    'italic',
    'monospace',
    'overline',
    'sc',
    'strike',
    'sub',
    'sup',
    'underline',
    // annos and inline-nodes
    'break',
    'ext-link',
    'inline-formula',
    'xref'
  ].map(name => TextureArticle.getNodeClass(name, 'strict')));

  class BodyConverter {
    get type () { return 'body' }

    get tagName () { return 'body' }

    import (el, node, importer) {
      let children = el.getChildren();
      let flattened = [];
      for (let child of children) {
        if (child.tagName === 'sec') {
          flattened = flattened.concat(this._flattenSec(child, 1));
        } else {
          flattened.push(child);
        }
      }
      node._childNodes = flattened.map(el => importer.convertElement(el).id);
    }

    _flattenSec (sec, level) {
      let result = [];

      let h = sec.createElement('heading');
      // Note: mapping the section id
      // TODO: what about other attributes?
      h.attr({
        id: sec.attr('id'),
        level
      });
      // ATTENTION: <sec-meta> is not supported
      if (findChild(sec, 'sec-meta')) {
        console.error('<sec-meta> is not supported by <heading> right now.');
      }
      // mapping sec > label to heading[label]
      // TODO: is this really the way we want to do it?
      let label = findChild(sec, 'label');
      if (label) {
        h.attr('label', label.textContent);
        label.remove();
      }
      // The title is essentially the h
      let title = findChild(sec, 'title');
      if (title) {
        h.append(title.childNodes);
        title.remove();
      }
      result.push(h);

      // process the remaining content recursively
      let children = sec.children;
      let L = children.length;
      for (let i = 0; i < L; i++) {
        const child = children[i];
        if (child.tagName === 'sec') {
          result = result.concat(this._flattenSec(child, level + 1));
        } else {
          result.push(child);
        }
      }

      return result
    }

    export (node, el, exporter) {
      let $$ = el.createElement.bind(el);
      const children = node.getChildren();
      let stack = [{ el }];
      for (let child of children) {
        if (child.type === 'heading') {
          let heading = child;
          let level = heading.getLevel();
          while (stack.length >= level + 1) {
            stack.pop();
          }
          let sec = $$('sec').attr({ id: heading.id });
          let title = $$('title');
          title.innerHTML = exporter.annotatedText(heading.getPath());
          sec.appendChild(title);
          substance.last(stack).el.appendChild(sec);
          stack.push({ el: sec });
        } else {
          substance.last(stack).el.appendChild(
            exporter.convertNode(child)
          );
        }
      }
    }

    static instance () {
      if (!this._instance) {
        this._instance = new BodyConverter();
      }
      return this._instance
    }
  }

  /**
   * A converter for JATS `<disp-quote>`.
   * Our internal model deviates from the original one in that the the attribution is separated from
   * the quote content by using a dedicated text property 'attrib'
   */
  class DispQuoteConverter {
    get type () { return 'disp-quote' }

    get tagName () { return 'disp-quote' }

    import (el, node, importer) {
      let $$ = el.createElement.bind(el.getOwnerDocument());
      let pEls = findAllChildren(el, 'p');
      if (pEls.length === 0) {
        pEls.push($$('p'));
      }
      let attrib = findChild(el, 'attrib');
      if (attrib) {
        node.attrib = importer.annotatedText(attrib, [node.id, 'attrib']);
      }
      node._childNodes = pEls.map(p => {
        return importer.convertElement(p).id
      });
    }

    export (node, el, exporter) {
      let $$ = exporter.$$;
      let children = node.getChildren();
      el.append(
        children.map(child => {
          return exporter.convertNode(child)
        })
      );
      if (node.attrib) {
        el.append(
          $$('attrib').append(
            exporter.annotatedText([node.id, 'attrib'])
          )
        );
      }
    }
  }

  function getLabel (node) {
    let label = node.label;
    if (node && node.state) {
      label = node.state.label || label;
    }
    return label
  }

  function getPos (node) {
    let pos;
    if (node && node.state) {
      pos = node.state.pos;
    }
    if (pos === undefined) {
      pos = Number.MAX_VALUE;
    }
    return pos
  }

  class FigConverter {
    get type () { return 'figure' }

    get tagName () { return 'fig' }

    import (el, node, importer) {
      let $$ = el.createElement.bind(el.getOwnerDocument());
      let labelEl = findChild(el, 'label');
      let contentEl = this._getContent(el);
      let permissionsEl = findChild(el, 'permissions');
      let captionEl = findChild(el, 'caption');
      let doc = importer.getDocument();
      // Preparations
      if (!captionEl) {
        captionEl = $$('caption');
      }
      let titleEl = findChild(captionEl, 'title');
      if (!titleEl) {
        titleEl = $$('title');
      }
      // drop everything than 'p' from caption
      let captionContent = captionEl.children;
      for (let idx = captionContent.length - 1; idx >= 0; idx--) {
        let child = captionContent[idx];
        if (child.tagName !== 'p') {
          captionEl.removeAt(idx);
        }
      }
      // there must be at least one paragraph
      if (!captionEl.find('p')) {
        captionEl.append($$('p'));
      }
      // Conversion
      if (labelEl) {
        node.label = labelEl.text();
      }
      node.title = importer.annotatedText(titleEl, [node.id, 'title']);
      // content is optional
      // TODO: really?
      if (contentEl) {
        node.content = importer.convertElement(contentEl).id;
      }
      node.caption = importer.convertElement(captionEl).id;
      if (permissionsEl) {
        node.permission = importer.convertElement(permissionsEl).id;
      } else {
        node.permission = doc.create({ type: 'permission' }).id;
      }
    }

    _getContent (el) {
      return findChild(el, 'graphic')
    }

    export (node, el, exporter) {
      let $$ = exporter.$$;
      let doc = exporter.getDocument();
      let permission = doc.get(node.permission);
      // ATTENTION: this helper retrieves the label from the state
      let label = getLabel(node);
      if (label) {
        el.append($$('label').text(label));
      }
      // Attention: <title> is part of the <caption>
      if (node.title || node.caption) {
        let caption = node.getCaption();
        let captionEl;
        if (caption) {
          captionEl = exporter.convertNode(caption);
        }
        if (node.title) {
          // Note: this would happen if title is set, but no caption
          if (!captionEl) captionEl = $$('caption');
          captionEl.insertAt(0,
            $$('title').append(
              exporter.annotatedText([node.id, 'title'])
            )
          );
        }
        el.append(captionEl);
      }
      if (node.content) {
        el.append(
          exporter.convertNode(doc.get(node.content))
        );
      }
      if (permission && !permission.isEmpty()) {
        el.append(
          exporter.convertNode(permission)
        );
      }
    }
  }

  class ElementCitationConverter {
    // Note: this will create different types according to the attributes in the JATS element
    get type () { return 'bibr' }

    matchElement (el) {
      return el.is('ref')
    }

    import (el, node, importer) {
      const doc = importer.state.doc;
      let elementCitation = el.find('element-citation');
      if (!elementCitation) {
        throw new Error('<element-citation> is required')
      }
      _importElementCitation(elementCitation, node, doc, importer);
    }

    export (node, el, exporter) {
      el.tagName = 'ref';
      el.append(
        _exportElementCitation(node, exporter)
      );
      return el
    }
  }

  function _importElementCitation (el, node, doc, importer) {
    const type = el.attr('publication-type');
    node.type = JATS_BIBR_TYPES_TO_INTERNAL[type];

    Object.assign(node, {
      assignee: getText(el, 'collab[collab-type=assignee] > named-content'),
      confName: getText(el, 'conf-name'),
      confLoc: getText(el, 'conf-loc'),
      day: getText(el, 'day'),
      edition: getText(el, 'edition'),
      elocationId: getText(el, 'elocation-id'),
      fpage: getText(el, 'fpage'),
      issue: getText(el, 'issue'),
      lpage: getText(el, 'lpage'),
      month: getText(el, 'month'),
      pageCount: getText(el, 'page-count'),
      pageRange: getText(el, 'page-range'),
      partTitle: getText(el, 'part-title'),
      patentCountry: getAttr(el, 'patent', 'country'),
      patentNumber: getText(el, 'patent'),
      publisherLoc: getSeparatedText(el, 'publisher-loc'),
      publisherName: getSeparatedText(el, 'publisher-name'),
      series: getText(el, 'series'),
      uri: getText(el, 'uri'),
      version: getText(el, 'version'),
      volume: getText(el, 'volume'),
      year: getText(el, 'year'),
      accessedDate: getAttr(el, 'date-in-citation', 'iso-8601-date'),
      // identifiers
      accessionId: getText(el, 'pub-id[pub-id-type=accession]'),
      archiveId: getText(el, 'pub-id[pub-id-type=archive]'),
      arkId: getText(el, 'pub-id[pub-id-type=ark]'),
      isbn: getText(el, 'pub-id[pub-id-type=isbn]'),
      doi: getText(el, 'pub-id[pub-id-type=doi]'),
      pmid: getText(el, 'pub-id[pub-id-type=pmid]')
    });

    if (type === 'book' || type === 'report' || type === 'software') {
      node.title = getAnnotatedText(importer, el, 'source', [node.id, 'title']);
    } else {
      node.containerTitle = getText(el, 'source');
      if (type === 'chapter') {
        node.title = getAnnotatedText(importer, el, 'chapter-title', [node.id, 'title']);
      } else if (type === 'data') {
        node.title = getAnnotatedText(importer, el, 'data-title', [node.id, 'title']);
      } else {
        node.title = getAnnotatedText(importer, el, 'article-title', [node.id, 'title']);
      }
    }

    node.authors = _importPersonGroup(el, doc, 'author');
    node.editors = _importPersonGroup(el, doc, 'editor');
    node.inventors = _importPersonGroup(el, doc, 'inventor');
    node.sponsors = _importPersonGroup(el, doc, 'sponsor');
    node.translators = _importPersonGroup(el, doc, 'translator');
  }

  function getAnnotatedText (importer, rootEl, selector, path) {
    let el = rootEl.find(selector);
    if (el) {
      return importer.annotatedText(el, path)
    } else {
      return ''
    }
  }

  function _importPersonGroup (el, doc, type) {
    let groupEl = el.find(`person-group[person-group-type=${type}]`);
    if (groupEl) {
      return groupEl.children.reduce((ids, childEl) => {
        let refContrib = _importRefContrib(doc, childEl);
        if (refContrib) ids.push(refContrib.id);
        return ids
      }, [])
    } else {
      return []
    }
  }

  function _importRefContrib (doc, el) {
    let refContrib = {
      type: 'ref-contrib'
    };
    if (el.tagName === 'name') {
      refContrib.givenNames = getText(el, 'given-names');
      refContrib.name = getText(el, 'surname');
      // TODO: We may want to consider prefix postfix, and mix it into givenNames, or name properties
      // We don't want separate fields because this gets complex/annoying during editing
      // prefix: getText(el, 'prefix'),
      // suffix: getText(el, 'suffix'),
    } else if (el.tagName === 'collab') {
      refContrib.name = getText(el, 'named-content[content-type=name]');
    } else {
      console.warn(`${el.tagName} not supported inside <person-group>`);
      return null
    }
    return doc.create(refContrib)
  }

  function _exportElementCitation (node, exporter) {
    const $$ = exporter.$$;
    const doc = node.getDocument();
    const type = node.type;
    let el = $$('element-citation').attr('publication-type', INTERNAL_BIBR_TYPES_TO_JATS[type]);
    if (node.assignee) {
      el.append(
        $$('collab').attr('collab-type', 'assignee').append(
          $$('named-content').attr({ 'content-type': 'name' }).text(node.assignee)
        )
      );
    }
    el.append(_createTextElement($$, node.confName, 'conf-name'));
    el.append(_createTextElement($$, node.confLoc, 'conf-loc'));
    el.append(_createTextElement($$, node.day, 'day'));
    el.append(_createTextElement($$, node.edition, 'edition'));
    el.append(_createTextElement($$, node.elocationId, 'elocation-id'));
    el.append(_createTextElement($$, node.fpage, 'fpage'));
    el.append(_createTextElement($$, node.issue, 'issue'));
    el.append(_createTextElement($$, node.lpage, 'lpage'));
    el.append(_createTextElement($$, node.month, 'month'));
    el.append(_createTextElement($$, node.pageCount, 'page-count'));
    el.append(_createTextElement($$, node.pageRange, 'page-range'));
    el.append(_createTextElement($$, node.partTitle, 'part-title'));
    el.append(_createTextElement($$, node.patentNumber, 'patent', { 'country': node.patentCountry }));
    el.append(_createMultipleTextElements($$, node.publisherLoc, 'publisher-loc'));
    el.append(_createMultipleTextElements($$, node.publisherName, 'publisher-name'));
    el.append(_createTextElement($$, node.uri, 'uri'));
    el.append(_createTextElement($$, node.accessedDate, 'date-in-citation', {'iso-8601-date': node.accessedDate}));
    el.append(_createTextElement($$, node.version, 'version'));
    el.append(_createTextElement($$, node.volume, 'volume'));
    el.append(_createTextElement($$, node.year, 'year'));
    // identifiers
    el.append(_createTextElement($$, node.accessionId, 'pub-id', {'pub-id-type': 'accession'}));
    el.append(_createTextElement($$, node.arkId, 'pub-id', {'pub-id-type': 'ark'}));
    el.append(_createTextElement($$, node.archiveId, 'pub-id', {'pub-id-type': 'archive'}));
    el.append(_createTextElement($$, node.isbn, 'pub-id', {'pub-id-type': 'isbn'}));
    el.append(_createTextElement($$, node.doi, 'pub-id', {'pub-id-type': 'doi'}));
    el.append(_createTextElement($$, node.pmid, 'pub-id', {'pub-id-type': 'pmid'}));
    // creators
    el.append(_exportPersonGroup($$, doc, node.authors, 'author'));
    el.append(_exportPersonGroup($$, doc, node.editors, 'editor'));
    el.append(_exportPersonGroup($$, doc, node.inventors, 'inventor'));
    el.append(_exportPersonGroup($$, doc, node.sponsors, 'sponsor'));

    if (type === BOOK_REF || type === REPORT_REF || type === SOFTWARE_REF) {
      el.append(_exportAnnotatedText(exporter, [node.id, 'title'], 'source'));
    } else {
      el.append(_createTextElement($$, node.containerTitle, 'source'));
      if (type === CHAPTER_REF) {
        el.append(
          _exportAnnotatedText(exporter, [node.id, 'title'], 'chapter-title')
        );
      } else if (type === DATA_PUBLICATION_REF) {
        el.append(
          _exportAnnotatedText(exporter, [node.id, 'title'], 'data-title')
        );
      } else {
        el.append(
          _exportAnnotatedText(exporter, [node.id, 'title'], 'article-title')
        );
      }
    }
    return el
  }

  function _exportPersonGroup ($$, doc, contribIds, personGroupType) {
    if (contribIds && contribIds.length > 0) {
      let el = $$('person-group').attr('person-group-type', personGroupType);
      contribIds.forEach(id => {
        let refContribNode = doc.get(id);
        el.append(
          _exportRefContrib($$, refContribNode)
        );
      });
      return el
    }
  }

  function _exportRefContrib ($$, refContrib) {
    let el;
    if (refContrib.givenNames) {
      el = $$('name');
      el.append(_createTextElement($$, refContrib.name, 'surname'));
      el.append(_createTextElement($$, refContrib.givenNames, 'given-names'));
    } else if (refContrib.name) {
      el = $$('collab');
      el.append(_createTextElement($$, refContrib.name, 'named-content', { 'content-type': 'name' }));
    } else {
      console.warn('No content found for refContrib node');
    }
    return el
  }

  function _createTextElement ($$, text, tagName, attrs) {
    if (text) {
      return $$(tagName).append(text).attr(attrs)
    }
  }

  function _exportAnnotatedText (exporter, path, tagName, attrs) {
    const $$ = exporter.$$;
    let text = exporter.getDocument().get(path);
    if (text) {
      return $$(tagName).attr(attrs).append(
        exporter.annotatedText(path)
      )
    }
  }

  function _createMultipleTextElements ($$, text, tagName, attrs) {
    if (text) {
      const textItems = text.split(';');
      return textItems.map(ti => {
        return $$(tagName).append(ti.trim()).attr(attrs)
      })
    }
  }

  // TODO: is it possible to assimilate this implementation to '../html/ListConverter'?
  // obviously HTML lists are different w.r.t. to tagNames
  // but very similar to JATS w.r.t. the content
  class ListConverter {
    get type () { return 'list' }

    get tagName () { return 'list' }

    import (el, node, importer) {
      let doc = importer.getDocument();
      let visited = new Set();
      let items = [];
      let config = [];
      this._extractItems(el, config, items, 0, visited);
      // create items
      let itemIds = items.map(item => {
        let { el, level } = item;
        let li = doc.create({
          type: 'list-item',
          id: el.id
        });
        li.attr('level', level);
        let p = el.find('p');
        if (p) {
          li.content = importer.annotatedText(p, li.getPath());
          return li.id
        }
        return false
      }).filter(Boolean);
      // populate list
      node.id = el.id;
      node.attributes = { 'list-type': config.join(',') };
      node._childNodes = itemIds;
    }

    _extractItems (el, config, items, level, visited) {
      if (el.is('list-item')) items.push({ el, level });
      if (el.is('list')) {
        let listType = el.attr('list-type') || 'bullet';
        if (!config[level]) config[level] = listType;
        level++;
        visited.add(el);
      }
      el.getChildren().forEach(c => this._extractItems(c, config, items, level, visited));
    }

    // ATTENTION: this is pretty rudimentary still
    export (node, el, exporter) {
      const $$ = exporter.$$;
      let newList = substance.renderListNode(node, (arg) => {
        if (arg === 'ol') {
          return $$('list').attr('list-type', 'order')
        } else if (arg === 'ul') {
          return $$('list').attr('list-type', 'bullet')
        } else if (arg === 'li') {
          return $$('list-item')
        } else {
          return $$('list-item', {id: arg.id}).append(
            $$('p').setInnerXML(arg.getInnerXML())
          )
        }
      });
      newList.id = node.id;
      return newList
    }
  }

  class PermissionsConverter {
    get type () { return 'permission' }

    get tagName () { return 'permissions' }

    import (el, node, importer) {
      // Extract figure permissions
      let copyrightStatementEl = el.find('copyright-statement');
      if (copyrightStatementEl) {
        node.copyrightStatement = copyrightStatementEl.textContent;
      }
      let copyrightYearEl = el.find('copyright-year');
      if (copyrightYearEl) {
        node.copyrightYear = copyrightYearEl.textContent;
      }
      let copyrightHolderEl = el.find('copyright-holder');
      if (copyrightHolderEl) {
        node.copyrightHolder = copyrightHolderEl.textContent;
      }
      // TODO: it would be more natural and explicit to do el.find('ali:license-rec')
      let licenseRefEl = el.find('license_ref');
      if (licenseRefEl) {
        node.license = licenseRefEl.textContent;
      }
      let licenseP = el.find('license > license-p');
      if (licenseP) {
        node.licenseText = importer.annotatedText(licenseP, [node.id, 'licenseText']);
      }
    }

    export (node, el, exporter) {
      let $$ = exporter.$$;
      if (node.copyrightStatement) {
        el.append($$('copyright-statement').append(node.copyrightStatement));
      }
      if (node.copyrightYear) {
        el.append($$('copyright-year').append(node.copyrightYear));
      }
      if (node.copyrightHolder) {
        el.append($$('copyright-holder').append(node.copyrightHolder));
      }
      if (node.license || node.licenseText) {
        let licenseEl = $$('license');
        if (node.license) {
          licenseEl.append(
            $$('ali:license_ref').append(node.license)
          );
        }
        if (node.licenseText) {
          licenseEl.append(
            $$('license-p').append(
              exporter.annotatedText([node.id, 'licenseText'])
            )
          );
        }
        el.append(licenseEl);
      }
    }
  }

  class TableConverter {
    get tagName () { return 'table' }

    get type () { return 'table' }

    import (el, node, importer) {
      const doc = importer.state.doc;
      const $$ = doc.createElement.bind(doc);
      let rows = el.findAll('tr');
      let newRows = rows.map(tr => {
        return {
          id: tr.id,
          children: []
        }
      });
      for (let i = 0; i < rows.length; i++) {
        let tr = rows[i];
        let newRow = newRows[i];
        let children = tr.getChildren();
        for (let j = 0, k = 0; j < children.length; j++, k++) {
          // skipping spanned cells which is necessary
          // because HTML tables have a sparse representation w.r.t. span
          while (newRow.children[k]) k++;
          let c = children[j];
          let attributes = {};
          if (c.is('th')) attributes.heading = true;
          let rowspan = c.attr('rowspan');
          if (rowspan) {
            rowspan = Math.max(1, parseInt(rowspan, 10));
            if (rowspan > 1) {
              attributes.rowspan = String(rowspan);
            }
          }
          let colspan = c.attr('colspan');
          if (colspan) {
            colspan = Math.max(1, parseInt(colspan, 10));
            if (colspan > 1) {
              attributes.colspan = String(colspan);
            }
          }
          // flag all spanned cells so that we can skip them
          _fillSpanned($$, newRows, i, k, rowspan, colspan);
          let cell = $$('table-cell', { id: c.id });
          cell.attr(attributes);
          cell.content = importer.annotatedText(c, cell.getPath());
          newRows[i].children[k] = cell;
        }
      }
      node._childNodes = newRows.map(data => {
        let row = $$('table-row', { id: data.id }).append(data.children);
        return row.id
      });
    }

    export (node, el, exporter) {
      const $$ = exporter.$$;
      let htmlTable = $$('table').attr('id', node.id);
      let tbody = $$('tbody');
      let rows = node.findAll('table-row');
      let matrix = node.getCellMatrix();
      for (let i = 0; i < rows.length; i++) {
        let row = rows[i];
        let cells = matrix[i];
        let tr = $$('tr').attr('id', row.id);
        for (let j = 0; j < cells.length; j++) {
          let cell = cells[j];
          if (cell.shadowed) continue
          let el = $$(cell.attr('heading') ? 'th' : 'td');
          let attributes = { id: cell.id };
          let rowspan = cell.attr('rowspan');
          if (rowspan) {
            rowspan = Math.max(1, parseInt(rowspan, 10));
            if (rowspan > 1) {
              attributes.rowspan = rowspan;
            }
          }
          let colspan = cell.attr('colspan');
          if (colspan) {
            colspan = Math.max(1, parseInt(colspan, 10));
            if (colspan > 1) {
              attributes.colspan = colspan;
            }
          }
          el.attr(attributes);
          el.setInnerXML(cell.getInnerXML());
          tr.append(el);
        }
        tbody.append(tr);
      }
      htmlTable.append(tbody);
      return htmlTable
    }
  }

  function _fillSpanned ($$, newRows, row, col, rowspan, colspan) {
    if (!rowspan && !colspan) return
    if (!rowspan) rowspan = 1;
    if (!colspan) colspan = 1;
    for (let i = row; i < row + rowspan; i++) {
      for (let j = col; j < col + colspan; j++) {
        if (i === row && j === col) continue
        newRows[i].children[j] = $$('table-cell');
      }
    }
  }

  class TableWrapConverter extends FigConverter {
    get type () { return 'table-figure' }

    get tagName () { return 'table-wrap' }

    _getContent (el) {
      return findChild(el, 'table')
    }
  }

  var UnsupportedNodeConverter = {
    type: 'unsupported-node',
    matchElement (el) {
      return false
    },
    import (el, node) {
      node.data = el.serialize();
    },
    export (node, el) {
      return substance.DefaultDOMElement.parseSnippet(node.data, 'xml')
    }
  }

  var UnsupportedInlineNodeConverter = {
    type: 'unsupported-inline-node',
    matchElement (el) {
      return false
    },
    import (el, node) {
      node.data = el.serialize();
    },
    export (node, el) {
      return substance.DefaultDOMElement.parseSnippet(node.data, 'xml')
    }
  }

  function createJatsImporter (doc) {
    // Note: we are applying a hybrid approach, i.e. we create XML importers for the JATS schema
    // but only for those elements which are supported by our internal article schema.
    let jatsSchema = TextureArticle.xmlSchema;
    let tagNames = jatsSchema.getTagNames().filter(name => Boolean(InternalArticleSchema.getNodeClass(name)));
    let jatsConverters = createXMLConverters(TextureArticle.xmlSchema, tagNames);
    let converters = [
      new BodyConverter(),
      // this is only used for import, because BodyConverter does an on-the-fly DOM transformation
      // before calling element converters. Thus, in the export direction headings are already transformed into <sec> elements
      HeadingImporter,
      new DispQuoteConverter(),
      new FigConverter(),
      new ListConverter(),
      new PermissionsConverter(),
      new TableWrapConverter(),
      new TableConverter(),
      new ElementCitationConverter()
    ].concat(jatsConverters);
    let jatsImporter = new _HybridJATSImporter({
      schema: InternalArticleSchema,
      xmlSchema: jatsSchema,
      idAttribute: 'id',
      converters
    });
    // ATTENTION: this looks hacky, but we know what we are doing (hopefully)
    jatsImporter.state.doc = doc;
    return jatsImporter
  }

  class _HybridJATSImporter extends substance.XMLDocumentImporter {
    _getConverterForElement (el, mode) {
      let converter = super._getConverterForElement(el, mode);
      if (!converter) {
        if (mode === 'inline') {
          return UnsupportedInlineNodeConverter
        } else {
          return UnsupportedNodeConverter
        }
      }
      return converter
    }

    _createNode (nodeData) {
      let doc = this.state.doc;
      let node = doc.get(nodeData.id);
      if (node) {
        throw new Error('Node already exists')
      }
      return doc.create(nodeData)
    }

    nextId (prefix) {
      // ATTENTION: we gonna use '_' as a prefix for automatically created ids
      // TODO: also do this for nodes created via Document
      let doc = this.state.doc;
      let id = this.state.uuid('_' + prefix);
      while (doc.get(id)) {
        id = this.state.uuid('_' + prefix);
      }
      return id
    }
  }

  const HeadingImporter = {
    type: 'heading',
    tagName: 'heading',
    import (el, node, importer) {
      // Note: attributes are converted automatically
      node.content = importer.annotatedText(el, [node.id, 'content']);
    }
  };

  /*
    TextureJATs Reference: (Please keep this up-to-date)
    article:
      (
        front,
        body?,
        back?,
      )
    front:
      (
        journal-meta?,    // not supported yet
        article-meta,     // -> metadata and others
        // TODO: define a strict schema here ( why multiple ones? )
        (def-list|list|ack|bio|fn-group|glossary|notes)*
      )
    article-meta:
      (
        article-id*,      // not supported yet
        article-categories?,  //   -> article-record
        title-group?,     // this is not optional internally, at least it contains the main title
        contrib-group*,   // -> mapped to authors, editors, and contributors
        aff*,             // -> affiliations
        author-notes?,    // not supported yet
        pub-date*,        // -> article-record
        volume?,          // -> article-record
        issue?,           // -> article-record
        isbn?,            // -> article-record
        (((fpage,lpage?)?,page-range?)|elocation-id)?,  // -> article-record
        history?,         // -> article-record
        permissions?,     // -> article-record
        self-uri*,        // not supported yet
        (related-article,related-object)*, // not supported yet
        abstract?,        // -> content.abstract
        trans-abstract*,  // -> translations
        kwd-group*,       // -> keywords
        funding-group*,   // not supported yet
        conference*,      // not supported yet
        counts?,          // not supported yet
        custom-meta-group?  // not supported yet
      )
    back:
      (
        label?,   // not supported
        title*, // not supported
        (ack|app-group|bio|fn-group|glossary|ref-list|notes|sec)* // not supported
      )

    TODO:
      Allow only one place for '<ack>', '<bio>', '<fn-group>', '<glossary>', '<notes>'
  */

  function jats2internal (jats, options) {
    let doc = InternalArticleDocument.createEmptyArticle(InternalArticleSchema);
    // this is used to for parts of the DOM where we use JATS in the internal model
    let jatsImporter = createJatsImporter(doc, options);

    // metadata
    _populateOrganisations(doc, jats);
    _populateAuthors(doc, jats, jatsImporter);
    _populateEditors(doc, jats, jatsImporter);
    _populateAwards(doc, jats);
    _populateArticleRecord(doc, jats, jatsImporter);
    _populateKeywords(doc, jats);
    _populateSubjects(doc, jats);

    // content
    _populateTitle(doc, jats, jatsImporter);
    _populateAbstract(doc, jats, jatsImporter);
    _populateBody(doc, jats, jatsImporter);
    _populateFootnotes(doc, jats, jatsImporter);
    _populateReferences(doc, jats, jatsImporter);

    return doc
  }

  function _populateOrganisations (doc, jats) {
    const organisations = doc.get('organisations');
    const affEls = jats.findAll('article > front > article-meta > aff');
    affEls.forEach(el => {
      let org = {
        id: el.id,
        type: 'organisation',
        name: getText(el, 'institution[content-type=orgname]'),
        division1: getText(el, 'institution[content-type=orgdiv1]'),
        division2: getText(el, 'institution[content-type=orgdiv2]'),
        division3: getText(el, 'institution[content-type=orgdiv3]'),
        street: getText(el, 'addr-line[content-type=street-address]'),
        addressComplements: getText(el, 'addr-line[content-type=complements]'),
        city: getText(el, 'city'),
        state: getText(el, 'state'),
        postalCode: getText(el, 'postal-code'),
        country: getText(el, 'country'),
        phone: getText(el, 'phone'),
        fax: getText(el, 'fax'),
        email: getText(el, 'email'),
        uri: getText(el, 'uri[content-type=link]')
      };
      organisations.append(doc.create(org));
    });
  }

  function _populateAuthors (doc, jats, importer) {
    let authors = doc.get('authors');
    let authorEls = jats.findAll(`contrib-group[content-type=author] > contrib`);
    _populateContribs(doc, jats, importer, authors, authorEls);
  }

  function _populateEditors (doc, jats, importer) {
    let editors = doc.get('editors');
    let editorEls = jats.findAll(`contrib-group[content-type=editor] > contrib`);
    _populateContribs(doc, jats, importer, editors, editorEls);
  }

  function _populateContribs (doc, jats, importer, contribs, contribEls, groupId) {
    for (let contribEl of contribEls) {
      if (contribEl.attr('contrib-type') === 'group') {
        // ATTENTION: groups are defined 'inplace'
        // the members of the group are appended to the list of persons
        let groups = doc.get('groups');
        let group = {
          id: contribEl.id,
          type: 'group',
          name: getText(contribEl, 'named-content[content-type=name]'),
          email: getText(contribEl, 'email'),
          affiliations: _getAffiliationIds(contribEl, true),
          equalContrib: contribEl.getAttribute('equal-contrib') === 'yes',
          corresp: contribEl.getAttribute('corresp') === 'yes',
          awards: _getAwardIds(contribEl)
        };
        groups.append(doc.create(group));

        let memberEls = contribEl.findAll('contrib');
        _populateContribs(doc, jats, importer, contribs, memberEls, group.id);
      } else {
        contribs.append(
          doc.create({
            type: 'person',
            givenNames: getText(contribEl, 'given-names'),
            surname: getText(contribEl, 'surname'),
            email: getText(contribEl, 'email'),
            alias: getText(contribEl, 'string-name[content-type=alias]'),
            prefix: getText(contribEl, 'prefix'),
            suffix: getText(contribEl, 'suffix'),
            affiliations: _getAffiliationIds(contribEl),
            awards: _getAwardIds(contribEl),
            bio: _getBio(contribEl, importer),
            equalContrib: contribEl.getAttribute('equal-contrib') === 'yes',
            corresp: contribEl.getAttribute('corresp') === 'yes',
            deceased: contribEl.getAttribute('deceased') === 'yes',
            group: groupId
          })
        );
      }
    }
  }

  function _getBio (el, importer) {
    let $$ = el.createElement.bind(el.getOwnerDocument());
    let bioEl = findChild(el, 'bio');

    // If there is no bio element we should provide it
    if (!bioEl) {
      bioEl = $$('bio');
    }

    // drop everything than 'p' from bio
    let bioContent = bioEl.children;
    for (let idx = bioContent.length - 1; idx >= 0; idx--) {
      let child = bioContent[idx];
      if (child.tagName !== 'p') {
        bioEl.removeAt(idx);
      }
    }
    // there must be at least one paragraph
    if (!bioEl.find('p')) {
      bioEl.append($$('p'));
    }

    return importer.convertElement(bioEl).id
  }

  function _getAffiliationIds (el, isGroup) {
    // let dom = el.ownerDocument
    let xrefs = el.findAll('xref[ref-type=aff]');
    // NOTE: for groups we need to extract only affiliations of group, without members
    if (isGroup) {
      xrefs = el.findAll('collab > xref[ref-type=aff]');
    }
    let affs = xrefs.map(xref => xref.attr('rid'));
    return affs
  }

  function _getAwardIds (el) {
    let xrefs = el.findAll('xref[ref-type=award]');
    let awardIds = xrefs.map(xref => xref.attr('rid'));
    return awardIds
  }

  function _populateAwards (doc, jats) {
    const awards = doc.get('awards');
    const awardEls = jats.findAll('article > front > article-meta > funding-group > award-group');
    awardEls.forEach(el => {
      let award = {
        id: el.id,
        type: 'award',
        institution: getText(el, 'institution'),
        fundRefId: getText(el, 'institution-id'),
        awardId: getText(el, 'award-id')
      };
      awards.append(doc.create(award));
    });
  }

  // TODO: use doc API for manipulation, not a bare object
  function _populateArticleRecord (doc, jats, jatsImporter) {
    let articleMetaEl = jats.find('article > front > article-meta');
    let articleRecord = doc.get('article-record');
    _assign(articleRecord, {
      elocationId: getText(articleMetaEl, 'elocation-id'),
      fpage: getText(articleMetaEl, 'fpage'),
      lpage: getText(articleMetaEl, 'lpage'),
      issue: getText(articleMetaEl, 'issue'),
      volume: getText(articleMetaEl, 'volume'),
      pageRange: getText(articleMetaEl, 'page-range')
    });
    // Import permission if present
    const permissionsEl = articleMetaEl.find('permissions');
    // An empty permission is already there, but will be replaced if <permission> element is there
    if (permissionsEl) {
      doc.delete(articleRecord.permission);
      let permission = jatsImporter.convertElement(permissionsEl);
      // ATTENTION: so that the document model is correct we need to use
      // the Document API  to set the permission id
      _assign(articleRecord, {
        permission: permission.id
      });
    }

    const articleDateEls = articleMetaEl.findAll('history > date, pub-date');
    if (articleDateEls.length > 0) {
      let dates = {};
      articleDateEls.forEach(dateEl => {
        const date = _extractDate(dateEl);
        dates[date.type] = date.value;
      });
      _assign(articleRecord, dates);
    }
  }

  const DATE_TYPES_MAP = {
    'pub': 'publishedDate',
    'accepted': 'acceptedDate',
    'received': 'receivedDate',
    'rev-recd': 'revReceivedDate',
    'rev-request': 'revRequestedDate'
  };

  function _extractDate (el) {
    const dateType = el.getAttribute('date-type');
    const value = el.getAttribute('iso-8601-date');
    const entityProp = DATE_TYPES_MAP[dateType];
    return {
      value: value,
      type: entityProp
    }
  }

  function _populateKeywords (doc, jats) {
    let keywords = doc.get('keywords');
    let kwdEls = jats.findAll('article > front > article-meta > kwd-group > kwd');
    kwdEls.forEach(kwdEl => {
      keywords.append(doc.create({
        type: 'keyword',
        name: kwdEl.textContent,
        category: kwdEl.getAttribute('content-type'),
        language: kwdEl.getParent().getAttribute('xml:lang')
      }));
    });
  }

  function _populateSubjects (doc, jats) {
    // TODO: IMO we need to consolidate this. The original meaning of <subj-group> seems to be
    // to be able to define an ontology, also hierarchically
    // This implementation assumes that subjects are flat.
    // To support translations, multiple subj-groups can be provided with different xml:lang
    let subjects = doc.get('subjects');
    let subjGroups = jats.findAll('article > front > article-meta > article-categories > subj-group');
    // TODO: get this from the article element
    const DEFAULT_LANG = 'en';
    for (let subjGroup of subjGroups) {
      let language = subjGroup.attr('xml:lang') || DEFAULT_LANG;
      let subjectEls = subjGroup.findAll('subject');
      for (let subjectEl of subjectEls) {
        subjects.append(doc.create({
          type: 'subject',
          name: subjectEl.textContent,
          category: subjectEl.getAttribute('content-type'),
          language
        }));
      }
    }
  }

  function _populateTitle (doc, jats, jatsImporter) {
    let title = doc.get('title');
    let titleEl = jats.find('article > front > article-meta > title-group > article-title');
    if (titleEl) {
      _convertAnnotatedText(jatsImporter, titleEl, title);
    }
    // translations
    let titleTranslations = jats.findAll('article > front > article-meta > title-group > trans-title-group > trans-title');
    let translationIds = titleTranslations.map(transTitleEl => {
      let group = transTitleEl.parentNode;
      let language = group.attr('xml:lang');
      let translation = doc.create({ type: 'text-translation', id: transTitleEl.id, language });
      _convertAnnotatedText(jatsImporter, transTitleEl, translation);
      return translation.id
    });
    _assign(title, {
      translations: translationIds
    });
  }

  function _populateAbstract (doc, jats, jatsImporter) {
    let $$ = jats.createElement.bind(jats);
    // ATTENTION: JATS can have multiple abstracts
    // ATM we only take the first, loosing the others
    let abstractEls = jats.findAll('article > front > article-meta > abstract');
    if (abstractEls.length > 0) {
      let abstractEl = abstractEls[0];
      if (abstractEls.length > 1) {
        console.error('FIXME: Texture only supports one <abstract>.');
      }
      // if the abstract is empty, add an empty paragraph
      if (abstractEl.getChildCount() === 0) {
        abstractEl.append($$('p'));
      }
      let abstract = doc.get('abstract');
      abstractEl.children.forEach(el => {
        abstract.append(jatsImporter.convertElement(el));
      });
    }
    // translations
    let transAbstractEls = jats.findAll('article > front > article-meta > trans-abstract');
    let translationIds = transAbstractEls.map(transAbstractEl => {
      let language = transAbstractEl.attr('xml:lang');
      let _childNodes = transAbstractEl.getChildren().map(child => {
        return jatsImporter.convertElement(child).id
      });
      let translation = doc.create({
        type: 'container-translation',
        id: transAbstractEl.id,
        language,
        _childNodes
      });
      return translation.id
    });
    doc.set(['abstract', 'translations'], translationIds);
  }

  function _populateBody (doc, jats, jatsImporter) {
    let $$ = jats.createElement.bind(jats);
    // ATTENTION: JATS can have multiple abstracts
    // ATM we only take the first, loosing the others
    let bodyEl = jats.find('article > body');
    if (bodyEl) {
      // add an empty paragraph if the body is empty
      if (bodyEl.getChildCount() === 0) {
        bodyEl.append($$('p'));
      }
      let body = doc.get('body');
      // ATTENTION: because there is already a body node in the document, *the* body, with id 'body'
      // we must use change the id of the body element so that it does not collide with the internal one
      bodyEl.id = substance.uuid();
      let tmp = jatsImporter.convertElement(bodyEl);
      body.append(tmp.children);
      doc.delete(tmp);
    }
  }

  function _populateFootnotes (doc, jats, jatsImporter) {
    let fnEls = jats.findAll('article > back > fn-group > fn');
    let footnotes = doc.get('footnotes');
    fnEls.forEach(fnEl => {
      footnotes.append(jatsImporter.convertElement(fnEl));
    });
  }

  function _populateReferences (doc, jats, jatsImporter) {
    let references = doc.get('references');
    // TODO: make sure that we only allow this place for references via restricting the TextureJATS schema
    let refListEl = jats.find('article > back > ref-list');
    if (refListEl) {
      let refEls = refListEl.findAll('ref');
      refEls.forEach(refEl => {
        references.append(jatsImporter.convertElement(refEl));
      });
    }
  }

  // Helpers

  function _convertAnnotatedText (jatsImporter, el, textNode) {
    const doc = jatsImporter.state.doc;
    // NOTE: this is a bit difficult but necessary
    // The importer maintains a stack of 'scopes' to deal with recursive calls
    // triggered by converters for nesteded element (annotations and inline nodes)
    jatsImporter.state.pushContext(el.tagName);
    textNode.content = jatsImporter.annotatedText(el, textNode.getPath());
    let context = jatsImporter.state.popContext();
    context.annos.forEach(nodeData => doc.create(nodeData));
  }

  // would be good to have this as a general Node API
  function _assign (node, obj) {
    let doc = node.getDocument();
    let props = Object.keys(obj);
    for (let prop of props) {
      doc.set([node.id, prop], obj[prop]);
    }
  }

  const EMPTY_JATS = `<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article PUBLIC "-//NLM//DTD JATS (Z39.96) Journal Archiving DTD v1.0 20120330//EN" "JATS-journalarchiving.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:ali="http://www.niso.org/schemas/ali/1.0">
  <front>
    <article-meta>
      <title-group>
        <article-title></article-title>
      </title-group>
      <abstract>
      </abstract>
    </article-meta>
  </front>
  <body>
  </body>
  <back>
  </back>
</article>`;

  function createEmptyJATS () {
    return substance.DefaultDOMElement.parseXML(EMPTY_JATS)
  }

  class XrefConverter {
    get type () { return 'xref' }

    get tagName () { return 'xref' }

    import () {
      // nop
    }

    export (node, el, exporter) {
      el.attr(node.attributes);
      let label = getLabel(node);
      if (label) {
        el.text(label);
      }
    }
  }

  function createJatsExporter (jatsDom, doc) {
    // Note: we are applying a hybrid approach, i.e. we create XML importers for the JATS schema
    // but only for those elements which are supported by our internal article schema.
    let jatsSchema = TextureArticle.xmlSchema;
    let tagNames = jatsSchema.getTagNames().filter(name => Boolean(InternalArticleSchema.getNodeClass(name)));
    let jatsConverters = createXMLConverters(TextureArticle.xmlSchema, tagNames);
    // ATTENTION: in this case it is different to the importer
    // not the first matching converter is used, but the last one which is
    // registered for a specific nody type, i.e. a later converter overrides a previous one
    let converters = jatsConverters.concat([
      new BodyConverter(),
      new DispQuoteConverter(),
      new FigConverter(),
      new ListConverter(),
      new PermissionsConverter(),
      new TableWrapConverter(),
      new TableConverter(),
      new ElementCitationConverter(),
      UnsupportedNodeConverter,
      UnsupportedInlineNodeConverter,
      new XrefConverter()
    ]);
    let exporter = new Internal2JATSExporter({
      converters,
      elementFactory: {
        createElement: jatsDom.createElement.bind(jatsDom)
      }
    });
    exporter.state.doc = doc;
    return exporter
  }

  class Internal2JATSExporter extends substance.XMLExporter {
    getNodeConverter (node) {
      let type = node.type;
      if (node.isInstanceOf('bibr')) {
        type = 'bibr';
      }
      return this.converters.get(type)
    }
  }

  /*
    Output will have the following form:

    article:
      (
        front,
        body?,
        back?,
      )
    front:
      (
        journal-meta?,    // not supported yet
        article-meta,
        def-list?         // not supported yet
      )
    article-meta:
      (
        article-id*,      // not supported yet
        article-categories?,  // derived from subjects
        title-group?,
        contrib-group*,
        aff*,
        author-notes?,    // not supported yet
        pub-date*,
        volume?,
        issue?,
        isbn?,
        (((fpage,lpage?)?,page-range?)|elocation-id)?,
        history?,
        permissions?,     // not supported yet
        self-uri*,        // not supported yet
        related-article*, // not supported yet
        related-object*,  // not supported yet
        abstract?,
        trans-abstract*,
        kwd-group*,
        funding-group*,   // derived from awards
        conference*,      // not supported yet
        counts?,          // not supported yet
        custom-meta-group?  // not supported yet
      )
    back:
      (
        ack*, // not supported yet
        bio*, // not supported yet
        fn-group?,
        glossary?,  // not supported yet
        ref-list?,
        notes*, // not supported yet
        sec*  // do we want to support this at all?
      )

    TODO:
      Allow only one place for '<ack>', '<bio>', '<fn-group>', '<glossary>', '<notes>'
  */

  function internal2jats (doc) { // eslint-disable-line
    let jats = createEmptyJATS();
    jats.$$ = jats.createElement.bind(jats);

    // we use this exporter for JATS compliant parts of our intneral document
    let jatsExporter = createJatsExporter(jats, doc);

    // metadata
    _populateFront(jats, doc, jatsExporter);
    _populateBody$1(jats, doc, jatsExporter);
    _populateBack(jats, doc, jatsExporter);

    return jats
  }

  function _populateFront (jats, doc, jatsExporter) {
    // TODO: journal-meta would go here, but is not supported yet

    _populateArticleMeta(jats, doc, jatsExporter);

    // TODO: def-list would go here, but is not supported yet
  }

  function _populateArticleMeta (jats, doc, jatsExporter) {
    const $$ = jats.$$;
    let articleMeta = jats.createElement('article-meta');
    let articleRecord = doc.get('article-record');
    let permission = doc.get(articleRecord.permission);

    // article-id*
    // TODO not supported yet

    // article-categories?
    articleMeta.append(_exportSubjects(jats, doc));

    // title-group?
    articleMeta.append(_exportTitleGroup(jats, doc, jatsExporter))

    // contrib-group*
    ;[
      ['author', 'authors'],
      ['editor', 'editors']
    ].forEach(([type, collectionId]) => {
      let collection = doc.get(collectionId);
      articleMeta.append(
        _exportContribGroup(jats, doc, jatsExporter, collection, type)
      );
    });

    // aff*
    articleMeta.append(_exportAffiliations(jats, doc));

    // author-notes? // not supported yet

    // pub-date*,
    articleMeta.append(
      _exportDate($$, articleRecord, 'publishedDate', 'pub', 'pub-date')
    );

    // volume?,
    if (articleRecord.volume) {
      articleMeta.append($$('volume').append(articleRecord.volume));
    }

    // issue?,
    if (articleRecord.issue) {
      articleMeta.append($$('issue').append(articleRecord.issue));
    }

    // isbn?, // not supported yet

    // (((fpage,lpage?)?,page-range?)|elocation-id)?,
    if (articleRecord.elocationId) {
      articleMeta.append(
        $$('elocation-id').append(articleRecord.elocationId)
      );
    } else if (articleRecord.fpage && articleRecord.lpage) {
      // NOTE: last argument is used to resolve insert position, as we don't have means
      // yet to ask for insert position of multiple elements
      let pageRange = articleRecord.pageRange || articleRecord.fpage + '-' + articleRecord.lpage;
      articleMeta.append(
        $$('fpage').append(articleRecord.fpage),
        $$('lpage').append(articleRecord.lpage),
        $$('page-range').append(pageRange)
      );
    }

    // history?,
    const historyEl = $$('history');
    historyEl.append(_exportDate($$, articleRecord, 'acceptedDate', 'accepted'));
    historyEl.append(_exportDate($$, articleRecord, 'receivedDate', 'received'));
    historyEl.append(_exportDate($$, articleRecord, 'revReceivedDate', 'rev-recd'));
    historyEl.append(_exportDate($$, articleRecord, 'revRequestedDate', 'rev-request'));
    // do not export and <history>
    if (historyEl.getChildCount() > 0) {
      articleMeta.append(historyEl);
    }

    // permissions?,
    if (permission && !permission.isEmpty()) {
      articleMeta.append(
        jatsExporter.convertNode(permission)
      );
    }

    // self-uri*,        // not supported yet

    // related-article*, // not supported yet

    // related-object*,  // not supported yet

    // abstract?,
    articleMeta.append(
      _exportAbstract(jats, doc, jatsExporter)
    );

    // trans-abstract*, // not yet supported

    // kwd-group*,
    articleMeta.append(
      _exportKeywords(jats, doc, jatsExporter)
    );

    // funding-group*,
    articleMeta.append(
      _exportAwards(jats, doc, jatsExporter)
    );

    // conference*,      // not supported yet

    // counts?,          // not supported yet

    // custom-meta-group?  // not supported yet

    // replace the <article-meta> element
    let front = jats.find('article > front');
    let oldArticleMeta = front.find('article-meta');
    front.replaceChild(oldArticleMeta, articleMeta);
  }

  function _exportSubjects (jats, doc) {
    // NOTE: subjects are used to populate <article-categories>
    // - subjects are organized flat, not hierarchically
    // - `subject.category` is mapped to subject[content-type]
    // - subjects are grouped into <subj-groups> using their language property
    // group subjects by language
    // TODO: this should come from the article node
    let $$ = jats.$$;
    let subjects = doc.get('subjects');
    let byLang = subjects.getChildren().reduce((byLang, subject) => {
      let lang = subject.language;
      if (!byLang[lang]) {
        byLang[lang] = [];
      }
      byLang[lang].push(subject);
      return byLang
    }, {});
    let articleCategories = $$('article-categories');
    substance.forEach(byLang, (subjects, lang) => {
      let groupEl = $$('subj-group').attr('xml:lang', lang);
      groupEl.append(
        subjects.map(subject => {
          return $$('subject').attr({ 'content-type': subject.category }).text(subject.name)
        })
      );
      articleCategories.append(groupEl);
    });
    // only return if there have been converted subjects
    if (articleCategories.getChildCount() > 0) {
      return articleCategories
    }
  }

  function _exportTitleGroup (jats, doc, jatsExporter) {
    let $$ = jats.$$;
    // ATTENTION: ATM only one, *the* title is supported
    // Potentially there are sub-titles, and JATS even supports more titles beyond this (e.g. for special purposes)
    let title = doc.get('title');
    let titleGroupEl = $$('title-group');
    let articleTitle = $$('article-title');
    _exportAnnotatedText$1(jatsExporter, title.getPath(), articleTitle);
    titleGroupEl.append(articleTitle);

    // translations
    titleGroupEl.append(
      title.getTranslations().map(translation => {
        return $$('trans-title-group').attr({ 'xml:lang': translation.language })
          .append(
            $$('trans-title').attr({ id: translation.id }).append(
              jatsExporter.annotatedText(translation.getPath())
            )
          )
      })
    );

    return titleGroupEl
  }

  function _exportContribGroup (jats, doc, exporter, personCollection, type) {
    // FIXME: this should not happen if we have general support for 'person-groups'
    // ATM, we only support authors, and editors.
    let $$ = jats.$$;
    let contribs = personCollection.getChildren();
    let contribGroupEl = $$('contrib-group').attr('content-type', type);
    let groupedContribs = _groupContribs(contribs);
    for (let [groupId, persons] of groupedContribs) {
      // append persons without a group first
      if (groupId === 'NOGROUP') {
        persons.forEach(person => {
          contribGroupEl.append(_exportPerson($$, exporter, person));
        });
      // persons within a group are nested into an extra <contrib> layer
      } else {
        let group = doc.get(groupId);
        contribGroupEl.append(_exportGroup($$, exporter, group, persons));
      }
    }
    if (contribGroupEl.getChildCount() > 0) {
      return contribGroupEl
    }
  }

  /*
    Uses group association of person nodes to create groups

    [p1,p2g1,p3g2,p4g1] => {p1: p1, g1: [p2,p4], g2: [p3] }
  */
  function _groupContribs (contribs) {
    let groups = new Map();
    groups.set('NOGROUP', []);
    for (let contrib of contribs) {
      let groupId = contrib.group;
      if (groupId) {
        if (!groups.has(groupId)) {
          groups.set(groupId, []);
        }
        groups.get(groupId).push(contrib);
      } else {
        groups.get('NOGROUP').push(contrib);
      }
    }
    return groups
  }

  function _exportPerson ($$, exporter, node) {
    let el = $$('contrib').attr({
      'contrib-type': 'person',
      'equal-contrib': node.equalContrib ? 'yes' : 'no',
      'corresp': node.corresp ? 'yes' : 'no',
      'deceased': node.deceased ? 'yes' : 'no'
    });
    el.append(
      $$('name').append(
        _createTextElement$1($$, node.surname, 'surname'),
        _createTextElement$1($$, node.givenNames, 'given-names'),
        _createTextElement$1($$, node.prefix, 'prefix'),
        _createTextElement$1($$, node.suffix, 'suffix')
      ),
      _createTextElement$1($$, node.email, 'email'),
      _createTextElement$1($$, node.alias, 'string-name', {'content-type': 'alias'}),
      _createBioElement($$, exporter, node)
    );
    node.affiliations.forEach(organisationId => {
      el.append(
        $$('xref').attr('ref-type', 'aff').attr('rid', organisationId)
      );
    });
    node.awards.forEach(awardId => {
      el.append(
        $$('xref').attr('ref-type', 'award').attr('rid', awardId)
      );
    });
    return el
  }

  function _createBioElement ($$, exporter, node) {
    let bio = node.getBio();
    if (bio) {
      // NOTE: we don't want to export empty containers
      // e.g. if there is only one empty paragraph we are not exporting anything
      if (bio.length === 1 && bio.children[0].isEmpty()) {
        return
      }
      let bioEl = exporter.convertNode(bio);
      return bioEl
    }
  }

  function _exportGroup ($$, exporter, node, groupMembers) {
    /*
      <contrib id="${node.id}" contrib-type="group" equal-contrib="yes|no" corresp="yes|no">
        <collab>
          <named-content content-type="name">${node.name}</named-content>
          <email>${node.email}</email>
          <$ for (let affId of node.affiliations) {$>
            <xref ref-type="aff" rid=${affId} />
          <$ } $>
          <$ for (let awardId of node.awards) {$>
            <xref ref-type="award" rid=${awardId} />
          <$ } $>
          <contrib-group contrib-type="group-member">
            <$ for (let person of groupMembers) {$>
              <Person node=${person} />
            <$ } $>
          </contrib-group>
          </collab>
      </contrib>
    */
    let contribEl = $$('contrib').attr({
      'id': node.id,
      'contrib-type': 'group',
      'equal-contrib': node.equalContrib ? 'yes' : 'no',
      'corresp': node.corresp ? 'yes' : 'no'
    });
    let collab = $$('collab');
    collab.append(
      $$('named-content').attr('content-type', 'name').append(node.name),
      $$('email').append(node.email)
    );
    // Adds affiliations to group
    node.affiliations.forEach(organisationId => {
      collab.append(
        $$('xref').attr('ref-type', 'aff').attr('rid', organisationId)
      );
    });
    // Add awards to group
    node.awards.forEach(awardId => {
      collab.append(
        $$('xref').attr('ref-type', 'award').attr('rid', awardId)
      );
    });
    // Add group members
    // <contrib-group contrib-type="group-member">
    let contribGroup = $$('contrib-group').attr('contrib-type', 'group-member');
    groupMembers.forEach(person => {
      let contribEl = _exportPerson($$, exporter, person);
      contribGroup.append(contribEl);
    });
    collab.append(contribGroup);
    contribEl.append(collab);
    return contribEl
  }

  function _exportAffiliations (jats, doc) {
    let $$ = jats.$$;
    let organisations = doc.get('organisations');
    let orgEls = organisations.getChildren().map(node => {
      let el = $$('aff').attr('id', node.id);
      el.append(_createTextElement$1($$, node.name, 'institution', {'content-type': 'orgname'}));
      el.append(_createTextElement$1($$, node.division1, 'institution', {'content-type': 'orgdiv1'}));
      el.append(_createTextElement$1($$, node.division2, 'institution', {'content-type': 'orgdiv2'}));
      el.append(_createTextElement$1($$, node.division3, 'institution', {'content-type': 'orgdiv3'}));
      el.append(_createTextElement$1($$, node.street, 'addr-line', {'content-type': 'street-address'}));
      el.append(_createTextElement$1($$, node.addressComplements, 'addr-line', {'content-type': 'complements'}));
      el.append(_createTextElement$1($$, node.city, 'city'));
      el.append(_createTextElement$1($$, node.state, 'state'));
      el.append(_createTextElement$1($$, node.postalCode, 'postal-code'));
      el.append(_createTextElement$1($$, node.country, 'country'));
      el.append(_createTextElement$1($$, node.phone, 'phone'));
      el.append(_createTextElement$1($$, node.fax, 'fax'));
      el.append(_createTextElement$1($$, node.email, 'email'));
      el.append(_createTextElement$1($$, node.uri, 'uri', {'content-type': 'link'}));
      return el
    });
    return orgEls
  }

  function _exportDate ($$, node, prop, dateType, tag) {
    const date = node[prop];
    // Do not export a date without value
    if (!date) return

    const tagName = tag || 'date';
    const el = $$(tagName).attr('date-type', dateType)
      .attr('iso-8601-date', date);

    const year = date.split('-')[0];
    const month = date.split('-')[1];
    const day = date.split('-')[2];
    if (_isDateValid(date)) {
      el.append(
        $$('day').append(day),
        $$('month').append(month),
        $$('year').append(year)
      );
    } else if (_isYearMonthDateValid(date)) {
      el.append(
        $$('month').append(month),
        $$('year').append(year)
      );
    } else if (_isYearDateValid(date)) {
      el.append(
        $$('year').append(year)
      );
    }
    return el
  }

  function _isDateValid (str) {
    const regexp = /^[0-9]{4}-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])$/;
    if (!regexp.test(str)) return false
    return true
  }

  function _isYearMonthDateValid (str) {
    const regexp = /^[0-9]{4}-(0[1-9]|1[0-2])$/;
    if (!regexp.test(str)) return false
    return true
  }

  function _isYearDateValid (str) {
    const regexp = /^[0-9]{4}$/;
    if (!regexp.test(str)) return false
    return true
  }

  function _createTextElement$1 ($$, text, tagName, attrs) {
    if (text) {
      let el = $$(tagName).append(text);
      substance.forEach(attrs, (value, key) => {
        el.attr(key, value);
      });
      return el
    }
  }

  /**
   * @param {DOMElement} jats the JATS DOM to export into
   * @param {Document} doc the document to convert from
   * @param {XMLExporter} jatsExporter an exporter instance used to export nested nodes
   */
  function _exportAbstract (jats, doc, jatsExporter) {
    const $$ = jats.$$;
    let abstract = doc.get('abstract');
    let els = [];

    // <abstract>
    let abstractEl = $$('abstract');
    // the abstract element itself is required
    // but we skip empty content
    if (!_isContainerEmpty(abstract)) {
      abstract.getChildren().forEach(p => {
        abstractEl.append(jatsExporter.convertNode(p));
      });
    }
    els.push(abstractEl);

    // translations
    abstract.getTranslations().forEach(translation => {
      if (!_isContainerEmpty(translation)) {
        let transAbstractEl = $$('trans-abstract').attr({ id: translation.id, 'xml:lang': translation.language })
          .append(
            translation.getChildren().map(child => jatsExporter.convertNode(child))
          );
        els.push(transAbstractEl);
      }
    });
    return els
  }

  function _exportKeywords (jats, doc) {
    const $$ = jats.$$;
    // TODO: keywords should be translatables
    const keywords = doc.get('keywords');
    let byLang = keywords.getChildren().reduce((byLang, keyword) => {
      let lang = keyword.language;
      if (!byLang[lang]) {
        byLang[lang] = [];
      }
      byLang[lang].push(keyword);
      return byLang
    }, {});
    let keywordGroups = [];
    substance.forEach(byLang, (keywords, lang) => {
      let groupEl = $$('kwd-group').attr('xml:lang', lang);
      groupEl.append(
        keywords.map(keyword => {
          return $$('kwd').attr({ 'content-type': keyword.category }).text(keyword.name)
        })
      );
      keywordGroups.push(groupEl);
    });
    return keywordGroups
  }

  function _exportAwards (jats, doc) {
    const $$ = jats.$$;
    let awards = doc.get('awards').getChildren();
    if (awards.length > 0) {
      let fundingGroupEl = $$('funding-group');
      awards.forEach(award => {
        let el = $$('award-group').attr('id', award.id);
        let institutionWrapEl = $$('institution-wrap');
        institutionWrapEl.append(_createTextElement$1($$, award.fundRefId, 'institution-id', {'institution-id-type': 'FundRef'}));
        institutionWrapEl.append(_createTextElement$1($$, award.institution, 'institution'));
        el.append(
          $$('funding-source').append(institutionWrapEl),
          _createTextElement$1($$, award.awardId, 'award-id')
        );
        fundingGroupEl.append(el);
      });
      return fundingGroupEl
    }
  }

  function _populateBody$1 (jats, doc, jatsExporter) {
    let body = doc.get('body');
    if (!_isContainerEmpty(body)) {
      let bodyEl = jatsExporter.convertNode(body);
      let oldBody = jats.find('article > body');
      oldBody.parentNode.replaceChild(oldBody, bodyEl);
    }
  }

  function _populateBack (jats, doc, jatsExporter) {
    let $$ = jats.$$;
    let backEl = jats.find('article > back');
    /*
      back:
      (
        fn-group?,
        ref-list?,
      )
    */
    let footnotes = doc.get('footnotes').getChildren();
    if (footnotes.length > 0) {
      backEl.append(
        $$('fn-group').append(
          footnotes.map(footnote => {
            return jatsExporter.convertNode(footnote)
          })
        )
      );
    }

    let references = doc.get('references').getChildren();
    if (references.length > 0) {
      backEl.append(
        $$('ref-list').append(
          references.map(ref => {
            return jatsExporter.convertNode(ref)
          })
        )
      );
    }
  }

  function _exportAnnotatedText$1 (jatsExporter, path, el) {
    el.append(jatsExporter.annotatedText(path));
  }

  function _isContainerEmpty (container) {
    if (container.getChildCount() === 0) return true
    if (container.getChildCount() > 1) return false
    let first = container.getChildAt(0);
    return first && first.isText() && !first.getText()
  }

  function validateXML (xmlSchema, dom, options = {}) {
    let root = dom.find(xmlSchema.getStartElement());
    let allowNotImplemented = true;
    if (options.hasOwnProperty('allowNotImplemented')) {
      allowNotImplemented = Boolean(options.allowNotImplemented);
    }
    if (!root) {
      return {
        errors: [{
          msg: 'Start element is missing.',
          el: dom
        }]
      }
    } else {
      return validateElement(xmlSchema, root, { allowNotImplemented })
    }
  }

  function validateElement (xmlSchema, el, options) {
    const allowNotImplemented = options.allowNotImplemented;
    let errors = [];
    let valid = true;
    let q = [el];
    while (q.length > 0) {
      let next = q.shift();
      let elementSchema = xmlSchema.getElementSchema(next.tagName);
      if (!elementSchema) continue
      if (!allowNotImplemented && elementSchema.type === 'not-implemented') {
        errors.push({
          msg: `<${next.tagName}> is not implemented yet.`,
          el: next.parentNode
        });
        valid = false;
      }
      let res = xmlSchema.validateElement(next);
      if (!res.ok) {
        errors = errors.concat(res.errors);
        valid = false;
      }
      if (next.isElementNode()) {
        q = q.concat(next.getChildren());
      }
    }
    return {
      errors: errors,
      ok: valid
    }
  }

  class JATSImporter extends substance.EventEmitter {
    import (xml, options = {}) {
      let state = {
        dom: null,
        errors: {
          'parse': [],
          'validate-jats': [],
          'jats2restrictedJats': [],
          'validate-texture-article': [],
          'jats2internal': []
        },
        hasErrored: false
      };

      if (substance.isString(xml)) {
        try {
          state.dom = substance.DefaultDOMElement.parseXML(xml);
        } catch (err) {
          console.error('Could not parse XML:', err);
          this._error(state, 'parse', {
            msg: String(err)
          });
          return
        }
      } else if (xml._isDOMElement) {
        state.dom = xml;
      }

      if (!this._validate(JATS, state)) return state

      // JATS -> restricted JATS (= TextureArticle)
      if (!this._transform('jats2restrictedJats', state)) return state

      if (!this._validate(TextureArticle, state, options)) return state

      // restrictedJATS -> InternalArticle
      if (!this._transform('jats2internal', state)) return state

      return state
    }

    _validate (schema, state, options) {
      const name = schema.getName();
      const channel = `validate-${name}`;
      let res = validateXML(schema, state.dom, options);
      if (!res.ok) {
        res.errors.forEach((err) => {
          this._error(state, channel, err);
        });
        return false
      }
      return true
    }

    _transform (mode, state) {
      const api = this._createAPI(state, mode);
      let dom = state.dom;
      switch (mode) {
        case 'jats2restrictedJats':
          jats2restrictedJats(dom, api);
          break
        case 'jats2internal':
          state.doc = jats2internal(dom, api);
          break
        default:
          //
      }
      return true
    }

    _createAPI (state, channel) {
      const self = this;
      let api = {
        error (data) {
          self._error(state, channel, data);
        }
      };
      return api
    }

    _error (state, channel, err) {
      state.hasErrored = true;
      state.errors[channel].push(err);
    }
  }

  class JATSExporter {
    /*
      Takes a InternalArticle document as a DOM and transforms it into a JATS document,
      following TextureArticle guidelines.
    */
    export (doc) {
      let jats = internal2jats(doc);
      let res = substance.validateXMLSchema(TextureArticle, jats);
      if (!res.ok) {
        res.errors.forEach((err) => {
          console.error(err.msg, err.el);
        });
      }
      return {
        jats,
        ok: res.ok,
        errors: res.errors
      }
    }
  }

  var EntityLabelsPackage = {
    name: 'entity-labels',
    configure (config) {
      // general
      config.addLabel('edit-references', 'Edit References');
      config.addLabel('edit-affiliations', 'Edit Affiliations');
      config.addLabel('show-more-fields', 'More fields');
      config.addLabel('show-less-fields', 'Less fields');
      config.addLabel('multi-select-default-value', 'Click to select a value');
      config.addLabel('select-default-value', 'No value selected');

      // item types
      config.addLabel('journal-article-ref', 'Journal Article');
      config.addLabel('edit-journal-article-ref', 'Edit Journal Article');
      config.addLabel('add-journal-article-ref', 'Add Journal Article');
      config.addLabel('create-journal-article-ref', 'Create Journal Article');

      config.addLabel('book-ref', 'Book');
      config.addLabel('edit-book-ref', 'Edit Book');
      config.addLabel('add-book-ref', 'Add Book');
      config.addLabel('create-book-ref', 'Create Book');

      config.addLabel('chapter-ref', 'Chapter');
      config.addLabel('edit-chapter-ref', 'Edit Chapter');
      config.addLabel('add-chapter-ref', 'Add Chapter');
      config.addLabel('create-chapter-ref', 'Create Chapter');

      config.addLabel('conference-paper-ref', 'Conference Paper');
      config.addLabel('create-conference-paper-ref', 'Create Conference Paper');
      config.addLabel('edit-conference-paper-ref', 'Edit Conference Paper');

      config.addLabel('webpage-ref', 'Webpage');
      config.addLabel('create-webpage-ref', 'Create Webpage');
      config.addLabel('edit-webpage-ref', 'Edit Webpage');

      config.addLabel('thesis-ref', 'Thesis');
      config.addLabel('create-thesis-ref', 'Create Thesis');
      config.addLabel('edit-thesis-ref', 'Edit Thesis');

      config.addLabel('software-ref', 'Software');
      config.addLabel('create-software-ref', 'Create Software');
      config.addLabel('edit-software-ref', 'Edit Software');

      config.addLabel('report-ref', 'Report');
      config.addLabel('create-report-ref', 'Create Report');
      config.addLabel('edit-report-ref', 'Edit Report');

      config.addLabel('data-publication-ref', 'Data Publication');
      config.addLabel('create-data-publication-ref', 'Create Data Publication');
      config.addLabel('edit-data-publication-ref', 'Edit Data Publication');

      config.addLabel('magazine-article-ref', 'Magazine Article');
      config.addLabel('create-magazine-article-ref', 'Create Magazine Article');
      config.addLabel('edit-magazine-article-ref', 'Edit Magazine Article');

      config.addLabel('newspaper-article-ref', 'Newspaper Article');
      config.addLabel('create-newspaper-article-ref', 'Create Newspaper Article');
      config.addLabel('edit-newspaper-article-ref', 'Edit Newspaper Article');

      config.addLabel('patent-ref', 'Patent');
      config.addLabel('create-patent-ref', 'Create Patent');

      config.addLabel('article-ref', 'Article');
      config.addLabel('create-article-ref', 'Create Article');

      // fields labels
      config.addLabel('authors', 'Authors');
      config.addLabel('edit-authors', 'Edit Authors');

      config.addLabel('editors', 'Editors');
      config.addLabel('edit-editors', 'Edit Editors');

      config.addLabel('translators', 'Translators');
      config.addLabel('edit-translators', 'Edit Translators');

      config.addLabel('abstract', 'Abstract');
      config.addLabel('accessedDate', 'Accessed Date');
      config.addLabel('accessionId', 'Accession ID');
      config.addLabel('archiveId', 'Archive ID');
      config.addLabel('arkId', 'ARK ID');
      config.addLabel('assignee', 'Assignee');
      config.addLabel('confLoc', 'Conference Location');
      config.addLabel('confName', 'Conference Name');
      config.addLabel('containerTitle', 'Source');
      config.addLabel('day', 'Day');
      config.addLabel('doi', 'DOI');
      config.addLabel('edition', 'Edition');
      config.addLabel('elocationId', 'E-Location ID');
      config.addLabel('fpage', 'First Page');
      config.addLabel('inventors', 'Inventors');
      config.addLabel('isbn', 'ISBN');
      config.addLabel('issue', 'Issue');
      config.addLabel('lpage', 'Last Page');
      config.addLabel('month', 'Month');
      config.addLabel('pageCount', 'Page Count');
      config.addLabel('pageRange', 'Page Range');
      config.addLabel('patentCountry', 'Patent Country');
      config.addLabel('patentNumber', 'Patent Number');
      config.addLabel('partTitle', 'Part Title');
      config.addLabel('pmid', 'PubMed ID');
      config.addLabel('publisherLoc', 'Publisher Location');
      config.addLabel('publisherName', 'Publisher Name');
      config.addLabel('source', 'Source');
      config.addLabel('sponsors', 'Sponsors');
      config.addLabel('series', 'Series');
      config.addLabel('title', 'Title');
      config.addLabel('version', 'Version');
      config.addLabel('volume', 'Volume');
      config.addLabel('year', 'Year');

      config.addLabel('acceptedDate', 'Accepted Date');
      config.addLabel('publishedDate', 'Published Date');
      config.addLabel('receivedDate', 'Received Date');
      config.addLabel('revReceivedDate', 'Revision Received Date');
      config.addLabel('revRequestedDate', 'Revision Requested Date');

      // person labels
      config.addLabel('person', 'Person');
      config.addLabel('add-person', 'Add Person');
      config.addLabel('edit-person', 'Edit Person');
      config.addLabel('create-person', 'Create Person');
      config.addLabel('orcid', 'ORCID');
      config.addLabel('givenNames', 'Given Names');
      config.addLabel('surname', 'Surname');
      config.addLabel('alias', 'Alias');
      config.addLabel('prefix', 'Prefix');
      config.addLabel('suffix', 'Suffix');
      config.addLabel('bio', 'Biography');
      config.addLabel('affiliations', 'Affiliations');
      config.addLabel('awards', 'Awards');
      config.addLabel('group', 'Group');
      config.addLabel('equalContrib', 'Equal Contribution');
      config.addLabel('corresp', 'Corresponding Author');
      config.addLabel('deceased', 'Deceased');

      // organisation labels
      config.addLabel('organisation', 'Affiliation');
      config.addLabel('add-organisation', 'Add Organisation');
      config.addLabel('edit-organisation', 'Edit Organisation');
      config.addLabel('create-organisation', 'Create Organisation');
      config.addLabel('name', 'Name');
      config.addLabel('division1', 'Division 1 (Department)');
      config.addLabel('division2', 'Division 2');
      config.addLabel('division3', 'Division 2');
      config.addLabel('street', 'Address Line 1 (Street)');
      config.addLabel('addressComplements', 'Address Line 2 (Complements)');
      config.addLabel('city', 'City');
      config.addLabel('state', 'State');
      config.addLabel('postalCode', 'Postal Code');
      config.addLabel('country', 'Country');
      config.addLabel('phone', 'Phone');
      config.addLabel('fax', 'Fax');
      config.addLabel('email', 'Email');
      config.addLabel('uri', 'Website');
      config.addLabel('members', 'Members');
      config.addLabel('edit-members', 'Edit Members');

      // award labels
      config.addLabel('award', 'Award');
      config.addLabel('institution', 'Institution Name');
      config.addLabel('fundRefId', 'Institution Identifier');
      config.addLabel('awardId', 'Award Identifier');

      // keyword labels
      config.addLabel('keyword', 'Keyword');
      config.addLabel('category', 'Category');
      config.addLabel('language', 'Language');

      // subject labels
      config.addLabel('subject', 'Subject');

      // figure labels
      config.addLabel('figure', 'Figure');
      config.addLabel('content', 'Content');
      config.addLabel('caption', 'Caption');
      config.addLabel('copyrightStatement', 'Copyright Statement');
      config.addLabel('copyrightYear', 'Copyright Year');
      config.addLabel('copyrightHolder', 'Copyright Holder');
      config.addLabel('license', 'License');
      config.addLabel('licenseText', 'License Text (optional)');

      // translatable labels
      config.addLabel('translatable', 'Translation');

      // footnote labels
      config.addLabel('fn', 'Footnote');
    }
  }

  function journalArticleRenderer ($$, entityId, entityDb, exporter) {
    let entity = entityDb.get(entityId);
    let fragments = [];

    if (entity.authors.length > 0) {
      fragments = fragments.concat(
        _renderAuthors($$, entity.authors, entityDb),
        '.'
      );
    }

    // We render an annotated article title here:
    if (entity.title) {
      fragments.push(
        ' ',
        ...exporter.annotatedText([entity.id, 'title'], entityDb, $$),
        '.'
      );
    }

    if (entity.editors.length > 0) {
      fragments = fragments.concat(
        ' ',
        _renderAuthors($$, entity.editors, entityDb),
        '.'
      );
    }
    if (entity.containerTitle) {
      fragments.push(
        ' ',
        $$('i').append(entity.containerTitle),
        '.'
      );
    }

    let date = _renderDate($$, entity.year, entity.month, entity.day, 'short');
    if (date) {
      fragments.push(' ', date, ';');
    }

    if (entity.volume) {
      fragments.push(entity.volume);
    }
    if (entity.issue) {
      fragments.push('(', entity.issue, ')');
    }

    let contentLocation = _renderLocation($$, entity.fpage, entity.lpage, entity.pageRange, entity.elocationId);
    if (contentLocation) {
      fragments.push(':', contentLocation, '.');
    } else {
      fragments.push('.');
    }

    if (entity.doi) {
      fragments.push(
        ' ',
        _renderDOI($$, entity.doi)
      );
    }

    if (entity.pmid) {
      fragments.push(' PMID ', entity.pmid);
    }
    return fragments
  }

  function bookRenderer ($$, entityId, entityDb, exporter) {
    let entity = entityDb.get(entityId);
    let fragments = [];

    if (entity.authors.length > 0) {
      fragments = fragments.concat(
        _renderAuthors($$, entity.authors, entityDb),
        '.'
      );
    } else if (entity.editors.length > 0) {
      let editorLabel = entity.editors.length > 1 ? 'eds' : 'ed';
      fragments = fragments.concat(
        _renderAuthors($$, entity.editors, entityDb),
        ', ',
        editorLabel,
        '.'
      );
    }
    if (entity.translators.length) {
      fragments = fragments.concat(
        ' (',
        _renderAuthors($$, entity.translators, entityDb),
        ', trans).'
      );
    }
    if (entity.title) {
      fragments.push(
        ' ',
        $$('i').append(entity.title),
        '.'
      );
    }
    if (entity.volume) {
      if (/^\d+$/.test(entity.volume)) {
        fragments.push(' Vol ', entity.volume, '.');
      } else {
        fragments.push(' ', entity.volume, '.');
      }
    }
    if (entity.edition) {
      fragments.push(' ', entity.edition, '.');
    }
    if (entity.editors.length > 0 && entity.authors.length > 0) {
      let editorLabel = entity.editors.length > 1 ? 'eds' : 'ed';
      fragments = fragments.concat(
        ' (',
        _renderAuthors($$, entity.editors, entityDb),
        ', ',
        editorLabel,
        ').'
      );
    }

    fragments.push(_renderPublisherPlace($$, entity.publisherLoc, entity.publisherName));

    if (entity.series) {
      fragments.push(' (', entity.series, ')');
    }

    if (entity.year) {
      fragments.push(' ', entity.year);
      if (entity.month) {
        fragments.push(' ', _renderMonth(entity.month, 'short'));
      }
    }
    let contentLocation = _renderLocation($$, entity.fpage, entity.lpage, entity.pageRange, entity.elocationId);
    if (contentLocation) {
      fragments.push(':', contentLocation, '.');
    } else {
      fragments.push('.');
    }

    if (entity.doi) {
      fragments.push(
        ' ',
        _renderDOI($$, entity.doi)
      );
    }
    return fragments
  }

  function chapterRenderer ($$, entityId, entityDb, exporter) {
    let entity = entityDb.get(entityId);
    let fragments = [];

    if (entity.authors.length > 0) {
      fragments = fragments.concat(
        _renderAuthors($$, entity.authors, entityDb),
        '.'
      );
    }
    if (entity.translators.length) {
      fragments = fragments.concat(
        ' (',
        _renderAuthors($$, entity.translators, entityDb),
        ', trans).'
      );
    }
    if (entity.title) {
      fragments.push(
        ' ',
        ...exporter.annotatedText([entity.id, 'title'], entityDb, $$),
        '. '
      );
    }

    fragments = fragments.concat('In: ');
    if (entity.editors.length > 0) {
      let editorLabel = entity.editors.length > 1 ? 'eds' : 'ed';
      fragments = fragments.concat(
        ' ',
        _renderAuthors($$, entity.editors, entityDb),
        ', ',
        editorLabel,
        '.'
      );
    }
    if (entity.containerTitle) {
      fragments.push(
        ' ',
        $$('i').append(
          entity.containerTitle
        ),
        '.'
      );
    }
    if (entity.volume) {
      if (/^\d+$/.test(entity.volume)) {
        fragments.push(' ', entity.volume, '.');
      } else {
        fragments.push(' Vol ', entity.volume, '.');
      }
    }
    if (entity.edition) {
      fragments.push(' ', entity.edition, '.');
    }

    fragments.push(_renderPublisherPlace($$, entity.publisherLoc, entity.publisherName));

    if (entity.series) {
      fragments.push(' (', entity.series, ')');
    }

    if (entity.year) {
      fragments.push(' ', entity.year);
      if (entity.month) {
        fragments.push(' ', _renderMonth(entity.month, 'short'));
      }
    }
    let contentLocation = _renderLocation($$, entity.fpage, entity.lpage, entity.pageRange, entity.elocationId);
    if (contentLocation) {
      fragments.push(':', contentLocation, '.');
    } else {
      fragments.push('.');
    }

    if (entity.doi) {
      fragments.push(
        ' ',
        _renderDOI($$, entity.doi)
      );
    }
    return fragments
  }

  function patentRenderer ($$, entityId, entityDb, exporter) {
    let entity = entityDb.get(entityId);
    let fragments = [];

    if (entity.inventors.length > 0) {
      fragments = fragments.concat(
        _renderAuthors($$, entity.inventors, entityDb),
        '.'
      );
    }
    if (entity.title) {
      fragments.push(
        ' ',
        ...exporter.annotatedText([entity.id, 'title'], entityDb, $$),
        '. '
      );
    }

    if (entity.assignee) {
      fragments.push(' ', entity.assignee, ',');
    }
    let date = _renderDate($$, entity.year, entity.month, entity.day, 'short');
    if (date) {
      fragments.push(' ', date, ';');
    }
    if (entity.patentNumber) {
      fragments.push(' ', entity.patentNumber);
    }
    if (entity.patentCountry) {
      fragments.push(' (', entity.patentCountry, ').');
    }
    return fragments
  }

  function articleRenderer ($$, entityId, entityDb, exporter) {
    let entity = entityDb.get(entityId);
    let fragments = [];

    if (entity.authors.length > 0) {
      fragments = fragments.concat(
        _renderAuthors($$, entity.authors, entityDb),
        '.'
      );
    }
    // We render an annotated article title here:
    if (entity.title) {
      fragments.push(
        ' ',
        ...exporter.annotatedText([entity.id, 'title'], entityDb, $$),
        '.'
      );
    }

    if (entity.editors.length > 0) {
      fragments = fragments.concat(
        ' ',
        _renderAuthors($$, entity.editors, entityDb),
        '.'
      );
    }
    if (entity.containerTitle) {
      fragments.push(
        ' ',
        $$('i').append(entity.containerTitle),
        '.'
      );
    }

    let date = _renderDate($$, entity.year, entity.month, entity.day, 'short');
    if (date) {
      fragments.push(' ', date, ';');
    }

    if (entity.issue) {
      fragments.push('(', entity.issue, ')');
    }

    if (entity.doi) {
      fragments.push(
        ' ',
        _renderDOI($$, entity.doi)
      );
    }

    if (entity.pmid) {
      fragments.push(' PMID ', entity.pmid);
    }
    return fragments
  }

  function dataPublicationRenderer ($$, entityId, entityDb, exporter) {
    let entity = entityDb.get(entityId);
    let fragments = [];

    if (entity.authors.length > 0) {
      fragments = fragments.concat(
        _renderAuthors($$, entity.authors, entityDb),
        '.'
      );
    }
    if (entity.title) {
      fragments.push(
        ' ',
        ...exporter.annotatedText([entity.id, 'title'], entityDb, $$),
        '. '
      );
    }

    if (entity.containerTitle) {
      fragments.push(
        ' ',
        $$('i').append(entity.containerTitle),
        '.'
      );
    }
    if (entity.year) {
      fragments.push(' ', entity.year);
      if (entity.month) {
        fragments.push(' ', _renderMonth(entity.month, 'short'));
      }
      fragments.push('.');
    }
    if (entity.doi) {
      fragments.push(
        ' ',
        _renderDOI($$, entity.doi)
      );
    }
    return fragments
  }

  function magazineArticleRenderer ($$, entityId, entityDb, exporter) {
    let entity = entityDb.get(entityId);
    let fragments = [];

    if (entity.authors.length > 0) {
      fragments = fragments.concat(
        _renderAuthors($$, entity.authors, entityDb),
        '.'
      );
    }
    if (entity.title) {
      fragments.push(
        ' ',
        ...exporter.annotatedText([entity.id, 'title'], entityDb, $$),
        '. '
      );
    }

    if (entity.containerTitle) {
      fragments.push(
        ' ',
        $$('i').append(entity.containerTitle),
        ','
      );
    }

    if (entity.year) {
      fragments.push(' ', entity.year);
      if (entity.month) {
        fragments.push(' ', _renderMonth(entity.month, 'short'));
      }
    }

    let contentLocation = _renderLocation($$, entity.fpage, entity.lpage, entity.pageRange, entity.elocationId);
    if (contentLocation) {
      fragments.push(':', contentLocation, '.');
    } else {
      fragments.push('.');
    }

    if (entity.doi) {
      fragments.push(
        ' ',
        _renderDOI($$, entity.doi)
      );
    }

    return fragments
  }

  function newspaperArticleRenderer ($$, entityId, entityDb, exporter) {
    let entity = entityDb.get(entityId);
    let fragments = [];

    if (entity.authors.length > 0) {
      fragments = fragments.concat(
        _renderAuthors($$, entity.authors, entityDb),
        '.'
      );
    }
    if (entity.title) {
      fragments.push(
        ' ',
        ...exporter.annotatedText([entity.id, 'title'], entityDb, $$),
        '. '
      );
    }

    if (entity.containerTitle) {
      fragments.push(
        ' ',
        $$('i').append(entity.containerTitle),
        ','
      );
      if (entity.edition) {
        fragments.push(
          ' ',
          $$('i').append(entity.edition),
          ','
        );
      }
    }

    if (entity.year) {
      fragments.push(' ', entity.year);
      if (entity.month) {
        fragments.push(' ', _renderMonth(entity.month, 'short'));
      }
    }

    let contentLocation = _renderLocation($$, entity.fpage, entity.lpage, entity.pageRange, entity.elocationId);
    if (contentLocation) {
      fragments.push(':', contentLocation);
    }
    if (entity.partTitle) {
      fragments.push(' (', entity.partTitle, ')');
    }
    fragments.push('.');

    if (entity.doi) {
      fragments.push(
        ' ',
        _renderDOI($$, entity.doi)
      );
    }

    return fragments
  }

  function reportRenderer ($$, entityId, entityDb, exporter) {
    let entity = entityDb.get(entityId);
    let fragments = [];
    if (entity.authors.length > 0) {
      fragments = fragments.concat(
        _renderAuthors($$, entity.authors, entityDb),
        '. '
      );
    }

    if (entity.sponsors.length > 0) {
      fragments = fragments.concat(
        _renderAuthors($$, entity.sponsors, entityDb),
        ', sponsors. '
      );
    }

    if (entity.title) {
      fragments.push(
        $$('i').append(entity.title),
        '.'
      );
    }

    fragments.push(_renderPublisherPlace($$, entity.publisherLoc, entity.publisherName));

    if (entity.series) {
      fragments.push(' (', entity.series, ')');
    }

    if (entity.year) {
      fragments.push(' ', entity.year);
      if (entity.month) {
        fragments.push(' ', _renderMonth(entity.month, 'short'));
      }
      fragments.push('.');
    }

    if (entity.doi) {
      fragments.push(
        ' ',
        _renderDOI($$, entity.doi)
      );
    }

    return fragments
  }

  function conferencePaperRenderer ($$, entityId, entityDb, exporter) {
    let entity = entityDb.get(entityId);
    let fragments = [];

    if (entity.authors.length > 0) {
      fragments = fragments.concat(
        _renderAuthors($$, entity.authors, entityDb),
        '.'
      );
    }
    if (entity.title) {
      fragments.push(
        ' ',
        ...exporter.annotatedText([entity.id, 'title'], entityDb, $$),
        '. '
      );
    }

    if (entity.containerTitle) {
      fragments.push(' ', $$('i').append(entity.containerTitle), '.');
    }

    if (entity.confName && entity.confLoc) {
      fragments.push(' ', entity.confName, '; ', entity.confLoc, '.');
    } else if (entity.confName) {
      fragments.push(' ', entity.confName, '.');
    } else if (entity.confLoc) {
      fragments.push(' ', entity.confLoc, '.');
    }

    if (entity.year) {
      fragments.push(' ', entity.year);
      if (entity.month) {
        fragments.push(' ', _renderMonth(entity.month, 'short'));
      }
    }

    let contentLocation = _renderLocation($$, entity.fpage, entity.lpage, entity.pageRange, entity.elocationId);
    if (contentLocation) {
      fragments.push(', ', contentLocation, '.');
    } else {
      fragments.push('.');
    }

    if (entity.doi) {
      fragments.push(
        ' ',
        _renderDOI($$, entity.doi)
      );
    }
    return fragments
  }

  function softwareRenderer ($$, entityId, entityDb, exporter) {
    let entity = entityDb.get(entityId);
    let fragments = [];

    if (entity.authors.length > 0) {
      fragments = fragments.concat(
        ' ',
        _renderAuthors($$, entity.authors, entityDb),
        '.'
      );
    }
    if (entity.title) {
      fragments.push(
        ' ',
        ...exporter.annotatedText([entity.id, 'title'], entityDb, $$),
        '.'
      );
    }
    if (entity.version) {
      fragments.push(' Version ', entity.version);
    }
    fragments.push('.');

    fragments.push(_renderPublisherPlace($$, entity.publisherLoc, entity.publisherName));

    let date = _renderDate($$, entity.year, entity.month, entity.day, 'short');
    if (date) {
      fragments.push(' ', date, ';');
    }

    if (entity.doi) {
      fragments.push(
        ' ',
        _renderDOI($$, entity.doi)
      );
    }

    return fragments
  }

  function thesisRenderer ($$, entityId, entityDb, exporter) {
    let entity = entityDb.get(entityId);
    let fragments = [];

    if (entity.authors.length > 0) {
      fragments = fragments.concat(
        _renderAuthors($$, entity.authors, entityDb),
        '.'
      );
    }
    if (entity.title) {
      fragments.push(
        ' ',
        ...exporter.annotatedText([entity.id, 'title'], entityDb, $$),
        '. '
      );
    }

    fragments.push(_renderPublisherPlace($$, entity.publisherLoc, entity.publisherName));

    if (entity.year) {
      fragments.push(' ', entity.year);
      if (entity.month) {
        fragments.push(' ', _renderMonth(entity.month, 'short'));
      }
      fragments.push('.');
    }

    return fragments
  }

  function webpageRenderer ($$, entityId, entityDb, exporter) {
    let entity = entityDb.get(entityId);
    let fragments = [];

    if (entity.authors.length > 0) {
      fragments = fragments.concat(
        _renderAuthors($$, entity.authors, entityDb),
        '.'
      );
    }
    if (entity.title) {
      fragments.push(
        ' ',
        ...exporter.annotatedText([entity.id, 'title'], entityDb, $$),
        '. '
      );
    }

    if (entity.publisherLoc) {
      fragments.push(' ', entity.publisherLoc);
    }

    if (entity.uri) {
      fragments.push(
        ' ',
        $$('a').attr({
          href: entity.uri,
          target: '_blank'
        }).append(
          entity.uri
        )
      );
    }

    if (entity.year) {
      let dateFormatted = _renderDate($$, entity.year, entity.month, entity.day, 'long');
      fragments.push('. Accessed ', dateFormatted, '.');
    }

    return fragments
  }

  /* This is used for authors and editors */
  function personRenderer ($$, entityId, entityDb, options = {}) {
    let { prefix, suffix, givenNames, surname } = entityDb.get(entityId);
    if (options.short) {
      givenNames = _getInitials(givenNames);
    }
    let result = [];
    if (prefix) {
      result.push(prefix, ' ');
    }
    result.push(
      givenNames,
      ' ',
      surname
    );
    if (suffix) {
      result.push(' (', suffix, ')');
    }
    return result
  }

  function groupRenderer ($$, entityId, entityDb) {
    let { name } = entityDb.get(entityId);
    return [ name ]
  }

  // function personRenderer($$, entityId, entityDb, options = {}) {
  //   let { prefix, suffix, givenNames, surname } = entityDb.get(entityId)
  function refContribRenderer ($$, entityId, entityDb, options = {}) {
    let { givenNames, name } = entityDb.get(entityId);

    let result = [
      name
    ];

    if (givenNames) {
      if (options.short) {
        givenNames = _getInitials(givenNames);
      }

      result.push(
        ' ',
        givenNames
      );
    }
    return result
  }

  function organisationRenderer ($$, entityId, entityDb, options = {}) {
    let { name, country } = entityDb.get(entityId);
    let result = [ name ];
    if (!options.short) {
      if (country) {
        result.push(', ', country);
      }
    }
    return result
  }

  function awardRenderer ($$, entityId, entityDb, options = {}) {
    let { awardId, institution } = entityDb.get(entityId);
    let result = [ institution ];
    if (!options.short) {
      if (awardId) {
        result.push(', ', awardId);
      }
    }
    return result
  }

  function keywordRenderer ($$, entityId, entityDb, options = {}) {
    let { category, name } = entityDb.get(entityId);
    let result = [ name ];
    if (!options.short) {
      if (category) {
        result.push(', ', category);
      }
    }
    return result
  }

  function subjectRenderer ($$, entityId, entityDb, options = {}) {
    let { category, name } = entityDb.get(entityId);
    let result = [ name ];
    if (!options.short) {
      if (category) {
        result.push(', ', category);
      }
    }
    return result
  }

  /*
    Exports
  */
  var entityRenderers = {
    'article-ref': _delegate(articleRenderer),
    'person': _delegate(personRenderer),
    'group': _delegate(groupRenderer),
    'book-ref': _delegate(bookRenderer),
    'chapter-ref': _delegate(chapterRenderer),
    'journal-article-ref': _delegate(journalArticleRenderer),
    'conference-paper-ref': _delegate(conferencePaperRenderer),
    'report-ref': _delegate(reportRenderer),
    'organisation': _delegate(organisationRenderer),
    'award': _delegate(awardRenderer),
    'data-publication-ref': _delegate(dataPublicationRenderer),
    'magazine-article-ref': _delegate(magazineArticleRenderer),
    'newspaper-article-ref': _delegate(newspaperArticleRenderer),
    'software-ref': _delegate(softwareRenderer),
    'thesis-ref': _delegate(thesisRenderer),
    'webpage-ref': _delegate(webpageRenderer),
    'keyword': _delegate(keywordRenderer),
    'ref-contrib': _delegate(refContribRenderer),
    'patent-ref': _delegate(patentRenderer),
    'subject': _delegate(subjectRenderer)
  }

  /*
    Helpers
  */
  function _renderAuthors ($$, authors, entityDb) {
    let fragments = [];
    authors.forEach((refContribId, i) => {
      fragments = fragments.concat(
        refContribRenderer($$, refContribId, entityDb, { short: true })
      );
      if (i < authors.length - 1) {
        fragments.push(', ');
      }
    });
    return fragments
  }

  function _renderDate ($$, year, month, day, format) {
    if (year) {
      if (month) {
        if (day) {
          return year + ' ' + _renderMonth(month, format) + ' ' + day
        } else {
          return year + ' ' + _renderMonth(month, format)
        }
      } else {
        return year
      }
    }
  }

  function _renderMonth (month, format) {
    let monthNames;
    if (format === 'long') {
      monthNames = [null, 'January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
    } else {
      monthNames = [null, 'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
    }
    if (month) {
      return monthNames[month] || month
    }
  }

  function _renderDOI ($$, doi) {
    return $$('a').attr({
      href: `https://doi.org/${doi}`,
      target: '_blank'
    }).append(
      'https://doi.org/',
      doi
    )
  }

  function _renderLocation ($$, fpage, lpage, pageRange, elocationId) {
    if (pageRange) {
      // Give up to three page ranges, then use passim for more, see
      // https://www.ncbi.nlm.nih.gov/books/NBK7282/box/A33679/?report=objectonly
      let parts = pageRange.split(',');
      if (parts.length > 3) {
        return parts.slice(0, 3).join(',') + ' passim'
      } else {
        return pageRange
      }
    } else if (fpage) {
      if (lpage) {
        // Do not repeat page numbers unless they are followed by a letter
        // e.g. 211-218 => 211-8 but 211A-218A stays
        if (fpage.length === lpage.length && /^\d+$/.test(fpage) && /^\d+$/.test(lpage)) {
          let i;
          for (i = 0; i < fpage.length; i++) {
            if (fpage[i] !== lpage[i]) break
          }
          return fpage + '-' + lpage.substring(i)
        }
        return fpage + '-' + lpage
      } else {
        return fpage
      }
    } else if (elocationId) {
      return elocationId
    }
  }

  function _renderPublisherPlace ($$, place, publisher) {
    if (place && publisher) {
      return ' ' + place + ': ' + publisher + '; '
    } else if (place) {
      return ' ' + place + '; '
    } else if (publisher) {
      return ' ' + publisher + '; '
    } else {
      return ''
    }
  }

  function _getInitials (givenNames) {
    return givenNames.split(' ').map(part => {
      return part[0] ? part[0].toUpperCase() : ''
    }).join('')
  }

  function _delegate (fn) {
    return function (entityId, db, exporter, options) {
      let el = _createElement();
      let $$ = el.createElement.bind(el);
      let fragments = fn($$, entityId, db, exporter, options);
      el.append(fragments);
      return el.innerHTML
    }
  }

  function _createElement () {
    return substance.DefaultDOMElement.parseSnippet('<div>', 'html')
  }

  function renderEntity (entity, exporter, options = {}) {
    if (entity) {
      const type = entity.type;
      let renderer = entityRenderers[type];
      if (renderer) {
        let doc = entity.getDocument();
        return renderer(entity.id, doc, exporter, options)
      } else {
        console.error(`No renderer available for type '${type}'`);
      }
    }
    return ''
  }

  class AuthorsListComponent extends substance.Component {
    getInitialState () {
      let items = this._getItems();
      return {
        hidden: items.length === 0,
        edit: false
      }
    }

    _getItems () {
      return this.props.model.getItems()
    }

    render ($$) {
      const items = this._getItems();
      let el = $$('div').addClass(this.getClassNames());

      if (this.state.hidden) {
        el.addClass('sm-hidden');
        return el
      }

      if (this.state.edit) {
        var modal = $$(ModalDialog, {
          width: 'medium',
          textAlign: 'center'
        });
        el.append(modal);
      }

      let contentEl = $$('div').addClass('se-content');
      if (items.length > 0) {
        items.forEach((item, index) => {
          let short = item.type === 'organisation';
          contentEl.append(
            $$('span').addClass('se-contrib').html(
              // HACK: renderEntity needs a Node
              // TODO: we should have a model based helper instead
              renderEntity(item._node, { short })
            )
          );
          if (index < items.length - 1) {
            contentEl.append(', ');
          }
        });
      } else {
        contentEl.append(
          $$('span').addClass('se-contrib sm-empty').append(this.getEmptyMessage())
        );
      }

      el.append(
        contentEl
      );

      // FIXME: display affiliations
      // el.append(
      //   $$(AffiliationsListComponent, {
      //     node: this.props.node
      //   })
      // )
      return el
    }

    getClassNames () {
      return 'sc-authors-list'
    }

    getEmptyMessage () {
      return this.getLabel('no-authors')
    }
  }

  class NodeModelComponent extends substance.Component {
    didMount () {
      // EXPERIMENTAL: ExperimentalArticleValidator updates `node.id, @issues`
      const model = this.props.model;
      this.context.appState.addObserver(['document'], this._rerenderWhenIssueHaveChanged, this, {
        stage: 'render',
        document: {
          path: [model.id, '@issues']
        }
      });
    }

    dispose () {
      this.context.appState.removeObserver(this);
    }

    getInitialState () {
      return {
        fullMode: false
      }
    }

    render ($$) {
      const fullMode = this.state.fullMode;
      const model = this.props.model;
      // TODO: issues should be accessed via model, not directly
      const nodeIssues = model._node['@issues'];
      let hasIssues = (nodeIssues && nodeIssues.size > 0);

      const el = $$('div').addClass(this._getClassNames()).attr('data-id', model.id);

      // EXPERIMENTAL: highlight editors for nodes with issues
      if (hasIssues) {
        el.addClass('sm-warning');
      }

      el.append(this._renderHeader($$));

      let hasHiddenProps = false;
      const properties = this._getProperties();
      const propsLength = Object.keys(properties).length;
      const hiddenPropsLength = Object.keys(properties).reduce((total, key) => {
        if (!properties[key].isRequired() && properties[key].isEmpty()) {
          total++;
        }
        return total
      }, 0);
      const exposedPropsLength = propsLength - hiddenPropsLength;
      let fieldsLeft = CARD_MINIMUM_FIELDS - exposedPropsLength;
      for (let property of properties) {
        let hidden = !property.isRequired() && property.isEmpty();
        if (hidden && fieldsLeft > 0) {
          hidden = false;
          fieldsLeft--;
        }
        if (hidden) hasHiddenProps = true;
        if (fullMode || !hidden) {
          const PropertyEditor = this._getPropertyEditorClass(property);
          // skip this property if the editor implementation produces nil
          if (!PropertyEditor) continue
          let label;
          if (this._showLabelForProperty(property.name)) {
            label = this.getLabel(property.name);
          }
          const model = property.model;
          const issues = nodeIssues ? nodeIssues.get(property.name) : [];
          el.append(
            $$(FormRowComponent, {
              label,
              issues
            }).append(
              $$(PropertyEditor, {
                label,
                model
              }).ref(property.name)
            )
          );
        }
      }

      const controlEl = $$('div').addClass('se-control')
        .on('click', this._toggleMode);

      if (hasHiddenProps) {
        if (fullMode) {
          controlEl.append(
            $$(substance.FontAwesomeIcon, { icon: 'fa-chevron-up' }).addClass('se-icon'),
            this.getLabel('show-less-fields')
          );
        } else {
          controlEl.append(
            $$(substance.FontAwesomeIcon, { icon: 'fa-chevron-down' }).addClass('se-icon'),
            this.getLabel('show-more-fields')
          );
        }
      }

      const footer = $$('div').addClass('se-footer').append(
        controlEl
      );

      el.append(footer);

      return el
    }

    _getProperties () {
      return this.props.model.getProperties()
    }

    _getClassNames () {
      return `sc-node-model sm-${this.props.model.type}`
    }

    _renderHeader ($$) {
      // TODO: rethink this. IMO it is not possible to generalize this implementation.
      // Maybe it is better to just use the regular component and pass a prop to allow the component to render in a 'short' style
      const ModelPreviewComponent = this.getComponent('model-preview', true);
      const model = this.props.model;
      let header = $$('div').addClass('se-header');
      if (ModelPreviewComponent) {
        header.append(
          $$(ModelPreviewComponent, { model })
        );
      }
      return header
    }

    /*
      Can be overriden to specify for which properties, labels should be hidden.
    */
    _showLabelForProperty (prop) {
      return true
    }

    get isRemovable () {
      return true
    }

    _getPropertyEditorClass (property) {
      return this.getComponent(property.type)
    }

    _toggleMode () {
      const fullMode = this.state.fullMode;
      this.extendState({fullMode: !fullMode});
    }

    _rerenderWhenIssueHaveChanged () {
      // console.log('Rerendering NodeModelCompent after issues have changed', this.props.model.id)
      this.rerender();
    }
  }

  class LicenseEditor extends ValueComponent {
    render ($$) {
      const model = this.props.model;
      const value = model.getValue();
      let el = $$('div').addClass('sc-license-editor');

      const licenseSelector = $$('select').addClass('se-select')
        .ref('input')
        .on('change', this._setLicense);

      licenseSelector.append(
        $$('option').append(this.getLabel('select-license'))
      );

      LICENSES.forEach(l => {
        const option = $$('option').attr({value: l.id}).append(l.name);
        if (l.id === value) option.attr({selected: 'selected'});
        licenseSelector.append(option);
      });

      el.append(licenseSelector);

      return el
    }

    _setLicense () {
      const model = this.props.model;
      const input = this.refs.input;
      const value = input.getValue();
      model.setValue(value);
    }
  }

  class FigureMetadataComponent extends NodeModelComponent {
    _getClassNames () {
      return `sc-figure-metadata sc-node-model`
    }

    _renderHeader ($$) {
      const model = this.props.model;
      let header = $$('div').addClass('se-header');
      header.append(
        $$('div').addClass('se-label').text(model.getLabel())
      );
      return header
    }

    // overriding this to get spawn a special editor for the content
    _getPropertyEditorClass (property) {
      // skip 'label' here, as it is shown 'read-only' in the header instead
      if (property.name === 'label') {
        return null
      // special editor to pick license type
      } else if (property.name === 'license') {
        return LicenseEditor
      } else {
        return super._getPropertyEditorClass(property)
      }
    }

    _getProperties () {
      let model = this.props.model;
      let permission = model.getPermission();
      let properties = model.getProperties();
      properties = properties.filter(p => p.name !== 'permission');
      properties = properties.concat(permission.getProperties());
      return properties
    }

    _showLabelForProperty (prop) {
      // Don't render a label for content property to use up the full width
      if (prop === 'content') {
        return false
      }
      return true
    }

    get isRemovable () {
      return false
    }
  }

  class PreviewComponent extends substance.Component {
    getChildContext () {
      return {
        editable: false
      }
    }

    render ($$) {
      let id = this.props.id;
      let el = $$('div')
        .addClass('sc-preview')
        .attr({'data-id': id});

      if (this.props.thumbnail) {
        el.append(
          $$('div').addClass('se-thumbnail').append(
            this.props.thumbnail
          )
        );
      }

      el.append(
        $$('div').addClass('se-label').append(
          this.props.label
        ),
        // NOTE: description is passed in as HTML string
        $$('div').addClass('se-description').append(
          this.props.description
        )
      );
      return el
    }
  }

  function renderModelComponent (context, $$, props) {
    const model = props.model;
    if (!model) throw new Error("'props.model' is required")
    let ModelComponent$$1 = getComponentForModel(context, model);
    if (ModelComponent$$1) {
      // LEGACY
      props.node = model._node;
      return $$(ModelComponent$$1, props)
    } else {
      return $$('div')
    }
  }

  class FigureComponent extends substance.Component {
    didMount () {
      // HACK: while this is an idiomatic approach to updating, I don't like it because we just need this to receive updates for labels
      // which are propagated via node state
      // TODO: instead we should use a Component for the label which is binding itself to the state update
      let mode = this._getMode();
      if (mode !== METADATA_MODE) {
        this.context.appState.addObserver(['document'], this.rerender, this, { stage: 'render', document: { path: [this.props.model.id] } });
      }
    }

    dispose () {
      this.context.appState.removeObserver(this);
    }

    render ($$) {
      const model = this.props.model;
      let mode = this._getMode();

      // delegating to a implementation in case of 'metadata'
      if (mode === METADATA_MODE) {
        return $$(FigureMetadataComponent, { model }).ref('metadata')
      }

      let el = $$('div')
        // TODO: don't violate the 'sc-' contract
        .addClass('sc-' + model.type)
        .attr('data-id', model.id);
      el.addClass(`sm-${mode}`);

      // TODO: this component should listen to label updates
      let label = model.getLabel();
      let contentModel = model.getContent();
      let figureContent = renderModelComponent(this.context, $$, {
        model: contentModel
      }).ref('content').addClass('se-content');
      el.addClass(`sm-${contentModel.type}`);

      if (mode === PREVIEW_MODE) {
        // TODO: We could return the PreviewComponent directly.
        // However this yields an error we need to investigate.
        el.append(
          $$(PreviewComponent, {
            id: this.props.model.id,
            thumbnail: contentModel.type === 'graphic' ? figureContent : undefined,
            label
          })
        );
      } else {
        let labelEl = $$('div').addClass('se-label').text(label);
        el.append(labelEl);
        el.append(figureContent);
        el.append(
          renderModelComponent(this.context, $$, {
            model: model.getTitle(),
            label: this.getLabel('title')
          }).ref('title').addClass('se-title')
        );
        el.append(
          renderModelComponent(this.context, $$, {
            model: model.getCaption(),
            label: this.getLabel('caption')
          }).ref('caption').addClass('se-caption')
        );
      }

      return el
    }

    _getMode () {
      return this.props.mode || 'manuscript'
    }
  }

  class HeadingComponent extends TextNodeComponent {
    getTagName () {
      return 'h' + this.props.node.getLevel()
    }
  }

  class ManuscriptComponent extends substance.Component {
    render ($$) {
      const AuthorsListComponent = this.getComponent('authors-list');
      const SectionLabel = this.getComponent('section-label');
      const model = this.props.model;
      const frontModel = model.getPropertyValue('front');
      const bodyModel = model.getPropertyValue('body');
      const backModel = model.getPropertyValue('back');
      const titleModel = frontModel.getPropertyValue('title');
      const authorsModel = frontModel.getPropertyValue('authors');
      const abstractModel = frontModel.getPropertyValue('abstract');
      const footnotesModel = backModel.getPropertyValue('footnotes');
      const referencesModel = backModel.getPropertyValue('references');
      const TitleComponent = this._getPropertyComponent(titleModel);
      const AbstractComponent = this._getPropertyComponent(abstractModel);
      const BodyComponent = this._getPropertyComponent(bodyModel);
      const FootnotesListComponent = this._getPropertyComponent(footnotesModel);
      const ReferenceListComponent = this._getPropertyComponent(referencesModel);

      let el = $$('div').addClass('sc-manuscript').append(
        $$(SectionLabel, {label: 'title-label'}).addClass('sm-title'),
        $$(TitleComponent, {
          model: titleModel,
          placeholder: this.getLabel('title-placeholder')
        }).addClass('sm-title')
      );

      if (authorsModel.length > 0) {
        el.append(
          $$(SectionLabel, {label: 'authors-label'}).addClass('sm-authors'),
          $$(AuthorsListComponent, {
            model: authorsModel,
            placeholder: this.getLabel('authors-placeholder')
          })
        );
      }

      el.append(
        $$(SectionLabel, {label: 'abstract-label'}).addClass('sm-abstract'),
        $$(AbstractComponent, {
          model: abstractModel,
          placeholder: this.getLabel('abstract-placeholder')
        }).addClass('sm-abstract')
      );

      el.append(
        $$(SectionLabel, {label: 'body-label'}).addClass('sm-body'),
        $$(BodyComponent, {
          model: bodyModel,
          placeholder: this.getLabel('body-placeholder')
        }).addClass('sm-body')
      );

      if (footnotesModel.length > 0) {
        el.append(
          $$(SectionLabel, {label: 'footnotes-label'}).addClass('sm-footnotes'),
          $$(FootnotesListComponent, {
            model: footnotesModel
          })
        );
      }

      if (referencesModel.length > 0) {
        el.append(
          $$(SectionLabel, {label: 'references-label'}).addClass('sm-references'),
          $$(ReferenceListComponent, {
            model: referencesModel
          })
        );
      }

      return el
    }

    getClassNames () {
      return 'sc-manuscript'
    }

    _getPropertyComponent (property) {
      return this.getComponent(property.type)
    }
  }

  class UnsupportedNodeComponent extends substance.IsolatedNodeComponent {
    _getContentClass () {
      return UnsupportedContentComponent
    }
  }

  class UnsupportedContentComponent extends substance.Component {
    render ($$) {
      const node = this.props.node;
      let data;
      if (node._isXMLNode) {
        data = node.toXML().serialize();
      } else if (node.data) {
        data = node.data;
      } else {
        data = JSON.stringify(node.toJSON());
      }
      let el = $$('div').addClass('sc-unsupported').append(
        $$('pre').text(data)
      ).attr({
        'data-id': node.id,
        'contenteditable': false
      });

      return el
    }
  }

  class UnsupportedInlineNodeComponent extends substance.Component {
    render ($$) {
      const node = this.props.node;
      let data;
      if (node._isXMLNode) {
        data = node.toXML().serialize();
      } else if (node.data) {
        data = node.data;
      } else {
        data = JSON.stringify(node.toJSON());
      }
      let el = $$('span').addClass('sc-unsupported-inline-node').append(
        $$('code').text(data)
      ).attr({
        'data-id': node.id,
        contenteditable: false
      });
      return el
    }
  }

  class AffiliationsList extends NodeComponent {
    render ($$) {
      const api = this.context.api;
      const article = api.getArticle();

      let el = $$('div').addClass('sc-affiliations-list');
      let entityIds = this._getOrgansiations();

      let contentEl = $$('div').addClass('se-content');
      entityIds.forEach((entityId, index) => {
        let entity = article.get(entityId);
        contentEl.append(
          $$('span').addClass('se-affiliation').html(
            renderEntity(entity)
          )
        );
        if (index < entityIds.length - 1) {
          contentEl.append('; ');
        }
      });
      el.append(contentEl);
      return el
    }

    _getAuthors () {
      return this.props.node.findAll('contrib').map(contrib => contrib.getAttribute('rid'))
    }

    _getOrgansiations () {
      const api = this.context.api;
      const article = api.getArticle();

      let organisations = [];
      let authors = this._getAuthors();
      authors.forEach(authorId => {
        let author = article.get(authorId);
        if (!author) {
          console.error('FIXME: no entity for author', authorId);
        } else {
          // We only consider person records
          if (author.type === 'person') {
            organisations = organisations.concat(author.affiliations);
          }
        }
      });
      return substance.uniq(organisations)
    }
  }

  class BioComponent extends substance.Component {
    render ($$) {
      const node = this.props.node;

      let el = $$('div')
        .addClass('sc-bio')
        .attr('data-id', node.id);

      let contentEl = $$(this.getComponent('container'), {
        placeholder: 'Enter Bio',
        node: node
      });
      el.append(contentEl);
      return el
    }
  }

  class BreakComponent extends substance.Component {
    render ($$) {
      return $$('br')
    }
  }

  function updateEntityChildArray (tx, nodeId, tagName, attribute, oldEntityIds, newEntityIds) {
    let node = tx.get(nodeId);
    let addedEntityIds = substance.without(newEntityIds, ...oldEntityIds);
    let removedEntityIds = substance.without(oldEntityIds, ...newEntityIds);

    // Remove old entities
    removedEntityIds.forEach(entityId => {
      let entityRefNode = node.find(`${tagName}[${attribute}=${entityId}]`);
      node.removeChild(entityRefNode);
      // Remove it completely
      tx.delete(entityRefNode.id);
    });

    // Create new entities
    addedEntityIds.forEach(entityId => {
      let entityRefNode = node.find(`${tagName}[${attribute}=${entityId}]`);
      if (!entityRefNode) {
        let opts = {};
        if (attribute === 'id') {
          opts = { id: entityId };
        }
        entityRefNode = tx.createElement(tagName, opts);
        if (attribute !== 'id') {
          entityRefNode.setAttribute(attribute, entityId);
        }
      }
      node.appendChild(entityRefNode);
    });

    // Sort entities in order of newEntityIds array
    let map = {};
    let refs = tx.findAll(`${tagName}`);
    refs.forEach(ref => {
      const rid = ref.getAttribute('rid');
      map[rid] = ref;
    });
    node.children.forEach(child => {
      node.removeChild(child);
    });
    newEntityIds.forEach(entityId => {
      node.appendChild(map[entityId]);
    });

    tx.setSelection(null);
  }

  class ContribsListComponent extends NodeComponent {
    didMount () {
      super.didMount();
      this.handleActions({
        'done': this._doneEditing,
        'cancel': this._doneEditing,
        'closeModal': this._doneEditing,
        'entitiesSelected': this._updateContribs
      });
    }

    getInitialState () {
      let entityIds = this._getEntityIds();
      return {
        hidden: entityIds.length === 0,
        edit: false
      }
    }

    _getEntityIds () {
      return this.props.node.findAll('contrib').map(contrib => contrib.getAttribute('rid'))
    }

    render ($$) {
      const api = this.context.api;
      const article = api.getArticle();
      const entityIds = this._getEntityIds();
      let el = $$('div').addClass(this.getClassNames());

      if (this.state.hidden) {
        el.addClass('sm-hidden');
        return el
      }

      if (this.state.edit) {
        var modal = $$(ModalDialog, {
          width: 'medium',
          textAlign: 'center'
        });
        // modal.append(
        //   $$(EditRelationship, {
        //     propertyName: this.getPropertyName(),
        //     entityIds: this._getEntityIds(),
        //     targetTypes: this.getTargetTypes()
        //   })
        // )
        el.append(modal);
      }

      let contentEl = $$('div').addClass('se-content');
      if (entityIds.length > 0) {
        entityIds.forEach((entityId, index) => {
          let entity = article.get(entityId);
          if (!entity) {
            console.error('FIXME: no entity for contrib', entityId);
          } else {
            let short = entity.type === 'organisation';
            contentEl.append(
              $$('span').addClass('se-contrib').html(
                renderEntity(entity, { short })
              )
            );
            if (index < entityIds.length - 1) {
              contentEl.append(', ');
            }
          }
        });
      } else {
        contentEl.append(
          $$('span').addClass('se-contrib sm-empty').append('No Authors')
        );
      }

      contentEl.append(
        ' ',
        $$('button').append(
          $$(substance.FontAwesomeIcon, { icon: 'fa-pencil' })
        ).on('click', this._editContribs)
      );

      el.append(contentEl);

      el.append(
        $$(AffiliationsList, {
          node: this.props.node
        })
      );
      return el
    }

    _editContribs () {
      this.setState({
        edit: true
      });
    }

    _doneEditing () {
      this.setState({
        edit: false
      });
    }

    _updateContribs (entityIds) {
      let oldEntityIds = this._getEntityIds();
      let editorSession = this.context.editorSession;

      editorSession.transaction(tx => {
        updateEntityChildArray(tx, this.props.node.id, 'contrib', 'rid', oldEntityIds, entityIds);
        this._updateAffs(tx, entityIds);
      });

      this.setState({
        edit: false
      });
    }

    /*
      Creates new aff entries and removes old ones
    */
    _updateAffs (tx, contribIds) {
      const api = this.context.api;
      const article = api.getArticle();
      let editorSession = this.context.editorSession;
      let doc = editorSession.getDocument();
      let oldOrgIds = doc.findAll('aff-group > aff').map(a => a.attr('rid'));
      let newOrgIds = [];
      contribIds.forEach(contribId => {
        let entity = article.get(contribId);
        newOrgIds = newOrgIds.concat(entity.affiliations);
      });
      newOrgIds = substance.uniq(newOrgIds);

      let addedOrgIds = substance.without(newOrgIds, ...oldOrgIds);
      let removedOrgIds = substance.without(oldOrgIds, ...newOrgIds);
      let affGroupEl = tx.find('aff-group');

      // Remove no longer used aff records (mappings)
      removedOrgIds.forEach(entityId => {
        let affNode = affGroupEl.find(`aff[rid=${entityId}]`);
        affGroupEl.removeChild(affNode);
        // Remove it completely
        tx.delete(affNode.id);
      });

      // Create aff records (mappings)
      addedOrgIds.forEach(entityId => {
        let affNode = affGroupEl.find(`aff[rid=${entityId}]`);
        if (!affNode) {
          affNode = tx.createElement('aff', {id: substance.uuid('aff')});
          affNode.attr('rid', entityId);
        }
        affGroupEl.appendChild(affNode);
      });
    }
  }

  class EditorsListComponent extends ContribsListComponent {
    getClassNames () {
      return 'sc-authors-list'
    }

    getTargetTypes () {
      return ['person']
    }

    getPropertyName () {
      return 'editors'
    }

    getEmptyMessage () {
      return this.getLabel('no-editors')
    }
  }

  class ElementNodeComponent extends NodeComponent {
    render ($$) {
      let el = $$(this.getTagName())
        .addClass(this.getClassNames());
      this._getChildren().forEach(child => {
        el.append(
          $$(this.getComponent(child.type), {
            node: child
          }).ref(child.id)
        );
      });
      return el
    }

    _getChildren () {
      return this.props.node.getChildren()
    }

    getTagName () {
      return this.props.node.type
    }

    getClassNames () {
      return `sc-${this.props.node.type}`
    }
  }

  class ExtLinkComponent extends NodeComponentMixin(substance.AnnotationComponent) {
    render ($$) {
      let el = super.render($$);
      let node = this.props.node;
      el.tagName = 'a';
      el.attr('href', node.attr('xlink:href'));
      return el
    }
  }

  // TODO: turn this into a Model based component
  class CaptionComponent extends substance.Component {
    render ($$) {
      const node = this.props.node;
      let el = $$('div')
        .addClass('sc-caption')
        .attr('data-id', node.id);
      let contentEl = $$(this.getComponent('container'), {
        placeholder: 'Enter Caption',
        node: node,
        disabled: this.props.disabled
      });
      el.append(contentEl);
      return el
    }
  }

  // TODO: try to get rid of this by using a FlowContentModel
  class ContainerNodeComponent extends substance.Component {
    render ($$) {
      const node = this.props.node;
      const ContainerEditor = this.getComponent('container-editor');
      let el = $$('div')
        // TODO: don't violate the 'sc-' contract
        .addClass('sc-' + node.type)
        .attr('data-id', node.id);
      el.append($$(ContainerEditor, {
        placeholder: this.props.placeholder,
        name: this.props.name,
        containerId: node.id,
        disabled: this.props.disabled
      }).ref('container'));
      // TODO: ability to edit attributes
      return el
    }
  }

  class DispQuoteComponent extends substance.Component {
    render ($$) {
      let model = this.props.model;
      const contentValueModel = model.getPropertyValue('content');
      const attribValueModel = model.getPropertyValue('attrib');
      const ContentEditor = this.getComponent(contentValueModel.type);
      const AttribEditor = this.getComponent(attribValueModel.type);

      let el = $$('div')
        .addClass('sc-disp-quote')
        .attr('data-id', model.id);

      el.append(
        $$(ContentEditor, {
          model: contentValueModel,
          placeholder: 'Enter attribution'
        })
      );

      el.append(
        $$(AttribEditor, {
          model: attribValueModel,
          placeholder: 'Enter attribution'
        })
      );
      return el
    }
  }

  class FootnoteComponent extends substance.Component {
    render ($$) {
      const node = this.props.node;
      const mode = this.props.mode;
      const model = this.props.model;
      const Container = this.getComponent('container');

      let el = $$('div')
        .addClass('sc-footnote')
        .attr('data-id', node.id);

      let label = getLabel(node) || '?';

      if (mode === PREVIEW_MODE) {
        el.append(
          $$(PreviewComponent, {
            id: model.id,
            label: label,
            description: $$(Container, {
              node: node,
              disabled: true,
              editable: false
            })
          })
        );
      } else {
        let fnContainer = $$('div').addClass('se-container');
        el.append(
          fnContainer.append(
            $$('div').addClass('se-label').append(
              label
            ),
            $$(Container, {
              placeholder: 'Enter Footnote',
              node: node,
              disabled: this.props.disabled
            }).ref('editor')
          )
        );
      }
      return el
    }
  }

  class GraphicComponent extends NodeComponent {
    render ($$) {
      const node = this.props.node;
      let url = node.getAttribute('xlink:href');
      let urlResolver = this.context.urlResolver;
      if (urlResolver) {
        url = urlResolver.resolveUrl(url);
      }
      let el = $$('div')
        .addClass('sc-graphic')
        .attr('data-id', node.id);

      if (this.state.errored) {
        el.append(
          $$('div').addClass('se-error').append(
            this.context.iconProvider.renderIcon($$, 'graphic-load-error').addClass('se-icon'),
            this.getLabel('graphic-load-error')
          )
        );
        return el
      }

      el.append(
        $$('img').attr({src: url}).ref('image')
          .on('error', this._onLoadError)
      );
      return el
    }

    _onLoadError () {
      this.extendState({errored: true});
    }
  }

  class TexMathComponent extends NodeComponent {
    render ($$) {
      const node = this.props.node;
      const texMath = node.textContent;
      const el = $$('span').addClass('sc-math');
      if (!texMath) {
        el.append('???');
      } else {
        try {
          el.append(
            $$('span').html(katex.renderToString(texMath))
          );
          let blockerEl = $$('div').addClass('se-blocker');
          el.append(blockerEl);
        } catch (error) {
          el.addClass('sm-error')
            .text(error.message);
        }
      }
      return el
    }
  }

  // TODO: introduce an InlineFormulaModel
  class InlineFormulaComponent extends NodeComponent {
    render ($$) {
      const node = this.props.node;
      const texMath = node.find('tex-math');
      const el = $$('span').addClass('sc-inline-formula');
      el.append(
        $$(TexMathComponent, {
          node: texMath
        }).ref('math')
      );
      if (this.props.isolatedNodeState) {
        el.addClass('sm-' + this.props.isolatedNodeState);
      }
      return el
    }
  }

  class ListComponent extends NodeComponent {
    render ($$) {
      const ListItemComponent = this.getComponent('list-item');
      let node = this.props.node;
      let el = substance.renderListNode(node, (item) => {
        // item is either a list item node, or a tagName
        if (substance.isString(item)) {
          return $$(item)
        } else if (item.type === 'list-item') {
          return $$(ListItemComponent, {
            node: item
          }).ref(item.id)
        }
      });
      el.addClass('sc-list').attr('data-id', node.id);
      return el
    }

    // we need this ATM to prevent this being wrapped into an isolated node (see ContainerEditor._renderNode())
    get _isCustomNodeComponent () { return true }
  }

  class ListItemComponent extends NodeComponent {
    render ($$) {
      const TextPropertyComponent = this.getComponent('text-property');
      const node = this.props.node;
      const path = node.getPath();
      let el = $$('li').addClass('sc-list-item');
      el.append(
        $$(TextPropertyComponent, {
          path,
          doc: node.getDocument()
        }).ref('text')
      );
      // for nested lists
      if (this.props.children) {
        el.append(this.props.children);
      }
      return el
    }
  }

  class ReferenceComponent extends NodeComponent {
    render ($$) {
      const refNode = this.getNode();
      let label = _getReferenceLabel(refNode);
      let html = this.context.api.renderEntity(refNode);
      // TODO: do we want to display something like this
      // if so, use the label provider
      html = html || '<i>Not available</i>';
      if (this.props.mode === PREVIEW_MODE) {
        // NOTE: We return PreviewComponent directly, to prevent inheriting styles from .sc-reference
        return $$(PreviewComponent, {
          id: this.props.model.id,
          label: label,
          description: $$('div').html(html)
        })
      } else {
        let el = $$('div').addClass('sc-reference');
        el.append(
          $$('div').addClass('se-label').append(label),
          $$('div').addClass('se-text').html(html)
        ).attr('data-id', refNode.id);
        return el
      }
    }
  }

  function _getReferenceLabel (refNode) {
    if (refNode.state && refNode.state.label) {
      return refNode.state.label
    }
    return '?'
  }

  class SigBlockComponent extends NodeComponent {
    render ($$) {
      const sigBlock = this.props.node;

      let el = $$('div').addClass('sc-sig-block');
      el.append($$(this.getComponent('separator'), {
        label: 'sig-block-start'
      }));

      let sigs = sigBlock.findAll('sig');

      sigs.forEach((sig) => {
        el.append($$(this.getComponent('container'), {
          node: sig,
          disabled: this.props.disabled
        })).ref(sig.id);
      });

      el.append($$(this.getComponent('separator'), {
        label: 'sig-block-start'
      }));

      return el
    }
  }

  function createTableSelection (data) {
    if (!data.anchorCellId || !data.focusCellId) throw new Error('Invalid selection data')
    return {
      type: 'custom',
      customType: 'table',
      data: data
    }
  }

  function getSelectionData (sel) {
    if (sel && sel.customType === 'table') {
      return sel.data
    }
    return {}
  }

  function getSelectedRange (table, selData) {
    return getCellRange(table, selData.anchorCellId, selData.focusCellId)
  }

  function computeSelectionRectangle (ulRect, lrRect) {
    let selRect = {};
    selRect.top = ulRect.top;
    selRect.left = ulRect.left;
    selRect.width = lrRect.left + lrRect.width - selRect.left;
    selRect.height = lrRect.top + lrRect.height - selRect.top;
    return selRect
  }

  function getCellRange (table, anchorCellId, focusCellId) {
    let anchorCell = table.get(anchorCellId);
    let focusCell = table.get(focusCellId);
    let startRow = Math.min(anchorCell.rowIdx, focusCell.rowIdx);
    let startCol = Math.min(anchorCell.colIdx, focusCell.colIdx);
    let endRow = Math.max(anchorCell.rowIdx + anchorCell.rowspan - 1, focusCell.rowIdx + focusCell.rowspan - 1);
    let endCol = Math.max(anchorCell.colIdx + anchorCell.colspan - 1, focusCell.colIdx + focusCell.colspan - 1);
    return { startRow, startCol, endRow, endCol }
  }

  function computeUpdatedSelection (table, selData, dr, dc, expand) {
    let focusCellId = selData.focusCellId;
    let focusCell = table.get(focusCellId);
    let rowIdx = focusCell.rowIdx;
    let colIdx = focusCell.colIdx;
    let rowspan = focusCell.rowspan;
    let colspan = focusCell.colspan;
    let newFocusCell;
    if (dr) {
      if (dr < 0) {
        newFocusCell = table.getCell(rowIdx + dr, colIdx);
      } else if (dr > 0) {
        newFocusCell = table.getCell(rowIdx + rowspan - 1 + dr, colIdx);
      }
    } else if (dc) {
      if (dc < 0) {
        newFocusCell = table.getCell(rowIdx, colIdx + dc);
      } else if (dc > 0) {
        newFocusCell = table.getCell(rowIdx, colIdx + colspan - 1 + dc);
      }
    }
    if (newFocusCell) {
      if (newFocusCell.shadowed) newFocusCell = newFocusCell.masterCell;
      let newFocusCellId = newFocusCell.id;
      let newAnchorCellId = selData.anchorCellId;
      if (!expand) {
        newAnchorCellId = newFocusCellId;
      }
      return {
        anchorCellId: newAnchorCellId,
        focusCellId: newFocusCellId
      }
    } else {
      return selData
    }
  }

  function generateTable (doc, nrows, ncols, tableId) {
    let $$ = doc.createElement.bind(doc);
    tableId = tableId || substance.uuid('table');
    let table = $$('table', { id: tableId });
    let headRow = $$('table-row', { id: `${tableId}-h` });
    for (let j = 0; j < ncols; j++) {
      headRow.append(
        $$('table-cell', { id: `${tableId}-h-${j + 1}` })
          .attr('heading', true)
          .text(substance.tableHelpers.getColumnLabel(j))
      );
    }
    table.append(headRow);
    for (let i = 0; i < nrows; i++) {
      let row = $$('table-row', { id: `${tableId}-${i + 1}` });
      for (let j = 0; j < ncols; j++) {
        row.append($$('table-cell', { id: `${tableId}-${i + 1}-${j + 1}` }).text(''));
      }
      table.append(row);
    }
    return table
  }

  const { getRangeFromMatrix } = substance.tableHelpers;

  var tableHelpers = /*#__PURE__*/Object.freeze({
    createTableSelection: createTableSelection,
    getSelectionData: getSelectionData,
    getSelectedRange: getSelectedRange,
    computeSelectionRectangle: computeSelectionRectangle,
    getCellRange: getCellRange,
    computeUpdatedSelection: computeUpdatedSelection,
    generateTable: generateTable,
    getRangeFromMatrix: getRangeFromMatrix
  });

  class TableCellEditor extends TextPropertyEditorNew {
    _handleEscapeKey (event) {
      this.__handleKey(event, 'escape');
    }

    _handleEnterKey (event) {
      this.__handleKey(event, 'enter');
    }

    _handleTabKey (event) {
      this.__handleKey(event, 'tab');
    }

    __handleKey (event, name) {
      event.stopPropagation();
      event.preventDefault();
      this.el.emit(name, {
        altKey: event.altKey,
        ctrlKey: event.ctrlKey,
        metaKey: event.metaKey,
        shiftKey: event.shiftKey,
        code: event.code
      });
    }
  }

  class TableCellComponent extends NodeComponent {
    render ($$) {
      const cell = this.props.node;
      let el = $$(cell.attr('heading') ? 'th' : 'td');
      el.addClass('sc-table-cell');
      let attributes = {
        id: cell.id,
        'data-row-idx': cell.rowIdx,
        'data-col-idx': cell.colIdx,
        rowspan: cell.rowspan,
        colspan: cell.colspan
      };
      el.attr(attributes);
      el.append(
        $$(TableCellEditor, {
          path: cell.getPath(),
          disabled: this.props.disabled,
          multiLine: true
        }).ref(cell.id)
      );
      return el
    }
  }

  class TableContextMenu extends ToolPanel {
    getEntryTypeComponents () {
      return Object.assign({}, super.getEntryTypeComponents(), {
        'tool-group': this.getComponent('menu-group'),
        'tool-dropdown': this.getComponent('menu-group')
      })
    }

    render ($$) {
      let el = $$('div').addClass('sc-table-context-menu sc-context-menu');
      el.append(this.renderEntries($$));
      return el
    }
  }

  class TableComponent extends substance.CustomSurface {
    constructor (...args) {
      super(...args);

      this._selectionData = {};
      this._clipboard = new ClipboardNew();
    }

    getChildContext () {
      return {
        surface: this,
        parentSurfaceId: this.getId(),
        // HACK: nulling this so that nested surfaces get an id that are relative to
        // this surface instead of the isolatedNodeComponent
        isolatedNodeComponent: null
      }
    }

    shouldRerender (newProps) {
      return (newProps.node !== this.props.node || newProps.disabled !== this.props.disabled)
    }

    didMount () {
      super.didMount();

      this._tableSha = this.props.node._getSha();
      const appState = this.context.appState;

      appState.addObserver(['document'], this._onDocumentChange, this, { stage: 'render' });
      appState.addObserver(['selection'], this._onSelectionChange, this, { stage: 'render' });

      this._positionSelection(this._getSelectionData());
    }

    dispose () {
      super.dispose();

      const appState = this.context.appState;
      appState.off(this);
    }

    render ($$) {
      let el = $$('div').addClass('sc-table');
      el.on('mousedown', this._onMousedown)
        .on('mouseup', this._onMouseup)
        .on('click', this._prevent);
      el.append(this._renderTable($$));
      el.append(this._renderKeyTrap($$));
      el.append(this._renderUnclickableOverlays($$));
      // el.append(this._renderClickableOverlays($$))
      el.append(this._renderContextMenu($$));
      return el
    }

    _renderTable ($$) {
      let table = $$('table').ref('table');
      let node = this.props.node;
      let matrix = node.getCellMatrix();
      for (let i = 0; i < matrix.length; i++) {
        let cells = matrix[i];
        let tr = $$('tr');
        for (let j = 0; j < cells.length; j++) {
          if (cells[j].shadowed) continue
          let cell = cells[j];
          tr.append(
            $$(TableCellComponent, { node: cell, disabled: true })
              .ref(cell.id)
              .on('enter', this._onCellEnter)
              .on('tab', this._onCellTab)
              .on('escape', this._onCellEscape)
          );
        }
        table.append(tr);
      }
      table.on('mousemove', this._onMousemove)
        .on('dblclick', this._onDblclick)
        .on('contextmenu', this._onContextMenu)
        .on('contextmenuitemclick', this._onContextmenuitemclick);
      return table
    }

    _renderKeyTrap ($$) {
      return $$('textarea').addClass('se-keytrap').ref('keytrap')
        .css({ position: 'absolute', width: 0, height: 0, opacity: 0 })
        .on('keydown', this._onKeydown)
        .on('input', this._onInput)
        .on('copy', this._onCopy)
        .on('paste', this._onPaste)
        .on('cut', this._onCut)
    }

    _renderUnclickableOverlays ($$) {
      let el = $$('div').addClass('se-unclickable-overlays');
      el.append(
        this._renderSelectionOverlay($$)
      );
      el.append(
        this.props.unclickableOverlays
      );
      return el
    }

    _renderSelectionOverlay ($$) {
      let el = $$('div').addClass('se-selection-overlay');
      el.append(
        $$('div').addClass('se-selection-anchor').ref('selAnchor').css('visibility', 'hidden'),
        $$('div').addClass('se-selection-range').ref('selRange').css('visibility', 'hidden')
      );
      return el
    }

    _renderContextMenu ($$) {
      const configurator = this.context.configurator;
      let contextMenu;
      const toolPanel = configurator.getToolPanel('table-context-menu');
      if (toolPanel) {
        contextMenu = $$(Managed(TableContextMenu), {
          toolPanel: configurator.getToolPanel('table-context-menu'),
          bindings: ['commandStates']
        });
      } else {
        contextMenu = $$('div');
      }
      contextMenu.ref('contextMenu')
        .addClass('se-context-menu')
        .css({ display: 'none' });
      return contextMenu
    }

    _onDocumentChange () {
      const table = this.props.node;
      // Note: using a simplified way to detect when a table
      // has changed structurally
      // TableElementNode is detecting such changes and
      // updates an internal 'sha' that we can compare against
      if (table._hasShaChanged(this._tableSha)) {
        this.rerender();
        this._tableSha = table._getSha();
      }
    }

    _onSelectionChange () {
      const doc = this.context.editorSession.getDocument();
      const sel = this.context.appState.selection;
      const self = this;
      if (!sel || sel.isNull()) {
        _disableActiveCell();
        this._hideSelection();
      } else if (sel.isPropertySelection()) {
        let nodeId = sel.path[0];
        if (this._activeCell !== nodeId) {
          _disableActiveCell();
          let newCellEditor = this.refs[nodeId];
          if (newCellEditor) {
            // console.log('ENABLING CELL EDITOR', nodeId)
            newCellEditor.extendProps({ disabled: false });
            this._activeCell = nodeId;
          }
        }
        if (this._activeCell) {
          // TODO: this could be simplified
          let cell = doc.get(this._activeCell);
          this._positionSelection({
            type: 'range',
            anchorCellId: cell.id,
            focusCellId: cell.id
          }, true);
        } else {
          this._hideSelection();
        }
      } else if (sel.surfaceId !== this.getId()) {
        _disableActiveCell();
        this._hideSelection();
      } else {
        _disableActiveCell();
      }
      this._hideContextMenu();

      function _disableActiveCell () {
        const activeCellId = self._activeCell;
        if (activeCellId) {
          let cellEditor = self.refs[activeCellId];
          if (cellEditor) {
            // console.log('DISABLING CELL EDITOR', activeCellId)
            cellEditor.extendProps({ disabled: true });
          }
          self._activeCell = null;
        }
      }
    }

    _onMousedown (e) {
      // console.log('TableComponent._onMousedown()')
      e.stopPropagation();
      // TODO: do not update the selection if right-clicked and already having a selection
      if (substance.platform.inBrowser) {
        substance.DefaultDOMElement.wrap(window.document).on('mouseup', this._onMouseup, this, {
          once: true
        });
      }
      // console.log('_onMousedown', e)
      let selData = this._selectionData;
      if (!selData) selData = this._selectionData = {};
      let target = this._getClickTargetForEvent(e);
      // console.log('target', target)
      if (!target) return

      let isRightButton = substance.domHelpers.isRightButton(e);
      if (isRightButton) {
        // console.log('IS RIGHT BUTTON')
        // this will be handled by onContextMenu
        if (target.type === 'cell') {
          let targetCell = this.props.node.get(target.id);
          let _needSetSelection = true;
          let _selData = this._getSelectionData();
          if (_selData && targetCell) {
            let { startRow, startCol, endRow, endCol } = getCellRange(this.props.node, _selData.anchorCellId, _selData.focusCellId);
            _needSetSelection = (
              targetCell.colIdx < startCol || targetCell.colIdx > endCol ||
              targetCell.rowIdx < startRow || targetCell.rowIdx > endRow
            );
          }
          if (_needSetSelection) {
            this._isSelecting = true;
            selData.anchorCellId = target.id;
            selData.focusCellId = target.id;
            this._requestSelectionChange(this._createTableSelection(selData));
          }
        }
        return
      }
      if (target.type === 'cell') {
        this._isSelecting = true;
        selData.focusCellId = target.id;
        if (!e.shiftKey) {
          selData.anchorCellId = target.id;
        }
        e.preventDefault();
        this._requestSelectionChange(this._createTableSelection(selData));
      }
    }

    _onMouseup (e) {
      e.stopPropagation();
      if (this._isSelecting) {
        e.preventDefault();
        this._isSelecting = false;
      }
    }

    _onMousemove (e) {
      if (this._isSelecting) {
        const selData = this._selectionData;
        let cellId = this._mapClientXYToCellId(e.clientX, e.clientY);
        if (cellId !== selData.focusCellId) {
          selData.focusCellId = cellId;
          this._requestSelectionChange(this._createTableSelection(selData));
        }
      }
    }

    _onDblclick (e) {
      e.preventDefault();
      e.stopPropagation();
      this._requestEditCell();
    }

    _onKeydown (e) {
      let handled = false;
      switch (e.keyCode) {
        case substance.keys.LEFT:
          this._nav(0, -1, e.shiftKey);
          handled = true;
          break
        case substance.keys.RIGHT:
          this._nav(0, 1, e.shiftKey);
          handled = true;
          break
        case substance.keys.UP:
          this._nav(-1, 0, e.shiftKey);
          handled = true;
          break
        case substance.keys.DOWN:
          this._nav(1, 0, e.shiftKey);
          handled = true;
          break
        case substance.keys.ENTER: {
          this._requestEditCell();
          handled = true;
          break
        }
        case substance.keys.TAB: {
          this._nav(0, 1);
          handled = true;
          break
        }
        case substance.keys.DELETE:
        case substance.keys.BACKSPACE: {
          this._clearSelection();
          handled = true;
          break
        }
        default:
          //
      }
      // let an optional keyboard manager handle the key
      if (!handled) {
        const keyboardManager = this.context.keyboardManager;
        if (keyboardManager) {
          handled = keyboardManager.onKeydown(e);
        }
      }
      if (handled) {
        e.preventDefault();
        e.stopPropagation();
      }
    }

    /*
      Type into cell (replacing the existing content)
    */
    _onInput () {
      const value = this.refs.keytrap.val();
      this._requestEditCell(value);
      // Clear keytrap after sending an action
      this.refs.keytrap.val('');
    }

    _onCellEnter (e) {
      e.stopPropagation();
      e.preventDefault();
      let cellEl = substance.DefaultDOMElement.wrap(e.target).getParent();
      if (e.detail.shiftKey) {
        this.context.api.getTableAPI().insertSoftBreak();
      } else {
        this._nav(1, 0, false, { anchorCellId: cellEl.id, focusCellId: cellEl.id });
      }
    }

    _onCellTab (e) {
      e.stopPropagation();
      e.preventDefault();
      let cellEl = substance.DefaultDOMElement.wrap(e.target).getParent();
      this._nav(0, 1, false, { anchorCellId: cellEl.id, focusCellId: cellEl.id });
    }

    _onCellEscape (e) {
      e.stopPropagation();
      e.preventDefault();
      let cellEl = substance.DefaultDOMElement.wrap(e.target).getParent();
      this._requestSelectionChange(this._createTableSelection({ anchorCellId: cellEl.id, focusCellId: cellEl.id }));
    }

    _onCopy (e) {
      e.preventDefault();
      e.stopPropagation();
      let clipboardData = e.clipboardData;
      this._clipboard.copy(clipboardData, this.context);
    }

    _onCut (e) {
      e.preventDefault();
      e.stopPropagation();
      let clipboardData = e.clipboardData;
      this._clipboard.cut(clipboardData, this.context);
    }

    _onPaste (e) {
      e.preventDefault();
      e.stopPropagation();
      let clipboardData = e.clipboardData;
      // TODO: allow to force plain-text paste
      this._clipboard.paste(clipboardData, this.context);
    }

    _onContextMenu (e) {
      e.preventDefault();
      e.stopPropagation();
      this._showContextMenu(e);
    }

    _onContextmenuitemclick (e) {
      e.preventDefault();
      e.stopPropagation();
      this._hideContextMenu();
    }

    _getSelection () {
      return this.context.editorSession.getSelection()
    }

    _getSelectionData () {
      let sel = this._getSelection();
      if (sel && sel.surfaceId === this.getId()) {
        return sel.data
      }
    }

    _requestEditCell (initialValue) {
      let selData = this._getSelectionData();
      if (selData) {
        // type over cell
        if (initialValue) {
          // TODO: is there a more common action to describe this?
          // seems that this is like 'typing'
          // Otherwise it is only setting the selection
          this._getTableApi().insertText(initialValue);
        } else {
          // TODO: do we have a general API to set the selection
          // into a specific editor?
          const doc = this.props.node.getDocument();
          let cell = doc.get(selData.anchorCellId);
          let path = cell.getPath();
          // TODO: we need low-level API to set the selection
          this.context.api._setSelection({
            type: 'property',
            path,
            startOffset: cell.getLength(),
            surfaceId: this.getId() + '/' + path.join('.')
          });
        }
      }
    }

    _requestSelectionChange (newSel) {
      // console.log('requesting selection change', newSel)
      this.context.editorSession.setSelection(newSel);
    }

    _getClickTargetForEvent (e) {
      let target = substance.DefaultDOMElement.wrap(e.target);
      let cellEl = substance.domHelpers.findParent(target, 'td,th');
      if (cellEl) {
        return { type: 'cell', id: cellEl.id }
      }
    }

    _getRowCol (cellEl) {
      let rowIdx = parseInt(cellEl.getAttribute('data-row-idx'), 10);
      let colIdx = parseInt(cellEl.getAttribute('data-col-idx'), 10);
      return [rowIdx, colIdx]
    }

    _mapClientXYToCellId (x, y) {
      // TODO: this could be optimized using bisect search
      let cellEls = this.refs.table.el.findAll('th,td');
      for (let i = 0; i < cellEls.length; i++) {
        let cellEl = cellEls[i];
        let rect = substance.domHelpers.getBoundingRect(cellEl);
        if (substance.domHelpers.isXInside(x, rect) && substance.domHelpers.isYInside(y, rect)) {
          return cellEl.id
        }
      }
    }

    _nav (dr, dc, expand, selData) {
      selData = selData || this._getSelectionData();
      if (selData) {
        let newSelData = computeUpdatedSelection(this.props.node, selData, dr, dc, expand);
        this._requestSelectionChange(this._createTableSelection(newSelData));
      }
    }

    _getCustomResourceId () {
      return this.props.node.id
    }

    _clearSelection () {
      let selData = this._getSelectionData();
      if (selData) {
        this._getTableApi().deleteSelection();
      }
    }

    rerenderDOMSelection () {
      // console.log('SheetComponent.rerenderDOMSelection()')
      this._positionSelection(this._getSelectionData());
      // // put the native focus into the keytrap so that we
      // // receive keyboard events
      this.refs.keytrap.el.focus({ preventScroll: true });
    }

    _positionSelection (selData, focused) {
      // TODO: find a better criteria for integrity checking
      if (!selData) {
        this._hideSelection();
        return
      }
      let { anchorCellId, focusCellId } = selData;

      let anchorCellComp = this._getActualCellComp(anchorCellId);
      let anchorRect = substance.getRelativeBoundingRect(anchorCellComp.el, this.el);
      this.refs.selAnchor.css(this._getStylesForRectangle(anchorRect));

      if (!focused) {
        let rangeRect;
        if (focusCellId === anchorCellId) {
          rangeRect = anchorRect;
        } else {
          let focusCellComp = this._getActualCellComp(focusCellId);
          let focusRect = substance.getRelativeBoundingRect(focusCellComp.el, this.el);
          rangeRect = substance.domHelpers.getBoundingRectForRects(anchorRect, focusRect);
        }
        this.refs.selRange.css(this._getStylesForRectangle(rangeRect));
      } else {
        this.refs.selRange.css('visibility', 'hidden');
      }
    }

    _getActualCellComp (cellId) {
      let table = this.props.node;
      let cell = table.get(cellId);
      if (cell.shadowed) cell = cell.masterCell;
      return this.refs[cell.id]
    }

    _hideSelection () {
      this.refs.selAnchor.css('visibility', 'hidden');
      this.refs.selRange.css('visibility', 'hidden');
    }

    _hideContextMenu () {
      this.refs.contextMenu.addClass('sm-hidden');
    }

    _showContextMenu (e) {
      let contextMenu = this.refs.contextMenu;
      let offset = this.el.getOffset();
      contextMenu.css({
        display: 'block',
        top: e.clientY - offset.top,
        left: e.clientX - offset.left
      });
      contextMenu.removeClass('sm-hidden');
    }

    _getStylesForRectangle (rect) {
      let styles = { visibility: 'hidden' };
      if (rect) {
        Object.assign(styles, rect);
        if (isFinite(rect.top) && isFinite(rect.left) &&
          isFinite(rect.width) && isFinite(rect.height)) {
          styles.visibility = 'visible';
        }
      }
      return styles
    }

    _createTableSelection (selData) {
      let sel = createTableSelection(selData);
      sel.data.nodeId = this.props.node.id;
      sel.surfaceId = this.getId();
      return sel
    }

    _getTableApi () {
      return this.context.api.getTableAPI()
    }

    _prevent (event) {
      event.stopPropagation();
      event.preventDefault();
    }
  }

  class XrefComponent extends NodeComponent {
    render ($$) {
      let node = this.props.node;
      let refType = node.getAttribute('ref-type');
      let label = getXrefLabel(node);
      return $$('span').addClass('sc-xref sm-' + refType).append(label)
    }
  }

  class ModelPreviewComponent extends ModelComponent {
    render ($$) {
      // TODO: rethink this. IMO rendering should not be part of the Article API
      // Either it could be part of the general Model API, i.e. model.previewHtml()
      // or we could use some kind of configurable renderer, very much like a converter
      let model = this.props.model;
      let api = this.context.api;
      let el = $$('div').addClass('sc-model-preview');
      el.html(
        api.renderEntity(model)
      );
      return el
    }
  }

  class SectionLabel extends substance.Component {
    render ($$) {
      const label = this.props.label;
      return $$('div').addClass('sc-section-label')
        .append(this.getLabel(label))
    }
  }

  var ManuscriptContentPackage = {
    name: 'manuscript-content',
    configure (config) {
      config.addComponent('authors-list', AuthorsListComponent);
      config.addComponent('back-matter', CompositeComponent);
      config.addComponent('bibr', ReferenceComponent);
      config.addComponent('figure', FigureComponent);
      config.addComponent('heading', HeadingComponent);
      config.addComponent('manuscript', ManuscriptComponent);
      config.addComponent('table-figure', FigureComponent);
      config.addComponent('unsupported', UnsupportedNodeComponent);
      config.addComponent('unsupported-inline-node', UnsupportedInlineNodeComponent);

      config.addComponent('entity', NodeModelComponent);
      config.addComponent('affiliations-list', AffiliationsList);
      config.addComponent('editors-list', EditorsListComponent);
      config.addComponent('bio', BioComponent);
      config.addComponent('break', BreakComponent);
      config.addComponent('caption', CaptionComponent);
      config.addComponent('container', ContainerNodeComponent);
      config.addComponent('col', ElementNodeComponent);
      config.addComponent('colgroup', ElementNodeComponent);
      config.addComponent('disp-quote', DispQuoteComponent);
      config.addComponent('fn', FootnoteComponent);
      config.addComponent('graphic', GraphicComponent);
      config.addComponent('inline-formula', InlineFormulaComponent);
      config.addComponent('list', ListComponent);
      config.addComponent('list-item', ListItemComponent);
      config.addComponent('sig-block', SigBlockComponent);
      config.addComponent('table', TableComponent);
      config.addComponent('xref', XrefComponent);

      config.addComponent('model-preview', ModelPreviewComponent);

      // ATTENTION: I have changed the behavior so that
      // unregistered annotations or inline-nodes are
      // rendered using the UnsupportedInlineNodeComponent
      // instead of rendering all by default with AnnotationComponent
      config.addComponent('bold', substance.AnnotationComponent);
      config.addComponent('italic', substance.AnnotationComponent);
      config.addComponent('sub', substance.AnnotationComponent);
      config.addComponent('sup', substance.AnnotationComponent);
      config.addComponent('monospace', substance.AnnotationComponent);
      config.addComponent('ext-link', ExtLinkComponent);

      // Manuscript sections config
      config.addComponent('section-label', SectionLabel);
      config.addLabel('title-label', 'Title');
      config.addLabel('title-placeholder', 'Enter a title for your article');
      config.addLabel('abstract-label', 'Abstract');
      config.addLabel('abstract-placeholder', 'Please provide a short description of your article.');
      config.addLabel('body-label', 'Main text');
      config.addLabel('body-placeholder', 'Write your article here.');
      config.addLabel('authors-label', 'Authors');
      config.addLabel('references-label', 'References');
      config.addLabel('footnotes-label', 'Footnotes');

      // Used for rendering warning in case of missing images
      config.addIcon('graphic-load-error', { 'fontawesome': 'fa-warning' });
      config.addLabel('graphic-load-error', 'We couldn\'t load an image, sorry.');
    }
  }

  class ReferenceListComponent extends substance.Component {
    didMount () {
      // TODO: as we have a node for references now, we should turn this into a NodeComponent instead
      this.context.appState.addObserver(['document'], this.rerender, this, { stage: 'render', document: { path: ['references'] } });
    }

    dispose () {
      // TODO: as we have a node for references now, we should turn this into a NodeComponent instead
      this.context.appState.removeObserver(this);
    }

    getInitialState () {
      let bibliography = this._getBibliography();
      return {
        hidden: (bibliography.length === 0)
      }
    }

    render ($$) {
      const ReferenceComponent = this.getComponent('bibr');
      const bibliography = this._getBibliography();

      let el = $$('div').addClass('sc-reference-list')
        .attr('data-id', 'ref-list');

      if (this.state.hidden) {
        el.addClass('sm-hidden');
        return el
      }

      // ATTENTION: bibliography still works with document nodes
      bibliography.forEach(refNode => {
        let model = NodeModelFactory.create(this.context.api, refNode);
        el.append(
          $$(ReferenceComponent, { model })
        );
      });

      return el
    }

    _getBibliography () {
      const api = this.context.api;
      const referenceManager = api.getReferenceManager();
      return referenceManager.getBibliography()
    }
  }

  class FootnoteGroupComponent extends substance.Component {
    didMount () {
      this.context.appState.addObserver(['document'], this.rerender, this, { stage: 'render', document: { path: ['footnotes'] } });
    }

    dispose () {
      this.context.appState.removeObserver(this);
    }

    getInitialState () {
      const footnotes = this._getFootnotes();
      return {
        hidden: (footnotes.length === 0)
      }
    }

    render ($$) {
      const FootnoteComponent = this.getComponent('fn');
      const footnotes = this._getFootnotes();

      let el = $$('div').addClass('sc-footnote-group')
        .attr('data-id', 'fn-group');

      if (this.state.hidden) {
        el.addClass('sm-hidden');
        return el
      }

      footnotes.forEach(model => {
        let node = model._node;
        el.append(
          $$(FootnoteComponent, { model, node }).ref(model.id)
        );
      });
      return el
    }

    _getFootnotes () {
      let model = this.props.model;
      let footnotes = model.getItems();
      return footnotes
    }
  }

  class EditXRefTool extends ToggleTool {
    render ($$) {
      const targets = this._getAvailableTargets();

      let el = $$('div').addClass('sc-edit-xref-tool');
      // ATTENTION the targets are not models or nodes, but entries
      // created by xrefHelpers.getAvailableTargets()
      // TODO: use something more idiomatic
      for (let entry of targets) {
        const target = entry.model;
        if (!target) continue
        const selected = entry.selected;
        let targetPreviewEl = this._renderOption($$, target, selected);
        targetPreviewEl.on('click', this._toggleTarget.bind(this, target.id), this);
        el.append(targetPreviewEl);
      }
      return el
    }

    _renderOption ($$, target, selected) {
      let optionEl = $$('div').addClass('se-option').append(
        renderModelComponent(this.context, $$, {
          model: target,
          mode: PREVIEW_MODE
        })
      );
      if (selected) {
        optionEl.addClass('sm-selected');
      }
      return optionEl
    }

    _getModel () {
      // TODO: we should name this 'modelId'
      let id = this.props.commandState.nodeId;
      return this.context.api.getModelById(id)
    }

    _getAvailableTargets () {
      const model = this._getModel();
      return model.getAvailableTargets()
    }

    _toggleTarget (targetNodeId, e) {
      // Make sure we don't follow external links
      e.preventDefault();
      e.stopPropagation();

      const model = this._getModel();
      const targets = model.toggleTarget(targetNodeId);

      // Triggers a rerender
      this.setState({
        targets
      });
    }
  }

  class EditExtLinkTool extends ToggleTool {
    render ($$) {
      let Input = this.getComponent('input');
      let Button$$1 = this.getComponent('button');
      let commandState = this.props.commandState;
      let el = $$('div').addClass('sc-edit-ext-link-tool');

      // GUARD: Return if tool is disabled
      if (commandState.disabled) {
        console.warn('Tried to render EditLinkTool while disabled.');
        return el
      }

      let urlPath = this._getUrlPath();

      el.append(
        $$(Input, {
          type: 'url',
          path: urlPath,
          placeholder: 'Paste or type a link url'
        }).ref('input'),
        $$(Button$$1, {
          icon: 'open-link',
          theme: this.props.theme
        }).addClass('sm-open')
          .attr('title', this.getLabel('open-link'))
          .on('click', this._openLink)
      );
      return el
    }

    _getPropPath () {
      return ['attributes', 'xlink:href']
    }

    _getUrlPath () {
      const nodeId = this._getNodeId();
      let propPath = this._getPropPath();
      return [nodeId].concat(propPath)
    }

    _getNodeId () {
      return this.props.commandState.nodeId
    }

    _openLink () {
      let doc = this._getDocument();
      let url = doc.get(this._getUrlPath());
      window.open(url, '_blank');
    }

    _getDocument () {
      return this.context.editorSession.getDocument()
    }
  }

  class AbstractCitationManager {
    constructor (documentSession, type, labelGenerator) {
      this.documentSession = documentSession;
      this.type = type;
      this.labelGenerator = labelGenerator;
      this._targetTypes = substance.array2table(XREF_TARGET_TYPES[type]);

      documentSession.on('change', this._onDocumentChange, this);
    }

    dispose () {
      this.documentSession.off(this);
    }

    hasCitables () {
      // TODO: we should assimilate 'ContainerNode' and 'XMLElementNode' interface
      // I.e. an XMLElementNode could per se act as a classical container node
      // ATM only XMLContainerNode has this interface
      return this._getCollectionElement().getChildCount() > 0
    }

    getCitables () {
      // TODO: we should assimilate 'ContainerNode' and 'XMLElementNode' interface
      // I.e. an XMLElementNode could per se act as a classical container node
      // ATM only XMLContainerNode has this interface
      return this._getCollectionElement().getChildren()
    }

    getSortedCitables () {
      return this.getCitables().sort((a, b) => {
        return getPos(a) - getPos(b)
      })
    }

    // TODO: how could this be generalized so that it is less dependent on the internal model?
    _onDocumentChange (change) {
      // HACK: do not react on node state updates
      if (change.info.action === 'node-state-update') return

      const doc = this._getDocument();

      // updateCitationLabels whenever
      // I.   an xref[ref-type='bibr'] is created or deleted
      // II.  the ref-type attribute of an xref is set to 'bibr' (creation)
      // II. the rid attribute of an xref with ref-type bibr is updated
      const ops = change.ops;
      let needsUpdate = false;
      for (var i = 0; i < ops.length; i++) {
        let op = ops[i];

        switch (op.type) {
          // I. citation is created or deleted
          case 'delete':
          case 'create': {
            if (op.val.type === 'xref' && op.val.attributes && op.val.attributes['ref-type'] === this.type) {
              needsUpdate = true;
            }
            if (op.val.type === 'ref') {
              needsUpdate = true;
            }
            if (op.val.type === 'fn') {
              needsUpdate = true;
            }
            break
          }
          case 'set': {
            if (op.path[1] === 'attributes') {
              // II. citation has been created, i.e. ref-type has been set to 'bibr' (or vice versa)
              if (op.path[2] === 'ref-type' && (op.val === this.type || op.original === this.type)) {
                needsUpdate = true;

              // III. the references of a citation have been updated
              } else if (op.path[2] === 'rid') {
                let node = doc.get(op.path[0]);
                if (node && node.getAttribute('ref-type') === this.type) {
                  needsUpdate = true;
                }
              }
            }

            break
          }
          default:
            //
        }
        if (needsUpdate) break
      }
      if (needsUpdate) {
        this._updateLabels();
      }
    }

    /*
      Label of bibliographic entries are determined
      by the order of their citations in the document.
      I.e. typically you pick all citations (`<xref>`) as they
      occur in the document, and provide the ids of the entries
      they refer to. This forms a list of tuples, such as:
      ```
        [
          { id: 'cite1', refs: [AB06, Mac10] },
          { id: 'cite2', refs: [FW15] },
          { id: 'cite3', refs: [Mac10, AB06, AB07] }
        ]
      ```

      @param {Array<Object>} a list of citation entries.
    */
    _updateLabels (silent) {
      let xrefs = this._getXrefs();
      let refs = this.getCitables();
      let bibEl = this._getCollectionElement();
      let refsById = refs.reduce((m, ref) => {
        m[ref.id] = ref;
        return m
      }, {});

      let stateUpdates = [];

      let pos = 1;
      let order = {};
      let refLabels = {};
      let xrefLabels = {};
      xrefs.forEach((xref) => {
        let isInvalid = false;
        let numbers = [];
        let rids = xref.getAttribute('rid') || '';
        rids = rids.split(' ');
        for (let i = 0; i < rids.length; i++) {
          const id = rids[i];
          // skip if id empty
          if (!id) continue
          // fail if there is an unknown id
          if (!refsById[id]) {
            isInvalid = true;
            continue
          }
          if (!order.hasOwnProperty(id)) {
            order[id] = pos;
            refLabels[id] = this.labelGenerator.getLabel(pos);
            pos++;
          }
          numbers.push(order[id]);
        }
        // invalid labels shall be the same as empty ones
        if (isInvalid) {
          // HACK: we just signal invalid references with a ?
          numbers.push('?');
          console.warn('invalid label detected for ', xref.toXML().getNativeElement());
        }
        xrefLabels[xref.id] = this.labelGenerator.getLabel(numbers);
      });

      // HACK
      // Now update the node state of all affected xref[ref-type='bibr']
      // TODO: solve this properly
      xrefs.forEach(xref => {
        const label = xrefLabels[xref.id];
        const state = { label };
        stateUpdates.push([xref.id, state]);
      });
      refs.forEach((ref, index) => {
        const label = refLabels[ref.id] || '';
        const state = { label };
        if (order[ref.id]) {
          state.pos = order[ref.id];
        } else {
          state.pos = pos + index;
        }
        stateUpdates.push([ref.id, state]);
      });

      // HACK
      // TODO: solve this properly
      // e.g. we could implement this manager as a reducer on the application
      // state, and let the bibliography component react to updates of that
      if (bibEl) {
        // Note: mimicking a state update on the bibliography element itself
        // so that it rerenders, e.g. because the order might have changed
        stateUpdates.push([bibEl.id, {}]);
      }

      this.documentSession.updateNodeStates(stateUpdates, silent);
    }

    _getDocument () {
      return this.documentSession.getDocument()
    }

    _getXrefs () {
      const content = this._getContentElement();
      let refs = content.findAll(`xref[ref-type='${this.type}']`);
      return refs
    }

    _getContentElement () {
      // TODO: we should generalize this and/or move it into ArticelAPI
      // so that this code gets independent of the overall document layout
      const doc = this._getDocument();
      return doc.get('content')
    }

    _getCollectionElement () {
      throw new Error('This method is abstract.')
    }
  }

  /*
    A base class for FigureManager and TableManager. In contrast to citables like references or footnotes,
    the citable content is part of the content itself, and has a fixed order defined by the occurrence in the document.
    E.g. a reference is sorted and labeled according to the order of citations, but a figure is labeled according
    to the occurence in the content.
  */
  class CitableContentManager extends AbstractCitationManager {
    hasCitables () {
      return Boolean(this._getContentElement().find(XREF_TARGET_TYPES[this.type].join(',')))
    }

    getCitables () {
      return this._getContentElement().findAll(XREF_TARGET_TYPES[this.type].join(','))
    }

    getSortedCitables () {
      return this.getCitables()
    }

    /*
      Detection of changes that have an impact on the labeling is different to references.
      Labels change if
      1. Citable content is inserted or removed
      2. an xref ref-type is changed (TODO: this does not affect the other labels)
      3. xref targets are updated
    */
    _onDocumentChange (change) {
      // HACK: do not react on node state updates
      if (change.info.action === 'node-state-update') return
      const doc = this._getDocument();
      const TARGET_TYPES = this._targetTypes;
      const contentPath = this._getContentPath();

      // update labels whenever
      // I.   a <target-type> node is inserted into the body
      const ops = change.ops;
      let needsUpdate = false;
      for (var i = 0; i < ops.length; i++) {
        let op = ops[i];
        switch (op.type) {
          // I. citable content is inserted or removed
          case 'update': {
            if (substance.isArrayEqual(op.path, contentPath)) {
              let id = op.diff.val;
              let node = doc.get(id) || change.deleted[id];
              if (node && TARGET_TYPES[node.type]) {
                needsUpdate = true;
              }
            }
            break
          }
          case 'set': {
            if (op.path[1] === 'attributes') {
              // II. a ref-type has been updated
              if (op.path[2] === 'ref-type' && (op.val === this.type || op.original === this.type)) {
                needsUpdate = true;
              // III. cited targets have been updated
              } else if (op.path[2] === 'rid') {
                let node = doc.get(op.path[0]);
                if (node && node.getAttribute('ref-type') === this.type) {
                  needsUpdate = true;
                }
              }
            }

            break
          }
          default:
            //
        }
        if (needsUpdate) break
      }
      if (needsUpdate) {
        this._updateLabels();
      }
    }

    _getContentPath () {
      return this._getContentElement().getContentPath()
    }

    _getContentElement () {
      return this._getDocument().get('body')
    }

    _updateLabels (silent) {
      const doc = this._getDocument();

      let stateUpdates = [];

      let resources = this.getCitables();
      let resourcesById = {};
      let order = {};
      let pos = 1;
      resources.forEach((res) => {
        resourcesById[res.id] = res;
        order[res.id] = pos;
        let label = this.labelGenerator.getLabel([pos]);
        stateUpdates.push([res.id, { label, pos }]);
        pos++;
      });

      let xrefs = doc.findAll(`xref[ref-type='${this.type}']`);
      let xrefLabels = {};
      xrefs.forEach((xref) => {
        let isInvalid = false;
        let numbers = [];
        let rids = xref.getAttribute('rid') || '';
        rids = rids.split(' ');
        for (let i = 0; i < rids.length; i++) {
          const id = rids[i];
          if (!id) continue
          if (!resourcesById[id]) {
            isInvalid = true;
          } else {
            numbers.push(order[id]);
          }
        }
        // invalid labels shall be the same as empty ones
        if (isInvalid) numbers = [];
        xrefLabels[xref.id] = this.labelGenerator.getLabel(numbers);
      });
      // also update the state of the xrefs
      xrefs.forEach((xref) => {
        const label = xrefLabels[xref.id];
        stateUpdates.push([xref.id, { label }]);
      });

      // HACK: do not propagate change initially
      this.documentSession.updateNodeStates(stateUpdates, silent);
    }
  }

  class FigureManager extends CitableContentManager {
    constructor (documentSession, labelGenerator) {
      super(documentSession, 'fig', labelGenerator);
      this._updateLabels('initial');
    }
  }

  class FootnoteManager extends AbstractCitationManager {
    constructor (documentSession, labelGenerator) {
      super(documentSession, 'fn', labelGenerator);
      // compute initial labels
      this._updateLabels('initial');
    }

    _getCollectionElement () {
      return this._getDocument().get('footnotes')
    }
  }

  class ReferenceManager extends AbstractCitationManager {
    constructor (documentSession, labelGenerator) {
      super(documentSession, 'bibr', labelGenerator);
      // compute initial labels
      this._updateLabels('initial');
    }

    getBibliography () {
      return this.getSortedCitables()
    }

    _getCollectionElement () {
      return this._getDocument().get('references')
    }
  }

  class TableManager extends CitableContentManager {
    constructor (documentSession, labelGenerator) {
      super(documentSession, 'table', labelGenerator);

      this._updateLabels('initial');
    }
  }

  class ArticleSession extends DocumentSession {
    constructor (doc, configurator) {
      super(doc);

      this.figureManager = new FigureManager(this, configurator.getLabelGenerator('figures'));
      this.footnoteManager = new FootnoteManager(this, configurator.getLabelGenerator('footnotes'));
      this.referenceManager = new ReferenceManager(this, configurator.getLabelGenerator('references'));
      this.tableManager = new TableManager(this, configurator.getLabelGenerator('tables'));
    }

    getFigureManager () {
      return this.figureManager
    }

    getFootnoteManager () {
      return this.footnoteManager
    }

    getReferenceManager () {
      return this.referenceManager
    }

    getTableManager () {
      return this.tableManager
    }
  }

  class ArticleEditorSession extends EditorSessionMixin(ArticleSession) {
  }

  /*
    A special view on a translatable text inside the document.
  */
  class TranslateableModel {
    /*
      @param {ArticleAPI} api
      @param {Title|Abstract} node
    */
    constructor (api, node) {
      this._api = api;
      this._node = node;
    }

    get id () {
      return this._node.id
    }

    get name () {
      // TODO: probably we will need something more sophisticable here
      return this._node.id
    }

    get type () {
      return 'translatable'
    }

    getOriginalModel () {
      let model;
      if (this._node.isText()) {
        model = new TextModel(this._api, this._node.getPath());
      } else {
        model = new FlowContentModel(this._api, this._node.getContentPath());
      }
      return model
    }

    /*
      Returns a list of translations
    */
    getTranslations () {
      return this._node.translations.map(id => {
        return this._api.getModelById(id)
      })
    }

    /*
      Creates a new translation (with empty text) for a given language code
    */
    addTranslation (languageCode) {
      this._api.addTranslation(this, languageCode);
    }

    /*
      Removes a translation for a given language code
    */
    removeTranslation (translationModel) {
      this._api.deleteTranslation(this, translationModel);
    }
  }

  class TableEditingAPI {
    constructor (editorSession) {
      this.editorSession = editorSession;
    }

    isTableSelected () {
      let sel = this._getSelection();
      return (sel && !sel.isNull() && sel.customType === 'table')
    }

    deleteSelection () {
      if (!this.isTableSelected()) throw new Error('Table selection required')
      let selData = this._getSelectionData();
      let { tableId, startRow, endRow, startCol, endCol } = selData;
      this.editorSession.transaction(tx => {
        // Note: the selection remains the same
        this._clearValues(tx.get(tableId), startRow, startCol, endRow, endCol);
      }, { action: 'deleteSelection' });
    }

    copySelection () {
      if (!this.isTableSelected()) throw new Error('Table selection required')

      // create a snippet with a table containing only the selected range
      let selData = this._getSelectionData();
      let { table, startRow, endRow, startCol, endCol } = selData;
      let doc = this._getDocument();
      let cells = getRangeFromMatrix(table.getCellMatrix(), startRow, startCol, endRow, endCol, true);
      let snippet = doc.createSnippet();
      let tableCopy = snippet.create({ type: 'table' });
      // TODO: consolidate inconsistent Node API (Container vs XMLElementNode)
      for (let row of cells) {
        let trow = snippet.create({ type: 'table-row' });
        for (let cell of row) {
          let _nodes = substance.documentHelpers.copyNode(cell).map(_node => snippet.create(_node));
          trow.appendChild(_nodes[0]);
        }
        tableCopy.appendChild(trow);
      }
      snippet.getContainer().show(tableCopy.id);
      return snippet
    }

    paste (content, options) {
      if (!this.isTableSelected()) throw new Error('Table selection required')

      // TODO: implement paste for tables
      let snippet = content.get(substance.documentHelpers.SNIPPET_ID);
      if (!snippet) return false
      let first = snippet.getNodeAt(0);
      if (first.type !== 'table') return false
      return this._pasteTable(first)
    }

    _pasteTable (copy) {
      // TODO: extend dimension if necessary
      // and the assign cell attributes and content
      // ATTENTION: make sure that col/rowspans do not extend the table dims
      let [nrows, ncols] = copy.getDimensions();
      let selData = this._getSelectionData();
      let { tableId, startRow, startCol } = selData;
      let N = startRow + nrows;
      let M = startCol + ncols;
      // make the table larger if necessary
      this._ensureSize(tableId, N, M);

      this.editorSession.transaction(tx => {
        let table = tx.get(tableId);
        let cellMatrix = table.getCellMatrix();
        let copyCellMatrix = copy.getCellMatrix();
        for (let rowIdx = 0; rowIdx < nrows; rowIdx++) {
          for (let colIdx = 0; colIdx < ncols; colIdx++) {
            let copyCell = copyCellMatrix[rowIdx][colIdx];
            let cell = cellMatrix[startRow + rowIdx][startCol + colIdx];
            if (copyCell.getAttribute('heading')) {
              cell.setAttribute('heading', true);
            } else {
              cell.removeAttribute('heading');
            }
            // TODO: limit rowspan so that it does not exceed overall dims
            cell.setAttribute('rowspan', copyCell.rowspan);
            cell.setAttribute('colspan', copyCell.colspan);
            // TODO: copy annotations too
            cell.textContent = copyCell.textContent;
          }
        }
      }, { action: 'paste' });

      return true
    }

    insertRows (mode, count) {
      if (!this.isTableSelected()) return

      let selData = this._getSelectionData();
      let tableId = selData.tableId;
      let pos = mode === 'below' ? selData.endRow + 1 : selData.startRow;
      this.editorSession.transaction(tx => {
        this._createRowsAt(tx.get(tableId), pos, count);
      }, { action: 'insertRows', pos, count });
    }

    insertCols (mode, count) {
      if (!this.isTableSelected()) return
      let selData = this._getSelectionData();
      let tableId = selData.tableId;
      let pos = mode === 'right' ? selData.endCol + 1 : selData.startCol;
      this.editorSession.transaction(tx => {
        this._createColumnsAt(tx.get(tableId), pos, count);
      }, { action: 'insertCols', pos, count });
    }

    deleteRows () {
      if (!this.isTableSelected()) return
      let selData = this._getSelectionData();
      let tableId = selData.tableId;
      let pos = selData.startRow;
      let count = selData.nrows;
      this.editorSession.transaction(tx => {
        this._deleteRows(tx.get(tableId), pos, count);
        tx.selection = null;
      }, { action: 'deleteRows', pos, count });
    }

    deleteCols () {
      if (!this.isTableSelected()) return
      let selData = this._getSelectionData();
      let tableId = selData.tableId;
      let pos = selData.startCol;
      let count = selData.ncols;
      this.editorSession.transaction(tx => {
        this._deleteCols(tx.get(tableId), pos, pos + count - 1);
        tx.selection = null;
      }, { action: 'deleteCols', pos, count });
    }

    merge () {
      if (!this.isTableSelected()) return
      let selData = this._getSelectionData();
      // TODO: make sure that the selection allows to do that
      const tableId = selData.tableId;
      let table = this._getDocument().get(tableId);
      let { startRow, endRow, startCol, endCol } = selData;
      let bigOne = table.getCell(startRow, startCol);
      // compute the span by walking all non-shadowed cells
      for (let i = startRow; i <= endRow; i++) {
        for (let j = startCol; j <= endCol; j++) {
          let cell = table.getCell(i, j);
          if (cell.shadowed) continue
          let rowspan = cell.rowspan;
          let colspan = cell.colspan;
          if (rowspan > 1) {
            endRow = Math.max(endRow, i + rowspan - 1);
          }
          if (colspan > 1) {
            endCol = Math.max(endCol, j + colspan - 1);
          }
        }
      }
      // Note: spans should be >= 1, i.e. rowspan=1 means no spanning
      let rowspan = endRow - startRow + 1;
      let colspan = endCol - startCol + 1;
      if (bigOne.rowspan !== rowspan || bigOne.colspan !== colspan) {
        this.editorSession.transaction(tx => {
          let cell = tx.get(bigOne.id);
          cell.setAttribute('rowspan', rowspan);
          cell.setAttribute('colspan', colspan);
        }, { action: 'mergeCells' });
      }
    }

    unmerge () {
      if (!this.isTableSelected()) return
      let selData = this._getSelectionData();
      // TODO: make sure that the selection allows to do that
      const tableId = selData.tableId;
      let table = this._getDocument().get(tableId);
      let { startRow, endRow, startCol, endCol } = selData;
      let cellIds = [];
      for (let i = startRow; i <= endRow; i++) {
        for (let j = startCol; j <= endCol; j++) {
          let cell = table.getCell(i, j);
          let rowspan = cell.rowspan;
          let colspan = cell.colspan;
          if (rowspan > 1 || colspan > 1) {
            cellIds.push(cell.id);
          }
        }
      }
      if (cellIds.length > 0) {
        this.editorSession.transaction(tx => {
          cellIds.forEach(id => {
            let cell = tx.get(id);
            cell.removeAttribute('rowspan');
            cell.removeAttribute('colspan');
          });
        }, { action: 'unmergeCells' });
      }
    }

    toggleHeading (cellIds) {
      if (cellIds && cellIds.length > 0) {
        this.editorSession.transaction(tx => {
          for (let id of cellIds) {
            let cell = tx.get(id);
            let heading = cell.getAttribute('heading');
            if (heading) cell.removeAttribute('heading');
            else cell.setAttribute('heading', true);
          }
        }, { action: 'toggleHeading' });
      }
    }

    insertText (newVal) {
      if (!this.isTableSelected()) return
      let selData = this._getSelectionData();
      let cellId = selData.anchorCell.id;
      this.editorSession.transaction(tx => {
        let cell = tx.get(cellId);
        let path = cell.getPath();
        cell.textContent = newVal;
        tx.setSelection({
          type: 'property',
          path,
          startOffset: newVal.length,
          surfaceId: selData.surfaceId + '/' + path.join('.')
        });
      }, { action: 'insertText' });
    }

    insertSoftBreak () {
      this.editorSession.transaction(tx => {
        tx.insertText('\n');
      }, { action: 'soft-break' });
    }

    _getDocument () {
      return this.editorSession.getDocument()
    }

    _getSelection () {
      return this.editorSession.getSelection()
    }

    _getSelectionData () {
      let doc = this._getDocument();
      let sel = this._getSelection();
      if (sel && sel.customType === 'table') {
        let { nodeId, anchorCellId, focusCellId } = sel.data;
        let table = doc.get(nodeId);
        let anchorCell = doc.get(anchorCellId);
        let focusCell = doc.get(focusCellId);
        let { startRow, startCol, endRow, endCol } = getCellRange(table, anchorCellId, focusCellId);
        return {
          table,
          tableId: table.id,
          anchorCell,
          focusCell,
          startRow,
          endRow,
          startCol,
          endCol,
          nrows: endRow - startRow + 1,
          ncols: endCol - startCol + 1,
          surfaceId: sel.surfaceId
        }
      }
    }

    _getTable (doc, sel) {
      if (!sel || sel.isNull() || sel.customType === 'table') {
        return null
      }
    }

    _getCreateElement (table) {
      const doc = table.getDocument();
      return doc.createElement.bind(doc)
    }

    _createRowsAt (table, rowIdx, n) {
      let $$ = this._getCreateElement(table);
      const M = table.getColumnCount();
      let rowAfter = table.getChildAt(rowIdx);
      for (let i = 0; i < n; i++) {
        let row = $$('table-row');
        for (let j = 0; j < M; j++) {
          let cell = $$('table-cell');
          row.append(cell);
        }
        table.insertBefore(row, rowAfter);
      }
    }

    _deleteRows (table, startRow, endRow) {
      for (let rowIdx = endRow; rowIdx >= startRow; rowIdx--) {
        let row = table.getChildAt(rowIdx);
        table.removeChild(row);
        substance.documentHelpers.deleteNode(table.getDocument(), row);
      }
    }

    _deleteCols (table, startCol, endCol) {
      let N = table.getRowCount();
      for (let rowIdx = N - 1; rowIdx >= 0; rowIdx--) {
        let row = table.getChildAt(rowIdx);
        for (let colIdx = endCol; colIdx >= startCol; colIdx--) {
          let cell = row.getChildAt(colIdx);
          row.removeAt(colIdx);
          substance.documentHelpers.deleteNode(table.getDocument(), cell);
        }
      }
    }

    _createColumnsAt (table, colIdx, n) {
      let $$ = this._getCreateElement(table);
      let rowIt = table.getChildNodeIterator();
      while (rowIt.hasNext()) {
        let row = rowIt.next();
        let cellAfter = row.getChildAt(colIdx);
        for (let j = 0; j < n; j++) {
          let cell = $$('table-cell');
          row.insertBefore(cell, cellAfter);
        }
      }
    }

    _clearValues (table, startRow, startCol, endRow, endCol) {
      for (let rowIdx = startRow; rowIdx <= endRow; rowIdx++) {
        for (let colIdx = startCol; colIdx <= endCol; colIdx++) {
          let cell = table.getCell(rowIdx, colIdx);
          // TODO: are we sure that annotations get deleted this way?
          // Note that there is a delete logic behind this setText()
          cell.setText('');
        }
      }
    }

    _ensureSize (tableId, nrows, ncols) {
      let table = this._getDocument().get(tableId);
      let [_nrows, _ncols] = table.getDimensions();
      if (_ncols < ncols) {
        let pos = _ncols;
        let count = ncols - _ncols;
        this.editorSession.transaction(tx => {
          this._createColumnsAt(tx.get(tableId), pos, count);
        }, { action: 'insertCols', pos, count });
      }
      if (_nrows < nrows) {
        let pos = _nrows;
        let count = nrows - _nrows;
        this.editorSession.transaction(tx => {
          this._createRowsAt(tx.get(tableId), pos, count);
        }, { action: 'insertRows', pos, count });
      }
    }
  }

  const DISP_QUOTE = () => `
  <disp-quote></disp-quote>
`;

  const FIGURE_SNIPPET = () => `
  <fig xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:ali="http://www.niso.org/schemas/ali/1.0">
    <caption></caption>
    <graphic mime-subtype="" mimetype="image" xlink:href="" />
  </fig>
`;

  const FOOTNOTE_SNIPPET = () => `
  <fn></fn>
`;

  const PERSON_SNIPPET = () => `
  <contrib contrib-type="person" equal-contrib="no" corresp="no" deceased="no">
    <name>
      <surname></surname>
      <given-names></given-names>
      <suffix></suffix>
    </name>
    <bio></bio>
  </contrib>
`;

  const TABLE_SNIPPET = (nrows, ncols) => `
  <table-wrap>
    <caption>
    </caption>  
    <table>
      <tbody>
        <tr>
          ${Array(ncols).fill().map(() => '<th></th>').join('')}
        </tr>
        ${Array(nrows).fill().map(() => `<tr>
          ${Array(ncols).fill().map(() => '<td></td>').join('')}
        </tr>`).join('')}
      </tbody>
    </table>
  </table-wrap>
`;

  const elementSpippetsMap = {
    'disp-quote': DISP_QUOTE,
    'figure': FIGURE_SNIPPET,
    'footnote': FOOTNOTE_SNIPPET,
    'person': PERSON_SNIPPET,
    'table-figure': TABLE_SNIPPET
  };

  function createEmptyElement (tx, elName, ...snippetParams) {
    const snippet = elementSpippetsMap[elName];
    if (!snippet) {
      throw new Error('There is no snippet for element', elName)
    }
    let snippetEl = substance.DefaultDOMElement.parseSnippet(snippet(...snippetParams).trim(), 'xml');
    let docSnippet = tx.getDocument().createSnippet();
    let jatsImporter = createJatsImporter(docSnippet);
    let node = jatsImporter.convertElement(snippetEl);
    return substance.importNodeIntoDocument(tx, node)
  }

  function setContainerSelection (tx, node) {
    const p = node.find('p');
    if (p) {
      let path = [p.id, 'content'];
      let newSelection = {
        type: 'property',
        path,
        startOffset: 0,
        surfaceId: node.id
      };
      tx.setSelection(newSelection);
    }
  }

  function importFigures (tx, sel, files, paths) {
    const LAST = files.length - 1;
    let containerId = sel.containerId;
    files.map((file, idx) => {
      let path = paths[idx];
      let mimeData = file.type.split('/');
      let figure = createEmptyElement(tx, 'figure');
      let graphic = tx.get(figure.content);
      graphic.attr({
        'mime-subtype': mimeData[1],
        'mimetype': mimeData[0],
        'xlink:href': path
      });
      if (idx !== 0) {
        tx.break();
      }

      tx.insertBlockNode(figure);

      if (idx === LAST) {
        substance.selectionHelpers.selectNode(tx, figure.id, containerId);
      }
    });
  }

  function insertTableFigure (tx, rows, columns) {
    return createEmptyElement(tx, 'table-figure', rows, columns)
  }

  // TODO: this should come from configuration
  const COLLECTIONS = {
    'author': 'authors',
    'editor': 'editors'
  };

  class ArticleAPI extends EditorAPI {
    constructor (articleSession, config, archive) {
      super();
      this.config = config;
      this.modelRegistry = config.getModelRegistry();
      this.articleSession = articleSession;
      this.article = articleSession.getDocument();
      this.archive = archive;
      this._tableApi = new TableEditingAPI(articleSession);
      this._modelCache = new Map();
    }

    /*
      Get corresponding model for a given node. This used for most block content types (e.g. Figure, Heading etc.)
    */
    getModel (type, node) {
      let ModelClass = this.modelRegistry[type];
      // HACK: trying to retrieve the node if it is not given
      if (!node) {
        node = this.article.get(type);
      }
      if (ModelClass) {
        return new ModelClass(this, node)
      } else if (node) {
        return this._getModelForNode(node)
      }
    }

    getModelById (id) {
      let node = this.article.get(id);
      if (node) {
        // caching the model for a node so that we provide the same instance every time
        if (this._modelCache.has(node.id)) return this._modelCache.get(node.id)

        // now check if there is a custom model for this type
        let ModelClass = this.modelRegistry[node.type];
        // TODO: we could go and check if there is a component
        // registered for any of the parent types
        if (!ModelClass) {
          let superTypes = node.getSchema().getSuperTypes();
          for (let superType of superTypes) {
            ModelClass = this.modelRegistry[superType];
            if (ModelClass) break
          }
        }
        if (ModelClass) {
          return new ModelClass(this, node)
        }
        let model = this._getModelForNode(node);
        if (model) {
          this._modelCache.set(node.id, model);
          return model
        }
      }
    }

    _getNode (nodeId) {
      return this.article.get(nodeId)
    }

    // TODO: this should be configurable. As it is similar to HTML conversion
    // we could use the converter registry for this
    renderEntity (model) {
      let entity = this.getArticle().get(model.id);
      let exporter = this.config.getExporter('html');
      return renderEntity(entity, exporter)
    }

    getArticle () {
      return this.article
    }

    getArticleSession () {
      return this.articleSession
    }

    addItemToCollection (item, collection) {
      this.articleSession.transaction(tx => {
        let node = tx.create(item);
        tx.get(collection._node.id).appendChild(node);
        let newSelection = this._selectFirstRequiredProperty(node);
        tx.setSelection(newSelection);
      });
    }

    addItemsToCollection (items, collection) {
      if (items.length === 0) return
      this.articleSession.transaction(tx => {
        for (let i = 0; i < items.length; i++) {
          let item = items[i];
          let node = tx.create(item);
          tx.get(collection._node.id).appendChild(node);
          // put the cursor into the first item
          // TODO: or should it be the last one?
          if (i === 0) {
            let newSelection = this._selectFirstRequiredProperty(node);
            tx.setSelection(newSelection);
          }
        }
      });
    }

    removeItemFromCollection (item, collection) {
      const collectionId = collection.id;
      this.articleSession.transaction(tx => {
        tx.get(collectionId).removeChild(tx.get(item.id));
        tx.delete(item.id);
        tx.selection = null;
      });
    }

    moveCollectionItem (collection, from, to) {
      this.articleSession.transaction(tx => {
        let colNode = tx.get(collection._node.id);
        let item = colNode.getChildAt(from);
        colNode.removeAt(from);
        colNode.insertAt(to, item);
      });
    }

    getAuthorsModel () {
      return this.getModel('authors')
    }

    addReferences (items, collection) {
      const refContribProps = ['authors', 'editors', 'inventors', 'sponsors', 'translators'];
      const articleSession = this.articleSession;
      articleSession.transaction(tx => {
        let refs = tx.get(collection._node.id);
        items.forEach((item, i) => {
          refContribProps.forEach(propName => {
            if (item[propName]) {
              let refContribs = item[propName].map(contrib => {
                contrib.type = 'ref-contrib';
                const node = tx.create(contrib);
                return node.id
              });
              item[propName] = refContribs;
            }
          });

          let node = tx.create(item);
          refs.appendChild(tx.get(node.id));
          if (i === 0) {
            let newSelection = this._selectFirstRequiredProperty(node);
            tx.setSelection(newSelection);
          }
        });
      });
    }

    deleteReference (item, collection) {
      const articleSession = this.articleSession;
      articleSession.transaction(tx => {
        const xrefIndex = tx.getIndex('xrefs');
        const xrefs = xrefIndex.get(item.id);
        tx.get(collection._node.id).removeChild(tx.get(item.id));
        xrefs.forEach(xrefId => {
          let xref = tx.get(xrefId);
          let idrefs = xref.attr('rid').split(' ');
          idrefs = substance.without(idrefs, item.id);
          xref.setAttribute('rid', idrefs.join(' '));
        });
        tx.delete(item.id);
        tx.selection = null;
      });
    }

    /*
      @return {StringModel} Model for the language code of article's main language
    */
    getOriginalLanguageCode () {
      let article = this.getArticle().getRootNode();
      return new StringModel(this, [article.id, 'attributes', 'xml:lang'])
    }

    getCollectionForType (type) {
      // TODO: need to rethink this.
      // ATM we are registering special model classes for collections,
      // which are named after the single entity they contain,
      // e.g. 'authors' is a the collection of author nodes (which are person nodes essentially).
      // This is currently pretty confusing. It would be better to have
      // specific node in the model for that.
      // Still, we would need a mechanism to specify which node is acting as the parent
      // collection for which node.
      let collectionType = COLLECTIONS[type];
      // I don't like this implicit mapping.
      if (!collectionType) {
        collectionType = type + 's';
      }
      let model = this.getModel(collectionType);
      if (!model) {
        console.error(`No collection specified for type '${type}'. Using DynamicCollection. You should register a collection for this type explicitly.`);
        model = new DynamicCollection(this, type);
      }
      return model
    }

    getSchema (type) {
      return this.article.getSchema().getNodeSchema(type)
    }

    getArticleTitle () {
      let titleNode = this.getArticle().get('title');
      return new TextModel(this, titleNode.getPath())
    }

    getArticleAbstract () {
      let abstract = this.getArticle().get('abstract');
      return new FlowContentModel(this, abstract.getContentPath())
    }

    getArticleBody () {
      let body = this.getArticle().get('body');
      return new FlowContentModel(this, body.getContentPath())
    }

    getFigures () {
      let figs = this.getArticle().get('body').findAll('fig');
      return figs.map(fig => this.getModel(fig.type, fig))
    }

    getTranslatables () {
      const translatableItems = ['title', 'abstract'];
      const article = this.getArticle();
      const models = translatableItems.map(item => new TranslateableModel(this, article.get(item)));
      return models
    }

    addTranslation (model, languageCode) {
      const isText = model._node.isText();
      const articleSession = this.articleSession;
      articleSession.transaction(tx => {
        let item = {
          language: languageCode
        };
        if (isText) {
          item.type = 'text-translation';
        } else {
          item.type = 'container-translation';
        }
        let node = tx.create(item);
        // HACK: trying to avoid selection errors of empty container
        if (!isText) node.append(tx.create({type: 'p'}));
        let length = tx.get([model.id, 'translations']).length;
        tx.update([model.id, 'translations'], { type: 'insert', pos: length, value: node.id });
        tx.selection = null;
      });
    }

    deleteTranslation (translatableModel, translationModel) {
      const articleSession = this.articleSession;
      articleSession.transaction(tx => {
        let translatable = tx.get(translatableModel.id);
        let pos = translatable.translations.indexOf(translationModel.id);
        if (pos !== -1) {
          tx.update([translatableModel.id, 'translations'], { type: 'delete', pos: pos });
        }
        tx.delete(translationModel.id);
        tx.selection = null;
      });
    }

    // TODO: we should use a better internal model for xref
    // instead of an attribute we should use an array property instead
    toggleXrefTarget (targetId, model) {
      const articleSession = this.articleSession;
      articleSession.transaction(tx => {
        const xref = tx.get(model.id);
        let targetIds = xref.getAttribute('rid').split(' ');
        let found = false;
        for (let idx = targetIds.length - 1; idx >= 0; idx--) {
          let id = targetIds[idx];
          if (!tx.get(id)) {
            targetIds.splice(idx);
          }
          if (id === targetId) {
            targetIds.splice(idx);
            found = true;
          }
        }
        if (!found) {
          targetIds.push(targetId);
        }
        xref.setAttribute('rid', targetIds.join(' '));
      });
    }

    _getContext () {
      return this._context
    }

    /* Low-level content editing API */

    copy () {
      if (this._tableApi.isTableSelected()) {
        return this._tableApi.copySelection()
      } else {
        return super.copy()
      }
    }

    paste (content, options) {
      // TODO: to achieve a schema compliant paste we need
      // to detect the target element and 'filter' the content accordingly
      if (this._tableApi.isTableSelected()) {
        return this._tableApi.paste(content, options)
      } else {
        return super.paste(content, options)
      }
    }

    insertText (text) {
      if (this._tableApi.isTableSelected()) {
        this._tableApi.insertText(text);
      } else {
        return super.insertText(text)
      }
    }

    _createTextNode (tx, container, text) {
      // TODO: for Container nodes we should define the default text type
      // maybe even via a schema attribute
      return tx.create({ type: 'p', content: text })
    }

    _createListNode (tx, container, params) {
      let el = tx.create({ type: 'list' });
      if (params.listType) {
        el.attr('list-type', params.listType);
      }
      return el
    }

    getTableAPI () {
      return this._tableApi
    }

    // EXPERIMENTAL: in the MetadataEditor we want to be able to select a full card
    // I do not want to introduce a 'card' selection as this is not an internal concept
    // and instead opting for 'model' selection.
    selectModel (modelId) {
      this._setSelection({
        type: 'custom',
        customType: 'model',
        data: {
          modelId
        }
      });
    }

    selectValue (path) {
      this._setSelection({
        type: 'custom',
        customType: 'value',
        data: {
          path,
          propertyName: path[1]
        },
        surfaceId: path[0]
      });
    }

    /*
      TODO: In the future it should be necessary to expose those managers, instead
      API's should be used to access information.
    */
    getFigureManager () {
      return this.getArticleSession().getFigureManager()
    }

    getFootnoteManager () {
      return this.getArticleSession().getFootnoteManager()
    }

    getReferenceManager () {
      return this.getArticleSession().getReferenceManager()
    }

    getTableManager () {
      return this.getArticleSession().getTableManager()
    }

    get doc () {
      console.error('DEPRECATED: use api.getArticle() instead.');
      return this.getArticle()
    }

    _getDocument () {
      return this.getArticleSession().getDocument()
    }

    _getDocumentSession () {
      return this.getArticleSession()
    }

    _getEditorSession () {
      return this.articleSession
    }

    _isPropertyRequired (type, propertyName) {
      let REQUIRED = REQUIRED_PROPERTIES[type];
      if (REQUIRED) return REQUIRED.has(propertyName)
      return false
    }

    _selectFirstRequiredProperty (node) {
      let requiredProps = REQUIRED_PROPERTIES[node.type];
      if (requiredProps) {
        let propName = Array.from(requiredProps)[0];
        let path = [node.id, propName];
        return {
          type: 'property',
          path,
          startOffset: 0,
          surfaceId: `${path.join('.')}`
        }
      }
    }

    // TODO: can we improve this?
    // Here we would need a transaction on archive level, creating assets, plus placing them inside the article body.
    _insertFigures (files) {
      const articleSession = this.articleSession;
      let paths = files.map(file => {
        return this.archive.createFile(file)
      });
      let sel = articleSession.getSelection();
      if (!sel || !sel.containerId) return
      articleSession.transaction(tx => {
        importFigures(tx, sel, files, paths);
      });
    }

    _createTableFigure (tx, params) {
      return insertTableFigure(tx, params.rows, params.columns)
    }

    _createDispQuote (tx) {
      return createEmptyElement(tx, 'disp-quote')
    }

    _insertFootnote (item, footnotes) {
      const collectionId = footnotes.id;
      this.articleSession.transaction(tx => {
        const node = createEmptyElement(tx, 'footnote');
        tx.get(collectionId).appendChild(
          node
        );
        setContainerSelection(tx, node);
      });
    }

    _insertPerson (person, collection) {
      const collectionId = collection.id;
      this.articleSession.transaction(tx => {
        let bio = tx.create({type: 'bio'}).append(
          tx.create({type: 'p'})
        );
        person.bio = bio.id;
        let node = tx.create(person);
        tx.get(collectionId).appendChild(node);
        let newSelection = this._selectFirstRequiredProperty(node);
        tx.setSelection(newSelection);
      });

      // TODO: for snippet importing we need to register a contrib converter
      // and take care of groups

      // const collectionId = collection.id
      // this.articleSession.transaction(tx => {
      //   const node = createEmptyElement(tx, 'person')
      //   tx.get(collectionId).appendChild(
      //     node
      //   )
      //   let newSelection = this._selectFirstRequiredProperty(node)
      //   tx.setSelection(newSelection)
      // })
    }

    _getSelection () {
      return this.articleSession.editorState.selection
    }

    _setSelection (selData) {
      this.articleSession.setSelection(selData);
    }

    _createInternalEditorAPI () {
      return new InternalArticleEditingAPI()
    }
  }

  class InternalArticleEditingAPI extends InternalEditingAPI {
    createTextNode (tx, container, text) {
      // TODO: for Container nodes we should define the default text type
      // maybe even via a schema attribute
      return tx.create({ type: 'p', content: text })
    }

    createListNode (tx, container, params) {
      let el = tx.create({ type: 'list' });
      if (params.listType) {
        el.attr('list-type', params.listType);
      }
      return el
    }
  }

  // Base-class for Manuscript- and MetadataEditor to reduced code-redundancy
  class EditorPanel extends substance.Component {
    constructor (...args) {
      super(...args);

      this._initialize(this.props);
    }

    getActionHandlers () {
      return {
        executeCommand: this._executeCommand,
        toggleOverlay: this._toggleOverlay,
        startWorkflow: this._startWorkflow,
        closeModal: this._closeModal,
        scrollElementIntoView: this._scrollElementIntoView
      }
    }

    // TODO: shouldn't we react on willReceiveProps?
    _initialize (props) {
      const { articleSession, config, archive } = props;
      const editorSession = new ArticleEditorSession(
        articleSession, config, this, {
          workflowId: null,
          viewName: this.props.viewName
        }
      );
      const api = new ArticleAPI(editorSession, config, archive);
      const context = Object.assign(createEditorContext(config, editorSession), {
        archive,
        editor: this,
        api,
        urlResolver: archive,
        editable: true
      });

      this.appState = context.appState;
      this.api = api;
      this.context = context;
      this.editorSession = editorSession;

      this.editorSession.initialize();
      this.appState.addObserver(['workflowId'], this.rerender, this, { stage: 'render' });
      this.appState.addObserver(['viewName'], this._updateViewName, this, { stage: 'render' });

      // HACK: ATM there is no better way than to listen to an archive
      // event and forcing the CommandManager to update commandStates
      // and propagating the changes
      archive.on('archive:saved', () => {
        // HACK: alternatively we could trigger the commandManager directly
        // but setting the selection dirty, also makes sure the DOM selection gets rerendered
        // this.editorSession.commandManager.reduce()
        this.appState._setDirty('selection');
        this.appState.propagateUpdates();
      });

      // HACK: resetting the app state here, because things might get 'dirty' during initialization
      // TODO: find out if there is a better way to do this
      this.appState._reset();
    }

    _restoreViewport () {
      if (this.props.viewport) {
        // console.log('Restoring viewport', this.props.viewport)
        this.refs.contentPanel.setScrollPosition(this.props.viewport.x);
      }
    }

    dispose () {
      const appState = this.context.appState;
      const articleSession = this.props.articleSession;
      const editorSession = this.editorSession;
      articleSession.off(this);
      editorSession.dispose();
      appState.removeObserver(this);
      this.props.archive.off(this);
      // TODO: do we really need to clear here?
      this.empty();
    }

    getComponentRegistry () {
      return this.props.config.getComponentRegistry()
    }

    _updateViewName () {
      let appState = this.context.appState;
      this.send('updateViewName', appState.viewName);
    }

    _executeCommand (name, params) {
      this.editorSession.executeCommand(name, params);
    }

    _toggleOverlay (overlayId) {
      const appState = this.context.appState;
      if (appState.overlayId === overlayId) {
        appState.overlayId = null;
      } else {
        appState.overlayId = overlayId;
      }
      appState.propagateUpdates();
    }

    _startWorkflow (workflowId) {
      const appState = this.context.appState;
      appState.workflowId = workflowId;
      appState.overlayId = workflowId;
      appState.propagateUpdates();
    }

    _closeModal () {
      const appState = this.context.appState;
      appState.workflowId = null;
      appState.overlayId = null;
      appState.propagateUpdates();
    }

    _scrollElementIntoView (el, force) {
      this._getContentPanel().scrollElementIntoView(el, !force);
    }

    _getContentPanel () {
      throw new Error('This method is abstract')
    }

    _getConfigurator () {
      return this.props.config
    }

    _getEditorSession () {
      return this.editorSession
    }

    _getDocument () {
      return this.props.articleSession.getDocument()
    }

    _getTheme () {
      // TODO: this should come from app settings
      return 'light'
    }

    _onKeydown (e) {
      // console.log('EditorPanel._onKeydown', e)
      let handled = false;
      const appState = this.context.appState;
      switch (e.keyCode) {
        case substance.keys.ESCAPE: {
          if (appState.findAndReplace.enabled) {
            this.context.findAndReplaceManager.closeDialog();
            handled = true;
          }
          break
        }
        default:
          //
      }
      if (!handled) {
        handled = this.context.keyboardManager.onKeydown(e, this.context);
      }
      if (handled) {
        e.stopPropagation();
        e.preventDefault();
      }
      return handled
    }
  }

  class FrontMatterModel extends CompositeModel {
    constructor (api) {
      super(api);

      this.setProperties(
        { name: 'title', model: api.getArticleTitle() },
        { name: 'authors', model: api.getAuthorsModel() },
        { name: 'abstract', model: api.getArticleAbstract() }
      );
    }

    get type () { return 'front-matter' }
  }

  class BackMatterModel extends CompositeModel {
    constructor (api) {
      super(api);

      this.setProperties(
        { name: 'footnotes', model: api.getModelById('footnotes') },
        { name: 'references', model: api.getModelById('references') }
      );
    }

    get type () { return 'back-matter' }
  }

  class ManuscriptModel extends CompositeModel {
    constructor (api) {
      super(api);

      this.setProperties(
        { name: 'front', model: new FrontMatterModel(api) },
        { name: 'body', model: api.getArticleBody() },
        { name: 'back', model: new BackMatterModel(api) }
      );
    }

    get type () { return 'manuscript' }
  }

  class TOCProvider extends substance.EventEmitter {
    constructor (articleSession, config) {
      super();

      this.articleSession = articleSession;
      this.config = config;

      this.entries = this.computeEntries();
      if (this.entries.length > 0) {
        this.activeEntry = this.entries[0].id;
      } else {
        this.activeEntry = null;
      }

      this.articleSession.on('change', this.handleDocumentChange, this);
    }

    dispose () {
      this.articleSession.off(this);
    }

    handleDocumentChange (change) {
      let doc = this.getDocument();
      let needsUpdate = false;
      let tocTypes = this.constructor.tocTypes;

      // HACK: this is not totally correct but works.
      // Actually, the TOC should be updated if tocType nodes
      // get inserted or removed from the container, plus any property changes
      // This implementation just checks for changes of the node type
      // not the container, but as we usually create and show in
      // a single transaction this works.
      for (let i = 0; i < change.ops.length; i++) {
        let op = change.ops[i];
        let nodeType;
        if (op.isCreate() || op.isDelete()) {
          let nodeData = op.getValue();
          nodeType = nodeData.type;
          if (substance.includes(tocTypes, nodeType)) {
            needsUpdate = true;
            break
          }
        } else if (op.path) {
          let id = op.path[0];
          let node = doc.get(id);
          if (node && substance.includes(tocTypes, node.type)) {
            needsUpdate = true;
            break
          }
        }
      }
      if (needsUpdate) {
        this.entries = this.computeEntries();
        this.emit('toc:updated');
      }
    }

    computeEntries () {
      const doc = this.getDocument();
      const config = this.config;
      let entries = [];

      // Title is always there
      entries.push({
        id: 'title',
        name: 'Title',
        level: 1,
        node: doc.get('title')
      });

      // Note: For abstract we need to find first text node
      // inside container to set selection there
      const abstract = doc.find('abstract');
      if (abstract.getChildCount() > 0) {
        let first = abstract.find('p');
        if (first.getText()) {
          entries.push({
            id: abstract.id,
            name: 'Abstract',
            level: 1,
            node: abstract
          });
        }
      }

      const contentNodes = doc.get(config.containerId).getChildren();
      contentNodes.forEach(node => {
        if (node.type === 'heading') {
          entries.push({
            id: node.id,
            name: node.getText(),
            level: parseInt(node.attr('level'), 10),
            node: node
          });
        }
      });

      const footnotes = doc.get('footnotes');
      if (footnotes.getChildCount() > 0) {
        entries.push({
          id: 'footnotes',
          name: 'Footnotes',
          level: 1
        });
      }

      const references = doc.get('references');
      if (references.getChildCount() > 0) {
        entries.push({
          id: 'references',
          name: 'References',
          level: 1
        });
      }

      return entries
    }

    getEntries () {
      return this.entries
    }

    getDocument () {
      return this.articleSession.getDocument()
    }

    markActiveEntry (scrollPane) {
      let panelContent = scrollPane.getContentElement();
      let contentHeight = scrollPane.getContentHeight();
      let scrollPaneHeight = scrollPane.getHeight();
      let scrollPos = scrollPane.getScrollPosition();

      let scrollBottom = scrollPos + scrollPaneHeight;
      let regularScanline = scrollPos + 10;
      let smartScanline = 2 * scrollBottom - contentHeight;
      let scanline = Math.max(regularScanline, smartScanline);

      let tocNodes = this.computeEntries();
      if (tocNodes.length === 0) return

      // Use first toc node as default
      let activeEntry = tocNodes[0].id;
      for (let i = tocNodes.length - 1; i >= 0; i--) {
        let tocNode = tocNodes[i];
        let nodeEl = panelContent.find('[data-id="' + tocNode.id + '"]');
        if (!nodeEl) {
          console.warn('Not found in Content panel', tocNode.id);
          return
        }
        let panelOffset = scrollPane.getPanelOffsetForElement(nodeEl);
        if (scanline >= panelOffset) {
          activeEntry = tocNode.id;
          break
        }
      }

      if (this.activeEntry !== activeEntry) {
        this.activeEntry = activeEntry;
        this.emit('toc:updated');
      }
    }
  }

  TOCProvider.tocTypes = ['heading', 'ref', 'fn', 'p'];

  class TOC extends substance.Component {
    didMount () {
      let tocProvider = this.context.tocProvider;
      tocProvider.on('toc:updated', this.onTOCUpdated, this);
    }

    dispose () {
      let tocProvider = this.context.tocProvider;
      tocProvider.off(this);
    }

    render ($$) {
      let tocProvider = this.context.tocProvider;
      let activeEntry = tocProvider.activeEntry;
      let tocEntries = $$('div')
        .addClass('se-toc-entries')
        .ref('tocEntries');

      let entries = tocProvider.getEntries();
      if (entries.length >= 2) {
        for (let i = 0; i < entries.length; i++) {
          let entry = entries[i];
          let level = entry.level;

          let tocEntryEl = $$('a')
            .addClass('se-toc-entry sm-level-' + level)
            .attr({
              href: '#',
              'data-id': entry.id
            })
            .ref(entry.id)
            .on('click', this.handleClick)
            .append(
              entry.name
            );
          if (activeEntry === entry.id) {
            tocEntryEl.addClass('sm-active');
          }
          tocEntries.append(tocEntryEl);
        }
      }

      let el = $$('div').addClass('sc-toc').append(
        tocEntries
      );
      return el
    }

    getDocument () {
      return this.context.doc
    }

    onTOCUpdated () {
      this.rerender();
    }

    handleClick (e) {
      e.preventDefault();
      let nodeId = e.currentTarget.dataset.id;
      this.send('tocEntrySelected', nodeId);
    }
  }

  class ManuscriptEditor extends EditorPanel {
    getActionHandlers () {
      return Object.assign(super.getActionHandlers(), {
        tocEntrySelected: this._tocEntrySelected
      })
    }

    _initialize (props) {
      super._initialize(props);

      this.model = new ManuscriptModel(this.api);
      this.tocProvider = this._getTOCProvider();
      this.context.tocProvider = this.tocProvider;
    }

    didMount () {
      super.didMount();

      this.tocProvider.on('toc:updated', this._showHideTOC, this);
      this._showHideTOC();
      this._restoreViewport();

      substance.DefaultDOMElement.getBrowserWindow().on('resize', this._showHideTOC, this);
    }

    didUpdate () {
      super.didUpdate();

      this._showHideTOC();
      this._restoreViewport();
    }

    dispose () {
      super.dispose();

      this.tocProvider.off(this);
      substance.DefaultDOMElement.getBrowserWindow().off(this);
    }

    render ($$) {
      let el = $$('div').addClass('sc-manuscript-editor')
        // sharing styles with sc-article-reader
        .addClass('sc-manuscript-view');
      el.append(
        this._renderMainSection($$),
        this._renderContextPane($$)
      );
      el.on('keydown', this._onKeydown);
      return el
    }

    _renderMainSection ($$) {
      const appState = this.context.appState;
      let mainSection = $$('div').addClass('se-main-section');
      mainSection.append(
        this._renderToolbar($$),
        $$('div').addClass('se-content-section').append(
          this._renderTOCPane($$),
          this._renderContentPanel($$)
        ).ref('contentSection'),
        this._renderFooterPane($$)
      );

      if (appState.workflowId) {
        let Modal = this.getComponent('modal');
        let WorkflowComponent = this.getComponent(appState.workflowId);
        let workflowModal = $$(Modal).addClass('se-workflow-modal sm-workflow-' + appState.workflowId).append(
          $$(WorkflowComponent, appState.workflowProps).ref('workflow')
        );
        mainSection.append(workflowModal);
      }

      return mainSection
    }

    _renderTOCPane ($$) {
      let el = $$('div').addClass('se-toc-pane').ref('tocPane');
      el.append(
        $$('div').addClass('se-context-pane-content').append(
          $$(TOC)
        )
      );
      return el
    }

    _renderToolbar ($$) {
      const Toolbar = this.getComponent('toolbar');
      const configurator = this._getConfigurator();
      const toolPanel = configurator.getToolPanel('toolbar', true);
      return $$('div').addClass('se-toolbar-wrapper').append(
        $$(Managed(Toolbar), {
          toolPanel,
          bindings: ['commandStates']
        }).ref('toolbar')
      )
    }

    _renderContentPanel ($$) {
      const configurator = this._getConfigurator();
      const ScrollPane$$1 = this.getComponent('scroll-pane');
      const ManuscriptComponent = this.getComponent('manuscript');
      const Overlay$$1 = this.getComponent('overlay');
      const ContextMenu$$1 = this.getComponent('context-menu');
      const Dropzones = this.getComponent('dropzones');

      let contentPanel = $$(ScrollPane$$1, {
        tocProvider: this.tocProvider,
        // scrollbarType: 'substance',
        contextMenu: 'custom',
        scrollbarPosition: 'right'
      }).ref('contentPanel');

      contentPanel.append(
        $$(ManuscriptComponent, {
          model: this.model,
          disabled: this.props.disabled
        }).ref('article'),
        $$(Managed(Overlay$$1), {
          toolPanel: configurator.getToolPanel('main-overlay'),
          theme: this._getTheme(),
          bindings: ['commandStates']
        }),
        $$(Managed(ContextMenu$$1), {
          toolPanel: configurator.getToolPanel('context-menu'),
          theme: this._getTheme(),
          bindings: ['commandStates']
        }),
        $$(Dropzones)
      );
      return contentPanel
    }

    _renderFooterPane ($$) {
      const FindAndReplaceDialog = this.getComponent('find-and-replace-dialog');
      let el = $$('div').addClass('se-footer-pane');
      el.append(
        $$(FindAndReplaceDialog, {
          theme: this._getTheme(),
          viewName: 'manuscript'
        }).ref('findAndReplace')
      );
      return el
    }

    _renderContextPane ($$) {
      // TODO: we need to revisit this
      // We have introduced this to be able to inject a shared context panel
      // in Stencila. However, ATM we try to keep the component
      // as modular as possible, and avoid these kind of things.
      if (this.props.contextComponent) {
        let el = $$('div').addClass('se-context-pane');
        el.append(
          $$('div').addClass('se-context-pane-content').append(
            this.props.contextComponent
          )
        );
        return el
      }
    }

    _getContentPanel () {
      return this.refs.contentPanel
    }

    getViewport () {
      return {
        x: this.refs.contentPanel.getScrollPosition()
      }
    }

    _tocEntrySelected (nodeId) {
      let contentElement;
      switch (nodeId) {
        // scroll to the section label for the all the higher-level sections
        case 'title':
        case 'abstract':
        case 'body':
        case 'footnotes':
        case 'references': {
          let sectionComponent = this._getContentPanel().find(`.sc-section-label.sm-${nodeId}`).el;
          contentElement = sectionComponent.el;
          break
        }
        default: {
          let nodeComponent = this._getContentPanel().find(`[data-id="${nodeId}"]`);
          contentElement = nodeComponent.el;
        }
      }
      // Note: doing a forced scroll, i.e. not only if target is not visible
      return this._scrollElementIntoView(contentElement, true)
    }

    _showHideTOC () {
      let contentSectionWidth = this.refs.contentSection.el.width;
      if (!this._isTOCVisible() || contentSectionWidth < 960) {
        this.el.addClass('sm-compact');
      } else {
        this.el.removeClass('sm-compact');
      }
    }

    _isTOCVisible () {
      let entries = this.tocProvider.getEntries();
      return entries.length >= 2
    }

    _getTOCProvider () {
      return new TOCProvider(this.editorSession, { containerId: 'body' })
    }
  }

  class DecreaseHeadingLevelCommand extends substance.Command {
    getCommandState (params) {
      let doc = params.editorSession.getDocument();
      let sel = params.selection;
      let isBlurred = params.editorSession.isBlurred();

      let commandState = {
        disabled: false
      };

      if (sel.isPropertySelection() && !isBlurred) {
        let path = sel.getPath();
        let node = doc.get(path[0]);
        if (node &&
          node.isBlock() &&
          node.type === 'heading') {
          commandState.active = true;
        } else {
          commandState.disabled = true;
        }
      } else {
        commandState.disabled = true;
      }

      return commandState
    }

    execute (params) {
      let sel = params.selection;
      let editorSession = params.editorSession;
      let doc = editorSession.getDocument();
      let path = sel.getPath();
      let node = doc.get(path[0]);
      if (node.getAttribute('level') > 1) {
        editorSession.transaction((txDoc) => {
          let node = txDoc.get(path[0]);
          node.setAttribute('level', String(parseInt(node.level, 10) - 1));
        });
      }
    }
  }

  class IncreaseHeadingLevelCommand extends substance.Command {
    getCommandState (params) {
      let doc = params.editorSession.getDocument();
      let sel = params.selection;
      let isBlurred = params.editorSession.isBlurred();

      let commandState = {
        disabled: false
      };

      if (sel.isPropertySelection() && !isBlurred) {
        let path = sel.getPath();
        let node = doc.get(path[0]);
        if (node &&
          node.isBlock() &&
          node.type === 'heading') {
          commandState.active = true;
        } else {
          commandState.disabled = true;
        }
      } else {
        commandState.disabled = true;
      }

      return commandState
    }

    execute (params) {
      let sel = params.selection;
      let editorSession = params.editorSession;
      let doc = editorSession.getDocument();
      let path = sel.getPath();
      let node = doc.get(path[0]);
      if (node.getAttribute('level') < 3) {
        editorSession.transaction((txDoc) => {
          let node = txDoc.get(path[0]);
          node.setAttribute('level', String(parseInt(node.level, 10) + 1));
        });
      }
    }
  }

  class InsertExtLinkCommand extends substance.AnnotationCommand {
    executeCreate (params, context) {
      let result = super.executeCreate(params);
      let editorSession = context.editorSession;
      editorSession.transaction((tx) => {
        tx.setSelection(tx.selection.collapse());
      });
      return result
    }
  }

  class InsertNodeCommand extends substance.InsertNodeCommand {
    execute (params, context) {
      let state = params.commandState;
      if (state.disabled) return
      let editorSession = context.editorSession;
      editorSession.transaction((tx) => {
        let node = this.createNode(tx, params, context);
        tx.insertBlockNode(node);
        this.setSelection(tx, node);
      });
    }

    createNode(tx) { // eslint-disable-line
      throw new Error('This method is abstract')
    }
  }

  class InsertDispQuoteCommand extends InsertNodeCommand {
    createNode (tx, params, context) {
      return context.api._createDispQuote(tx)
    }
  }

  /**
    Reusable command implementation for inserting inline nodes.

    @class InsertInlineNodeCommand

    @example

    Define a custom command.

    ```
    class AddXRefCommand extends InsertInlineNodeCommand {
      createNode(tx) {
        let refType = this.config.refType
        let xref = tx.createElement('xref').attr('publication-type', 'journal')
        xref.attr('ref-type', refType)
        xref.attr('rid', '')
        return xref
      }
    }
    ```

    Register it in your app using the configurator.

    ```
    config.addCommand('add-xref', AddXRefCommand, { nodeType: 'xref' })
    ```
  */

  class InsertInlineNodeCommand extends substance.InsertInlineNodeCommand {
    /**
      Insert new inline node at the current selection
    */
    execute (params, context) {
      // TODO: use ArticleAPI
      let state = this.getCommandState(params, context);
      if (state.disabled) return
      let editorSession = context.editorSession;
      editorSession.transaction((tx) => {
        let node = this.createNode(tx, params, context);
        tx.insertInlineNode(node);
        this.setSelection(tx, node);
      });
    }

    createNode (tx, context) { // eslint-disable-line no-unused-vars
      throw new Error('This method is abstract')
    }

    setSelection (tx, node) {
      if (node.isPropertyAnnotation()) {
        tx.selection = {
          type: 'property',
          path: node.getPath(),
          startOffset: node.startOffset,
          endOffset: node.endOffset
        };
      }
    }
  }

  class InsertXrefCommand extends InsertInlineNodeCommand {
    getType () {
      return 'xref'
    }

    createNode (tx) {
      const refType = this.config.refType;
      let xref = tx.createElement('xref');
      xref.attr('ref-type', refType);
      xref.attr('rid', '');
      return xref
    }

    isDisabled (params, context) {
      const sel = params.selection;
      const refType = this.config.refType;
      const hasTargets = hasAvailableXrefTargets(refType, context);
      // don't xref insertion
      // 1. if the selections is not a collapsed property selection
      // 2. if there are no citable targets available
      if (!sel.isPropertySelection() || !sel.isCollapsed() || !hasTargets) {
        return true
      }
      return false
    }
  }

  // TODO: this is kind of surprising, because it actually allows to insert multiple figures at once
  class InsertFigureCommand extends InsertNodeCommand {
    execute (params, context) {
      const state = params.commandState;
      const files = params.files;
      if (state.disabled) return
      let api = context.api;
      if (files.length > 0) {
        api._insertFigures(files);
      }
    }
  }

  class InsertFigureTool extends ToggleTool {
    renderButton ($$) {
      let button = super.renderButton($$);
      let input = $$('input').attr({
        'type': 'file',
        'multiple': 'multiple',
        'accept': 'image/*'
      }).ref('input')
        .on('change', this.onFileSelect);
      return [button, input]
    }

    getClassNames () {
      return 'sc-insert-figure-tool'
    }

    onClick () {
      this.refs.input.val(null);
      this.refs.input.click();
    }

    onFileSelect (e) {
      let files = e.currentTarget.files;
      this.executeCommand({
        files: Array.prototype.slice.call(files)
      });
    }
  }

  var DropFigure = {
    type: 'drop-asset',
    match (params) {
      // Mime-type starts with 'image/'
      let isImage = params.file.type.indexOf('image/') === 0;
      return params.type === 'file' && isImage
    },
    drop (tx, params, context) {
      let api = context.api;
      api._insertFigures([params.file]);
    }
  }

  class InsertInlineFormulaCommand extends substance.InsertInlineNodeCommand {
    getType () {
      return 'inline-formula'
    }

    createNode (tx) {
      const inlineFormula = tx.createElement('inline-formula')
        .attr('content-type', 'math/tex')
        .appendChild(
          tx.createElement('tex-math')
        );
      return inlineFormula
    }

    /**
      Insert new inline node at the current selection
    */
    execute (params, context) {
      const state = this.getCommandState(params);
      if (state.disabled) return
      const editorSession = context.editorSession;
      const sel = params.selection;
      editorSession.transaction((tx) => {
        const doc = tx.getDocument();
        const text = substance.documentHelpers.getTextForSelection(doc, sel);
        const node = tx.createElement('inline-formula')
          .attr('content-type', 'math/tex');
        const inlineFormula = tx.insertInlineNode(node);
        inlineFormula.appendChild(
          tx.createElement('tex-math').text(text)
        );
        this.setSelection(tx, node);
      });
    }

    setSelection (tx, node) {
      if (node.isPropertyAnnotation()) {
        tx.selection = {
          type: 'property',
          path: node.getPath(),
          startOffset: node.start.offset,
          endOffset: node.end.offset
        };
      }
    }

    isDisabled (params) {
      const sel = params.selection;
      const selectionState = params.editorSession.getSelectionState();
      if (!sel.isPropertySelection()) {
        return true
      }
      // We don't allow inserting an inline node on top of an existing inline node.
      if (selectionState.isInlineNodeSelection) {
        return true
      }
      return false
    }
  }

  /*
    Tool to edit math markup.
  */
  class EditInlineFormulaTool extends ToggleTool {
    render ($$) {
      let Input = this.getComponent('input');
      let commandState = this.props.commandState;
      let el = $$('div').addClass('sc-edit-math-tool');

      // GUARD: Return if tool is disabled
      if (commandState.disabled) {
        console.warn('Tried to render EditMathTool while disabled.');
        return el
      }
      let sourcePath = this.getSourcePath();
      el.append(
        $$(Input, {
          type: 'text',
          path: sourcePath,
          placeholder: 'Enter TeX'
        })
          // ATTNETION have a ref on it, otherwise the input will get rerendered on every change
          .ref('input')
          // stopping keydown events so that the input field is not distracted by other editor keyboard handler
          // TODO: maybe let 'Save' through...
          .on('keydown', substance.domHelpers.stop)
      );
      return el
    }

    getNodeId () {
      return this.props.commandState.nodeId
    }

    getSourcePath () {
      const commandState = this.props.commandState;
      const doc = this.context.editorSession.getDocument();
      const nodeId = commandState.nodeId;
      const inlineFormula = doc.get(nodeId);
      const texMath = inlineFormula.find('tex-math');
      return texMath.getPath()
    }

    onDelete (e) { // eslint-disable-line no-unused-vars
      console.error('FIXME: use ArticleAPI to delete formula');
      // e.preventDefault();
      // let nodeId = this.getNodeId()
      // let sm = this.context.surfaceManager
      // let surface = sm.getFocusedSurface()
      // if (!surface) {
      //   console.warn('No focused surface. Stopping command execution.')
      //   return
      // }
      // let editorSession = this.context.editorSession
      // editorSession.transaction((tx, args) => {
      //   tx.delete(nodeId)
      //   return args
      // })
    }
  }

  const DISABLED$2 = { disabled: true };

  class InsertTableCommand extends InsertNodeCommand {
    createNode (tx, params, context) {
      const api = context.api;
      let tableFigure = api._createTableFigure(tx, params);
      return tableFigure
    }
  }

  class BasicTableCommand extends substance.Command {
    getCommandState (params, context) { // eslint-disable-line no-unused-vars
      const tableApi = context.api.getTableAPI();
      if (!tableApi.isTableSelected()) return DISABLED$2
      const selData = tableApi._getSelectionData();
      return Object.assign({ disabled: false }, selData)
    }

    execute (params, context) { // eslint-disable-line no-unused-vars
      const commandState = params.commandState;
      if (commandState.disabled) return

      const tableApi = context.api.getTableAPI();
      return this._execute(tableApi, commandState)
    }
  }

  class InsertCellsCommand extends BasicTableCommand {
    _execute (tableApi, { ncols, nrows }) {
      const mode = this.config.spec.pos;
      const dim = this.config.spec.dim;
      if (dim === 'row') {
        tableApi.insertRows(mode, nrows);
      } else {
        tableApi.insertCols(mode, ncols);
      }
      return true
    }
  }

  class DeleteCellsCommand extends BasicTableCommand {
    _execute (tableApi, { startRow, startCol, nrows, ncols }) {
      const dim = this.config.spec.dim;
      if (dim === 'row') {
        tableApi.deleteRows();
      } else {
        tableApi.deleteCols();
      }
      return true
    }
  }

  class TableSelectAllCommand extends BasicTableCommand {
    _execute (tableApi) {
      tableApi.selectAll();
      return true
    }
  }

  class ToggleCellHeadingCommand extends BasicTableCommand {
    getCommandState (params, context) { // eslint-disable-line no-unused-vars
      let commandState = super.getCommandState(params, context);
      if (commandState.disabled) return commandState

      let { table, startRow, endRow, startCol, endCol } = commandState;
      let cells = substance.getRangeFromMatrix(table.getCellMatrix(), startRow, startCol, endRow, endCol, true);
      cells = substance.flatten(cells).filter(c => !c.shadowed);
      let onlyHeadings = true;
      for (let i = 0; i < cells.length; i++) {
        if (!cells[i].getAttribute('heading')) {
          onlyHeadings = false;
          break
        }
      }
      return Object.assign(commandState, {
        active: onlyHeadings,
        cellIds: cells.map(c => c.id)
      })
    }

    _execute (tableApi, { cellIds, heading }) {
      tableApi.toggleHeading(cellIds);
      return true
    }
  }

  class ToggleCellMergeCommand extends BasicTableCommand {
    getCommandState (params, context) { // eslint-disable-line no-unused-vars
      let commandState = super.getCommandState(params, context);
      if (commandState.disabled) return commandState

      let { table, nrows, ncols, startRow, startCol } = commandState;
      let cell = table.getCell(startRow, startCol);
      let rowspan = cell.rowspan;
      let colspan = cell.colspan;
      // ATTENTION: at the moment the selection is expressed in absolute
      // rows and cols, not considering colspans and rowspans
      // If a single cell with row- or colspan is selected, then
      // nrows=rowspan and ncols=colspan
      if (nrows > 1 || ncols > 1) {
        if (rowspan < nrows || colspan < ncols) {
          commandState.merge = true;
        } else {
          commandState.active = true;
          commandState.unmerge = true;
        }
      }
      // only enable if one merge option is enabled
      // TODO: if table commands are enabled this command should
      // be shown even if disabled
      if (!commandState.merge && !commandState.unmerge) {
        return DISABLED$2
      }
      return commandState
    }

    _execute (tableApi, { merge, unmerge }) {
      if (merge) {
        tableApi.merge();
      } else if (unmerge) {
        tableApi.unmerge();
      }
      return true
    }
  }

  class InsertTableTool extends ToggleTool {
    getClassNames () {
      return 'sc-insert-table-tool'
    }

    onClick () {
      const rows = 3;
      const columns = 5;
      this.executeCommand({
        rows: rows,
        columns: columns
      });
    }
  }

  class ToggleListCommand extends substance.Command {
    isSwitchTypeCommand () { return true }

    // TODO: do we want to generalize this to other list types?
    getType () {
      return 'list'
    }

    /*
      Note: this implementation is still very coupled with the specific internal data model.
      TODO: we could try to use API to generalize this
    */
    getCommandState (params) {
      let editorSession = params.editorSession;
      let doc = editorSession.getDocument();
      let sel = editorSession.getSelection();
      if (sel && sel.isPropertySelection()) {
        let path = sel.path;
        let node = doc.get(path[0]);
        if (node) {
          if (node.isListItem()) {
            let level = node.getLevel();
            let list = node.getParent();
            let listType = list.getListType(level);
            let active = listType === this.config.spec.listType;
            let action = active ? 'toggleList' : 'setListType';
            let listId = list.id;
            return {
              disabled: false,
              active,
              action,
              listId,
              level
            }
          } else if (node.isText() && node.isBlock()) {
            return {
              disabled: false,
              action: 'switchTextType'
            }
          }
        }
      }
      return { disabled: true }
    }

    /*
      Note: this implementation is still very coupled with the specific internal data model.
      TODO: we could try to use API to generalize this
    */
    execute (params) {
      let commandState = params.commandState;
      const { disabled, action } = commandState;
      if (disabled) return

      let editorSession = params.editorSession;
      switch (action) {
        case 'toggleList': {
          editorSession.transaction((tx) => {
            tx.toggleList();
          }, { action: 'toggleList' });
          break
        }
        case 'setListType': {
          const { listId, level } = commandState;
          editorSession.transaction((tx) => {
            let list = tx.get(listId);
            list.setListType(level, this.config.spec.listType);
          }, { action: 'setListType' });
          break
        }
        case 'switchTextType': {
          editorSession.transaction((tx) => {
            tx.toggleList({ listType: this.config.spec.listType });
          }, { action: 'toggleList' });
          break
        }
        default:
          //
      }
    }
  }

  var ArticleNavPackage = {
    name: 'ArticleNav',
    configure (config) {
      config.addLabel('mode', 'Mode');
      config.addViewMode({
        name: 'open-manuscript',
        viewName: 'manuscript',
        commandGroup: 'switch-view',
        icon: 'fa-align-left',
        label: 'Manuscript'
      });

      config.addViewMode({
        name: 'open-metadata',
        viewName: 'metadata',
        commandGroup: 'switch-view',
        icon: 'fa-th-list',
        label: 'Metadata'
      });

      // TODO: make reader great again
      /*
      config.addViewMode({
        name: 'open-reader',
        viewName: 'reader',
        commandGroup: 'switch-view',
        icon: 'fa-th-list',
        label: 'Reader'
      })
      */
    }
  }

  class SaveCommand extends substance.Command {
    getCommandState (params, context) {
      let archive = context.archive;
      if (!archive || !archive.hasPendingChanges()) {
        return substance.Command.DISABLED
      } else {
        return {
          disabled: false
        }
      }
    }

    execute (params, context) {
      context.editor.send('save');
    }
  }

  var PersistencePackage = {
    name: 'Persistence',
    configure (config) {
      config.addCommand('save', SaveCommand, {
        commandGroup: 'persistence'
      });
      config.addIcon('save', { 'fontawesome': 'fa-save' });
      config.addLabel('save', 'Save Document');
      // TODO: enable this once we have global key handling in place
      // config.addKeyboardShortcut('CommandOrControl+S', { command: 'save' })
    }
  }

  /*
    Converts a CSLJSON record to our internal format.
    See EntityDatabase for schemas.
  */

  function convertCSLJSON (source) {
    let bibType = source.type;
    let result;

    // CSL types: http://docs.citationstyles.org/en/stable/specification.html#appendix-iii-types
    let typeMapping = {
      'article': ARTICLE_REF,
      'article-magazine': MAGAZINE_ARTICLE_REF,
      'article-newspaper': NEWSPAPER_ARTICLE_REF,
      'article-journal': JOURNAL_ARTICLE_REF,
      // "bill"
      'book': BOOK_REF,
      // "broadcast"
      'chapter': CHAPTER_REF,
      'dataset': DATA_PUBLICATION_REF,
      // "entry"
      'entry-dictionary': BOOK_REF,
      'entry-encyclopedia': BOOK_REF,
      // "figure"
      // "graphic"
      // "interview"
      // "legislation"
      // "legal_case"
      // "manuscript"
      // "map"
      // "motion_picture"
      // "musical_score"
      // "pamphlet"
      'paper-conference': CONFERENCE_PAPER_REF,
      'patent': PATENT_REF,
      // "post"
      // "post-weblog"
      // "personal_communication"
      'report': REPORT_REF,
      // "review"
      // "review-book"
      // "song"
      // "speech"
      'thesis': THESIS_REF,
      // "treaty"
      'webpage': WEBPAGE_REF
      // NA : "software"
    };

    if (typeMapping[bibType]) {
      result = _convertFromCSLJSON(source, typeMapping[bibType]);
    } else {
      throw new Error(`Bib type ${bibType} not yet supported`)
    }
    return result
  }

  function _convertFromCSLJSON (source, type) {
    const date = _extractDateFromCSLJSON(source);

    let data = {
      type: type,

      title: source.title,
      containerTitle: source['container-title'],
      volume: source.volume,
      issue: source.issue,
      pageRange: source.page,
      doi: source.DOI,
      pmid: source.PMID,

      edition: source.edition,
      publisherLoc: source['publisher-place'],
      publisherName: source.publisher,
      pageCount: source['number-of-pages'],
      partTitle: source.section,
      confName: source.event,
      confLoc: source['event-place'],
      isbn: source.ISBN,

      year: date.year,
      month: date.month,
      day: date.day,

      uri: source.URL,
      version: source.version

      /* Examples with no corresponding field:
          - abstract
          - accessed
          - composer
          - director
          - ISSN
          - language
          - number-of-volumes
          - PMCID
          - title-short
          - translator
      */
    };

    // series
    if (source['collection-title']) {
      data.series = source['collection-title'];
      if (source['collection-number']) {
        data.series += '; ' + source['collection-number'];
      }
    }

    // Authors, editors, translators, inventors
    if (source.author) {
      if (type === 'patent') {
        data.inventors = source.author.map(a => { return {name: a.family, givenNames: a.given} });
      } else {
        data.authors = source.author.map(a => { return {name: a.family, givenNames: a.given} });
      }
    }
    if (source.editor) {
      data.editors = source.editor.map(a => { return {name: a.family, givenNames: a.given} });
    }
    if (source.translator) {
      data.translators = source.translator.map(a => { return {name: a.family, givenNames: a.given} });
    }

    // Cleanup output to avoid any undefined values
    Object.keys(data).forEach(key => {
      if (data[key] === undefined) {
        delete data[key];
      }
    });

    if (!data.doi) {
      // TODO: We should not rely that the imported item has a DOI, because it can also be imported from a generic CSL JSON file.
      //  However, there are some problems in the further processing withouth a DOI at the moment...
      throw new Error(`Citation must have DOI.`)
    }

    return data
  }

  function _extractDateFromCSLJSON (source) {
    let date = {};
    if (source.issued && source.issued['date-parts']) {
      let CSLdate = source.issued['date-parts'];
      if (CSLdate.length > 0) {
        date.year = String(CSLdate[0][0]);
        if (CSLdate[0][1]) {
          date.month = CSLdate[0][1] > 9 ? String(CSLdate[0][1]) : 0 + String(CSLdate[0][1]);
        }
        if (CSLdate[0][2]) {
          date.day = CSLdate[0][2] > 9 ? String(CSLdate[0][2]) : 0 + String(CSLdate[0][2]);
        }
      }
    }
    return date
  }

  class DOIInputComponent extends substance.Component {
    render ($$) {
      const labelProvider = this.context.labelProvider;

      const inputEl = $$('div').addClass('se-input-group').append(
        $$('input').addClass('se-input').attr({
          type: 'text',
          placeholder: labelProvider.getLabel('enter-doi-placeholder')
        }).on('input', this._unblockUI).ref('DOIInput')
      );

      if (this.state.loading) {
        inputEl.append(
          $$('div').addClass('se-input-sign').append(
            $$(substance.FontAwesomeIcon, {icon: 'fa-spinner fa-spin'})
          )
        );
      } else if (this.state.error) {
        const dois = this.state.error.dois;
        const errorsList = $$('ul').addClass('se-error-list');
        errorsList.append(
          $$('li').append(this.state.error.message)
        );
        if (dois) {
          errorsList.append(dois.map(d => $$('li').append('- ' + d)));
        }
        inputEl.append(
          $$('div').addClass('se-input-sign sm-error').append(
            $$(substance.FontAwesomeIcon, {icon: 'fa-exclamation-circle'})
          ),
          $$('div').addClass('se-error-popup').append(errorsList)
        );
      } else {
        inputEl.append(
          $$('button').addClass('se-action').append(
            labelProvider.getLabel('doi-fetch-action')
          ).on('click', this._startImporting)
        );
      }

      const el = $$('div').addClass('se-doi-input').append(
        $$('div').addClass('se-section-title').append(
          labelProvider.getLabel('fetch-datacite')
        ),
        inputEl
      );

      return el
    }

    _startImporting () {
      const input = this.refs.DOIInput;
      const val = input.val();
      const dois = val.split(' ').map(v => v.trim()).filter(v => Boolean(v));
      this.extendState({loading: true});

      _getBibEntries(dois).then(entries => {
        this.send('importBib', entries);
      }).catch(error => {
        this.extendState({error, loading: false});
      });
    }

    _unblockUI () {
      if (this.state.error) {
        this.extendState({error: undefined});
      }
    }
  }

  /*
    Helpers
  */
  const ENDPOINT = 'https://doi.org/';

  function _getBibEntries (dois) {
    return _fetchCSLJSONEntries(dois).then(entries => {
      let conversionErrors = [];
      let convertedEntries = [];
      entries.forEach(entry => {
        try {
          convertedEntries.push(
            convertCSLJSON(entry)
          );
        } catch (error) {
          conversionErrors.push(entry.DOI);
        }
      });
      if (conversionErrors.length > 0) {
        let error = new Error('Conversion error');
        error.dois = conversionErrors;
        return Promise.reject(error)
      } else {
        return convertedEntries
      }
    })
  }

  /*
    Fetch CSL JSON entries
  */
  function _fetchCSLJSONEntries (dois) {
    let errored = [];
    let entries = [];

    return dois.reduce((promise, doi) => {
      return promise
        .then(() => _fetchDOI(doi))
        .then(csl => entries.push(JSON.parse(csl)))
        .catch(() => errored.push(doi))
    }, Promise.resolve())
      .then(() => {
        if (errored.length > 0) {
          let err = new Error(`Could not resolve some DOI's`);
          err.dois = errored;
          throw err
        } else {
          return entries
        }
      })
  }

  /*
    Fetch single entry for DOI
  */
  function _fetchDOI (doi) {
    const url = ENDPOINT + doi;
    return substance.sendRequest({url: url, method: 'GET', header: {'accept': 'application/vnd.citationstyles.csl+json'}})
  }

  const supportedFormats = ['CSL-JSON'];

  class ReferenceUploadComponent extends substance.Component {
    render ($$) {
      const labelProvider = this.context.labelProvider;
      const el = $$('div').addClass('se-import').append(
        $$('div').addClass('se-section-title').append(
          labelProvider.getLabel('import-refs')
        ),
        $$('div').addClass('se-description').append(
          labelProvider.getLabel('supported-ref-formats') + ': ' + supportedFormats.join(', ')
        )
      );

      const dropZone = $$('div').addClass('se-drop-import').append(
        'Drag and drop or ',
        $$('span').addClass('se-select-trigger')
          .append('select')
          .on('click', this._onClick),
        ' file',
        $$('input').attr('type', 'file')
          .on('click', this._supressClickPropagation)
          .on('change', this._selectFile)
          .ref('input')
      ).on('drop', this._handleDrop)
        .on('dragstart', this._onDrag)
        .on('dragenter', this._onDrag)
        .on('dragend', this._onDrag);

      el.append(dropZone);

      if (this.state.error) {
        const dois = this.state.error.dois;
        const errorsList = $$('ul').addClass('se-error-list');
        errorsList.append(
          $$('li').append(this.state.error.message)
        );
        if (dois) {
          errorsList.append(dois.map(d => $$('li').append('- ' + d)));
        }
        el.append(
          $$('div').addClass('se-error-popup').append(errorsList)
        );
      }

      return el
    }

    _onClick () {
      this.refs.input.click();
    }

    _supressClickPropagation (e) {
      e.stopPropagation();
    }

    _selectFile (e) {
      const files = e.currentTarget.files;
      this._handleUploadedFiles(files);
    }

    _handleDrop (e) {
      const files = e.dataTransfer.files;
      this._handleUploadedFiles(files);
    }

    _handleUploadedFiles (files) {
      Object.values(files).forEach(file => {
        const isJSON = file.type.indexOf('application/json') === 0;
        if (isJSON) {
          const reader = new window.FileReader();
          reader.onload = this._onFileLoad.bind(this);
          reader.readAsText(file);
        }
      });
    }

    _onFileLoad (e) {
      const res = e.target.result;
      if (res) {
        let conversionErrors = [];
        let convertedEntries = [];
        const entries = JSON.parse(res);
        entries.forEach(entry => {
          try {
            convertedEntries.push(
              convertCSLJSON(entry)
            );
          } catch (error) {
            conversionErrors.push(entry.DOI || error);
          }
        });

        if (conversionErrors.length > 0) {
          let error = new Error('Conversion error');
          error.dois = conversionErrors;
          this.extendState({error});
        } else {
          this.send('importBib', convertedEntries);
        }
      }
    }

    _onDrag (e) {
      // Stop event propagation for the dragstart and dragenter
      // events, to avoid editor drag manager errors
      e.stopPropagation();
    }
  }

  class AddReferenceWorkflow extends substance.Component {
    didMount () {
      super.didMount();

      this.handleActions({
        'importBib': this._onImport
      });
    }

    render ($$) {
      const labelProvider = this.context.labelProvider;

      let el = $$('div').addClass('se-add-reference');

      const title = $$('div').addClass('se-title').append(
        labelProvider.getLabel('add-reference-title')
      );

      const manualAddEl = $$('div').addClass('se-manual-add').append(
        $$('div').addClass('se-section-title').append(
          labelProvider.getLabel('add-ref-manually')
        )
      );

      const refTypesButtons = $$('ul').addClass('se-reftypes-list');
      INTERNAL_BIBR_TYPES.forEach(item => {
        refTypesButtons.append(
          $$('li').addClass('se-type sm-' + item).append(
            labelProvider.getLabel(item)
          ).on('click', this._onAdd.bind(this, item))
        );
      });
      manualAddEl.append(refTypesButtons);

      el.append(
        title,
        $$(DOIInputComponent),
        $$(ReferenceUploadComponent),
        manualAddEl
      );

      return el
    }

    _onImport (items) {
      const api = this.context.api;
      const references = api.getModelById('references');
      references.addItems(items);
      this.send('closeModal');
    }

    _onAdd (type) {
      const api = this.context.api;
      const references = api.getModelById('references');
      references.addItem({type: type});
      this.send('closeModal');
    }
  }

  class CardComponent extends substance.Component {
    didMount () {
      // Note: without a 'managed' approach every card component needs to listen to selection updates
      // TODO: consider to use a reducer that maps the selection to another variable, e.g. activeCard
      // then the cards would not be triggered on every other change
      this.context.appState.addObserver(['selection'], this._onSelectionChange, this, { stage: 'render' });
    }

    dispose () {
      this.context.appState.removeObserver(this);
    }

    render ($$) {
      const children = this.props.children;
      const label = this.getLabel(this.props.label);
      const el = $$('div').addClass('sc-card')
        .append(
          $$('div').addClass('se-label').append(label)
        );
      el.append(children);
      el.on('click', this._toggleCardSelection);
      return el
    }

    _toggleCardSelection () {
      this.context.api.selectModel(this.props.modelId);
    }

    _onSelectionChange (sel) {
      if (sel && sel.customType === 'model') {
        if (sel.data.modelId === this.props.modelId) {
          this.el.addClass('sm-selected');
        } else {
          this.el.removeClass('sm-selected');
        }
      } else {
        this.el.removeClass('sm-selected');
      }
    }
  }

  class EditReferenceWorkflow extends substance.Component {
    constructor (...args) {
      super(...args);
      this.handleActions({
        'remove-item': this._removeReference
      });
    }

    render ($$) {
      const model = this.props.model;
      const ItemEditor = this.getComponent(model.type, true) || NodeModelComponent;

      let el = $$('div').addClass('se-edit-reference').append(
        $$(CardComponent, { modeId: model.id }).append(
          $$(ItemEditor, {
            model: model
          })
        )
      );

      return el
    }

    _removeReference (model) {
      const api = this.context.api;
      const references = api.getModelById('references');
      references.removeItem(model);
      this.send('closeModal');
    }
  }

  class CollectionEditor extends ModelComponent {
    getActionHandlers () {
      return {
        'remove-item': this._removeCollectionItem
      }
    }

    render ($$) {
      const model = this.props.model;
      let items = model.getItems();
      let el = $$('div').addClass('sc-collection-editor');
      items.forEach(item => {
        let ItemEditor = this._getItemComponentClass(item);
        el.append(
          $$(CardComponent, {label: item.type, modelId: item.id}).append(
            $$(ItemEditor, {
              model: item,
              mode: METADATA_MODE,
              node: item._node
            }).ref(item.id)
          )
        );
      });
      return el
    }

    _getItemComponentClass (item) {
      let ItemComponent = this.getComponent(item.type, true);
      if (!ItemComponent) {
        // try to find a component registered for a parent type
        if (item._node) {
          ItemComponent = this._getParentTypeComponent(item._node);
        }
      }
      return ItemComponent || this.getComponent('entity')
    }

    _getParentTypeComponent (node) {
      let superTypes = node.getSchema().getSuperTypes();
      for (let type of superTypes) {
        let NodeComponent$$1 = this.getComponent(type, true);
        if (NodeComponent$$1) return NodeComponent$$1
      }
    }

    _removeCollectionItem (item) {
      const collection = this.props.model;
      collection.removeItem(item);
    }
  }

  /* eslint-disable no-template-curly-in-string */

  var EditorPackage = {
    name: 'ManscruptEditor',
    configure (config) {
      config.import(BasePackage);
      config.import(EditorBasePackage);
      config.import(ModelComponentPackage);
      config.import(ManuscriptContentPackage);
      config.import(substance.MultiSelectPackage);
      config.import(EntityLabelsPackage);
      config.import(ArticleNavPackage);
      config.import(PersistencePackage);
      config.import(FindAndReplacePackage);

      // EXPERIMENTAL:
      // a CommandManager that uses the xmlSchema to inhibit commands
      // which would generate disallowed content
      config.setCommandManagerClass(substance.SchemaDrivenCommandManager);

      config.addComponent('toc', TOC);
      config.addComponent('references', ReferenceListComponent);
      config.addComponent('footnotes', FootnoteGroupComponent);

      // overriding the default components for preview
      config.addComponent('figure', FigureComponent, true);
      config.addComponent('table-figure', FigureComponent, true);
      config.addComponent('fn', FootnoteComponent, true);
      config.addComponent('bibr', ReferenceComponent, true);

      // TODO: try to get rid of this one
      config.addComponent('collection', CollectionEditor);

      // Commands
      config.addCommand('edit-xref', substance.EditInlineNodeCommand, {
        nodeType: 'xref',
        commandGroup: 'prompt'
      });
      config.addCommand('insert-xref-bibr', InsertXrefCommand, {
        refType: 'bibr',
        commandGroup: 'insert-xref'
      });
      config.addCommand('insert-xref-fig', InsertXrefCommand, {
        refType: 'fig',
        commandGroup: 'insert-xref'
      });
      config.addCommand('insert-xref-table', InsertXrefCommand, {
        refType: 'table',
        commandGroup: 'insert-xref'
      });
      config.addCommand('insert-xref-fn', InsertXrefCommand, {
        refType: 'fn',
        commandGroup: 'insert-xref'
      });
      config.addCommand('insert-disp-quote', InsertDispQuoteCommand, {
        nodeType: 'disp-quote',
        commandGroup: 'insert'
      });
      config.addCommand('insert-fig', InsertFigureCommand, {
        nodeType: 'fig',
        commandGroup: 'insert'
      });
      config.addCommand('insert-table', InsertTableCommand, {
        nodeType: 'table-wrap',
        commandGroup: 'insert'
      });
      config.addCommand('insert-formula', InsertInlineFormulaCommand, {
        commandGroup: 'insert'
      });
      config.addCommand('edit-formula', substance.EditInlineNodeCommand, {
        nodeType: 'inline-formula',
        commandGroup: 'prompt'
      });
      config.addCommand('decrease-heading-level', DecreaseHeadingLevelCommand, {
        commandGroup: 'text-level'
      });
      config.addCommand('increase-heading-level', IncreaseHeadingLevelCommand, {
        commandGroup: 'text-level'
      });
      config.addKeyboardShortcut('shift+tab', { command: 'decrease-heading-level' });
      config.addKeyboardShortcut('tab', { command: 'increase-heading-level' });

      config.addCommand('table:select-all', TableSelectAllCommand);
      config.addKeyboardShortcut('CommandOrControl+a', { command: 'table:select-all' });

      config.addCommand('toggle-cell-heading', ToggleCellHeadingCommand, {
        commandGroup: 'table'
      });
      config.addCommand('toggle-cell-merge', ToggleCellMergeCommand, {
        commandGroup: 'table'
      });
      config.addCommand('insert-columns-left', InsertCellsCommand, {
        spec: { dim: 'col', pos: 'left' },
        commandGroup: 'table-insert'
      });
      config.addCommand('insert-columns-right', InsertCellsCommand, {
        spec: { dim: 'col', pos: 'right' },
        commandGroup: 'table-insert'
      });
      config.addCommand('insert-rows-above', InsertCellsCommand, {
        spec: { dim: 'row', pos: 'above' },
        commandGroup: 'table-insert'
      });
      config.addCommand('insert-rows-below', InsertCellsCommand, {
        spec: { dim: 'row', pos: 'below' },
        commandGroup: 'table-insert'
      });
      config.addCommand('delete-columns', DeleteCellsCommand, {
        spec: { dim: 'col' },
        commandGroup: 'table-delete'
      });
      config.addCommand('delete-rows', DeleteCellsCommand, {
        spec: { dim: 'row' },
        commandGroup: 'table-delete'
      });

      config.addLabel('cite', 'Cite');
      config.addLabel('insert-xref-bibr', 'Reference');
      config.addLabel('insert-xref-fig', 'Figure');
      config.addLabel('insert-xref-table', 'Table');
      config.addLabel('insert-xref-fn', 'Footnote');
      config.addLabel('insert-disp-quote', 'Blockquote');

      config.addLabel('manuscript-start', 'Article starts here');
      config.addLabel('manuscript-end', 'Article ends here');
      config.addLabel('sig-block-start', 'Signature Block starts here');
      config.addLabel('sig-block-end', 'Signature Block ends here');

      config.addLabel('insert-rows-above', {
        en: 'Insert ${nrows} rows above'
      });
      config.addLabel('insert-rows-below', {
        en: 'Insert ${nrows} rows below'
      });
      config.addLabel('insert-columns-left', {
        en: 'Insert ${ncols} columns left'
      });
      config.addLabel('insert-columns-right', {
        en: 'Insert ${ncols} columns right'
      });
      config.addLabel('delete-rows', {
        en: 'Delete ${nrows} rows'
      });
      config.addLabel('delete-columns', {
        en: 'Delete ${ncols} columns'
      });
      config.addLabel('toggle-cell-heading', {
        en: 'Cell heading'
      });
      config.addLabel('toggle-cell-merge', {
        en: 'Merge cell'
      });

      // Tools
      config.addTool('edit-xref', EditXRefTool);

      config.addTool('insert-fig', InsertFigureTool);
      config.addDropHandler(DropFigure);
      config.addLabel('insert-fig', 'Figure');
      config.addIcon('insert-fig', { 'fontawesome': 'fa-image' });

      config.addTool('insert-table', InsertTableTool);
      config.addLabel('insert-table', 'Table');
      config.addIcon('insert-table', { 'fontawesome': 'fa-table' });

      config.addTool('edit-formula', EditInlineFormulaTool);
      config.addLabel('insert-formula', 'Formula');
      config.addIcon('insert-formula', { 'fontawesome': 'fa-dollar' });

      config.addIcon('insert-disp-quote', { 'fontawesome': 'fa-quote-right' });

      config.addIcon('toggle-cell-merge', {
        'fontawesome': 'fa-arrows-h'
      });
      config.addIcon('toggle-cell-heading', { 'fontawesome': 'fa-th-large' });

      // Annotation tools
      config.addAnnotationTool({
        name: 'bold',
        nodeType: 'bold',
        commandGroup: 'formatting',
        icon: 'fa-bold',
        label: 'Strong',
        accelerator: 'CommandOrControl+B'
      });

      config.addAnnotationTool({
        name: 'italic',
        nodeType: 'italic',
        commandGroup: 'formatting',
        icon: 'fa-italic',
        label: 'Emphasize',
        accelerator: 'CommandOrControl+I'
      });

      config.addAnnotationTool({
        name: 'ext-link',
        nodeType: 'ext-link',
        commandGroup: 'formatting',
        command: InsertExtLinkCommand,
        icon: 'fa-link',
        label: 'Link',
        accelerator: 'CommandOrControl+K'
      });

      config.addAnnotationTool({
        name: 'sub',
        nodeType: 'sub',
        commandGroup: 'formatting',
        icon: 'fa-subscript',
        label: 'Subscript'
      });

      config.addAnnotationTool({
        name: 'sup',
        nodeType: 'sup',
        commandGroup: 'formatting',
        icon: 'fa-superscript',
        label: 'Superscript'
      });

      config.addAnnotationTool({
        name: 'monospace',
        nodeType: 'monospace',
        commandGroup: 'formatting',
        icon: 'fa-code',
        label: 'Monospace'
      });

      config.addTextTypeTool({
        name: 'heading1',
        commandGroup: 'text-types',
        nodeSpec: {
          type: 'heading',
          attributes: { level: '1' }
        },
        icon: 'fa-header',
        label: 'Heading 1',
        accelerator: 'CommandOrControl+Alt+1'
      });

      config.addTextTypeTool({
        name: 'heading2',
        commandGroup: 'text-types',
        nodeSpec: {
          type: 'heading',
          attributes: { level: '2' }
        },
        icon: 'fa-header',
        label: 'Heading 2',
        accelerator: 'CommandOrControl+Alt+2'
      });

      config.addTextTypeTool({
        name: 'heading3',
        commandGroup: 'text-types',
        nodeSpec: {
          type: 'heading',
          attributes: { level: '3' }
        },
        icon: 'fa-header',
        label: 'Heading 3',
        accelerator: 'CommandOrControl+Alt+3'
      });

      config.addTextTypeTool({
        name: 'paragraph',
        commandGroup: 'text-types',
        nodeSpec: {
          type: 'p'
        },
        icon: 'fa-paragraph',
        label: 'Paragraph',
        accelerator: 'CommandOrControl+Alt+0'
      });

      config.addCommand('edit-ext-link', substance.EditAnnotationCommand, {
        nodeType: 'ext-link',
        commandGroup: 'prompt'
      });

      // ExtLink
      config.addTool('edit-ext-link', EditExtLinkTool);
      config.addIcon('open-link', { 'fontawesome': 'fa-external-link' });
      config.addLabel('open-link', 'Open Link');

      // Lists
      config.addCommand('toggle-unordered-list', ToggleListCommand, {
        spec: { listType: 'bullet' },
        commandGroup: 'list'
      });
      config.addKeyboardShortcut('CommandOrControl+Shift+8', { command: 'toggle-unordered-list' });
      config.addLabel('toggle-unordered-list', {
        en: 'Bulleted list',
        de: 'Liste'
      });
      config.addIcon('toggle-unordered-list', { 'fontawesome': 'fa-list-ul' });

      config.addCommand('toggle-ordered-list', ToggleListCommand, {
        spec: { listType: 'order' },
        commandGroup: 'list'
      });
      config.addKeyboardShortcut('CommandOrControl+Shift+7', { command: 'toggle-ordered-list' });
      config.addLabel('toggle-ordered-list', {
        en: 'Numbered list',
        de: 'Aufzhlung'
      });
      config.addIcon('toggle-ordered-list', { 'fontawesome': 'fa-list-ol' });

      config.addCommand('indent-list', substance.ListPackage.IndentListCommand, {
        spec: { action: 'indent' },
        commandGroup: 'list'
      });
      config.addLabel('indent-list', {
        en: 'Increase indentation',
        de: 'Einrckung vergrern'
      });
      config.addIcon('indent-list', { 'fontawesome': 'fa-indent' });

      config.addCommand('dedent-list', substance.ListPackage.IndentListCommand, {
        spec: { action: 'dedent' },
        commandGroup: 'list'
      });
      config.addLabel('dedent-list', {
        en: 'Decrease indentation',
        de: 'Einrckung verringern'
      });
      config.addIcon('dedent-list', { 'fontawesome': 'fa-dedent' });

      config.addToolPanel('toolbar', [
        {
          name: 'undo-redo',
          type: 'tool-group',
          showDisabled: true,
          style: 'minimal',
          items: [
            { type: 'command-group', name: 'undo-redo' }
          ]
        },
        {
          name: 'persistence',
          type: 'tool-group',
          showDisabled: true,
          style: 'minimal',
          items: [
            { type: 'command-group', name: 'persistence' }
          ]
        },
        {
          name: 'text-types',
          type: 'tool-dropdown',
          showDisabled: false,
          style: 'descriptive',
          items: [
            { type: 'command-group', name: 'text-types' }
          ]
        },
        {
          name: 'annotations',
          type: 'tool-group',
          showDisabled: true,
          style: 'minimal',
          items: [
            { type: 'command-group', name: 'formatting' }
          ]
        },
        {
          name: 'additinal-tools',
          type: 'tool-group',
          showDisabled: true,
          style: 'minimal',
          items: [
            { type: 'command-group', name: 'insert' }
          ]
        },
        {
          name: 'list',
          type: 'tool-group',
          showDisabled: false,
          style: 'minimal',
          items: [
            { type: 'command-group', name: 'list' }
          ]
        },
        {
          name: 'table',
          type: 'tool-group',
          showDisabled: false,
          style: 'minimal',
          items: [
            { type: 'command-group', name: 'table' }
          ]
        },
        {
          name: 'cite',
          type: 'tool-dropdown',
          showDisabled: true,
          style: 'descriptive',
          items: [
            { type: 'command-group', name: 'insert-xref' }
          ]
        },
        {
          name: 'view',
          type: 'tool-dropdown',
          showDisabled: false,
          style: 'descriptive',
          items: [
            { type: 'command-group', name: 'toggle-content-section' },
            { type: 'command-group', name: 'view' }
          ]
        },
        {
          name: 'mode',
          type: 'tool-dropdown',
          showDisabled: false,
          style: 'full',
          items: [
            { type: 'command-group', name: 'switch-view' }
          ]
        }
      ]);

      config.addToolPanel('main-overlay', [
        {
          name: 'prompt',
          type: 'tool-prompt',
          showDisabled: false,
          items: [
            { type: 'command-group', name: 'prompt' }
          ]
        }
      ]);

      config.addToolPanel('context-menu', [
        {
          name: 'context-menu',
          type: 'tool-group',
          showDisabled: false,
          style: 'descriptive',
          items: [
            { type: 'command-group', name: 'table-structure' }
          ]
        }
      ]);

      config.addToolPanel('table-context-menu', [
        {
          name: 'table-tools',
          type: 'tool-group',
          showDisabled: false,
          style: 'descriptive',
          items: [
            { type: 'command-group', name: 'table' }
          ]
        },
        { type: 'tool-separator' },
        {
          name: 'table-insert',
          type: 'tool-group',
          showDisabled: false,
          style: 'descriptive',
          items: [
            { type: 'command-group', name: 'table-insert' }
          ]
        },
        { type: 'tool-separator' },
        {
          name: 'table-delete',
          type: 'tool-group',
          showDisabled: false,
          style: 'descriptive',
          items: [
            { type: 'command-group', name: 'table-delete' }
          ]
        }
      ]);

      config.addToolPanel('workflow', [
        {
          name: 'workflow',
          type: 'tool-group',
          items: [
            { type: 'command-group', name: 'workflows' }
          ]
        }
      ]);

      // Labels for groups
      config.addLabel('structure', 'Structure');
      config.addLabel('article-info', 'Article Information');

      // Labels for panels
      config.addLabel('toc', 'Table of Contents');
      config.addLabel('article-record', 'Article Record');
      config.addLabel('contributors', 'Authors & Contributors');
      config.addLabel('translations', 'Translations');
      config.addLabel('pub-data', 'Publication Data');
      config.addLabel('edit-ref', 'Edit Reference');

      // Labels for empty lists
      config.addLabel('no-authors', 'No Authors');
      config.addLabel('no-editors', 'No Editors');
      config.addLabel('no-references', 'No References');
      config.addLabel('no-footnotes', 'No Footnotes');

      // Labels for buttons
      config.addLabel('add-ref', 'Add Reference');
      config.addLabel('edit-ref', 'Edit');
      config.addLabel('remove-ref', 'Remove');

      // Workflows
      config.addComponent('add-reference', AddReferenceWorkflow);
      config.addLabel('add-reference-title', 'Add Reference(s)');
      config.addLabel('add-ref-manually', 'Or create manually');
      config.addLabel('fetch-datacite', 'Fetch from DataCite');
      config.addLabel('enter-doi-placeholder', 'Enter one or more DOIs');
      config.addLabel('doi-fetch-action', 'Add');
      config.addLabel('import-refs', 'Import');
      config.addLabel('supported-ref-formats', 'Supported formats');
      config.addComponent('edit-reference', EditReferenceWorkflow);

      config.addIcon('pencil', {
        'fontawesome': 'fa-pencil'
      });

      config.addIcon('trash', {
        'fontawesome': 'fa-trash'
      });
    },
    ManuscriptEditor,
    // legacy
    Editor: ManuscriptEditor
  }

  class SaveHandler {
    constructor (context) {
      this.context = context;
    }

    saveDocument ({editorSession}) {
      return new Promise((resolve) => {
        let exporter = this.context.exporter;
        let doc = editorSession.getDocument();
        let dom = doc.toXML();
        let result = exporter.export(dom);
        if (result.hasErrored) {
          console.error(result.errors);
          throw new Error('Could not export JATS document')
        }
        console.info(result.dom.getNativeElement());
        // let xml = result.dom.serialize()
        resolve();
      })
    }
  }

  /*
    TODO: discuss

    There is a sophisticated cross-referencing package for latex
    that we took as inspiration: http://mirror.easyname.at/ctan/macros/latex/contrib/cleveref/cleveref.pdf

    This generator needs a set of configurations:

    - name: e.g. 'Figure'
    - plural: e.g. 'Figures'
    - and: e.g, ", ", or " and "
    - to: e.g, "--", or " to "
    - template: outer template, e.g. "[$]" could be used to generate "[1-3,4]"
    - groupTemplate: inner template, e.g. "[$]" could be used to generate "[1-3],[4]"

  */
  const HYPHEN = '';

  class NumberedLabelGenerator {
    constructor (config = {}) {
      // for labels with a type name such as 'Figure 1'
      this.name = config.name;
      // for labels with type name, with multiple refs, such as 'Figures 1-3'
      this.plural = config.plural;
      // used to join found groups
      this.and = config.and || ',';
      // used to render a single group
      this.to = config.to || HYPHEN;
      // a string where '$' will be replaced
      // this can be used to wrap the generated string,
      // e.g. "[$]" could be used to generate "[1-3,4]"
      this.template = config.template;
      // a string where '$' will be replaced
      // e.g "[$]" could be used to generate "[1-3],[4]"
      this.groupTemplate = config.groupTemplate;
      this.invalid = config.invalid || '???';
    }

    getLabel (numbers) {
      if (!numbers) return this.invalid
      if (!substance.isArray(numbers)) numbers = [numbers];
      if (numbers.length === 0) return this.invalid

      const L = numbers.length;
      numbers.sort();

      let frags = [];
      if (this.name) {
        if (L === 1) {
          frags.push(this.name);
        } else {
          frags.push(this.plural || this.name);
        }
        frags.push(' ');
      }

      // detect groups such as [1,2,3], [6], [8,9]
      let groups = [];
      let group = null;
      const _pushBlock = (g) => {
        if (!substance.isArray(g)) g = [g];
        let str;
        if (g.length === 1) {
          str = String(g[0]);
        } else if (g.length === 2) {
          _pushBlock(g[0]);
          _pushBlock(g[1]);
          return
        } else {
          // join with the 'to' operator, i.e. [1,2,3] => "1 to 3"
          str = String(g[0]) + this.to + String(substance.last(g));
        }
        if (this.groupTemplate) {
          str = this.groupTemplate.slice(0).replace('$', str);
        }
        groups.push(str);
      };
      for (let i = 0; i < L; i++) {
        let n = numbers[i];
        if (n === numbers[i - 1] + 1) {
          group.push(n);
        } else {
          if (group) {
            _pushBlock(group);
          }
          group = [n];
        }
      }
      _pushBlock(group);

      // join all groups with the 'and' operator
      // such as ["1-3", "5"] => "1-3, 4"
      frags.push(groups.join(this.and));

      let res = frags.join('');
      if (this.template) {
        res = this.template.slice(0).replace('$', res);
      }
      return res
    }
  }

  function removeElementAndXrefs (articleSession, elementId, parentEl) {
    let doc = articleSession.getDocument();
    let xrefIndex = doc.getIndex('xrefs');
    let xrefs = xrefIndex.get(elementId);

    if (xrefs.length === 0 || window.confirm(`Deleting this will affect ${xrefs.length} citations. Are you sure?`)) { // eslint-disable-line
      articleSession.transaction(tx => {
        let node = tx.get(elementId);
        // ATTENTION: it is important to nodes from the transaction tx!
        // Be careful with closures here.
        parentEl = tx.get(parentEl.id);
        parentEl.removeChild(node);
        tx.delete(node.id);
        // Now update xref targets
        xrefs.forEach((xrefId) => {
          let xref = tx.get(xrefId);
          let idrefs = xref.attr('rid').split(' ');
          idrefs = substance.without(idrefs, elementId);
          xref.setAttribute('rid', idrefs.join(' '));
        });
        tx.setSelection(null);
      });
    }
  }

  class TableEditing {
    constructor (editorSession, tableId, surfaceId) {
      this.editorSession = editorSession;
      this.tableId = tableId;
      this.surfaceId = surfaceId;
    }

    getTable () {
      return this.editorSession.getDocument().get(this.tableId)
    }

    getSelectionData () {
      return getSelectionData(this.editorSession.getSelection())
    }

    getSelectedRange () {
      return getSelectedRange(this.getTable(), this.getSelectionData())
    }

    insertRows (pos, count) {
      this.editorSession.transaction((tx) => {
        this._createRowsAt(this._getTable(tx), pos, count);
      }, { action: 'insertRows', pos, count });
    }

    insertCols (pos, count) {
      this.editorSession.transaction((tx) => {
        this._createColumnsAt(this._getTable(tx), pos, count);
      }, { action: 'insertCols', pos, count });
    }

    deleteRows (pos, count) {
      this.editorSession.transaction((tx) => {
        this._deleteRows(this._getTable(tx), pos, pos + count - 1);
        tx.selection = null;
      }, { action: 'deleteRows', pos, count });
    }

    deleteCols (pos, count) {
      this.editorSession.transaction((tx) => {
        this._deleteCols(this._getTable(tx), pos, pos + count - 1);
        tx.selection = null;
      }, { action: 'deleteCols', pos, count });
    }

    setCell (cellId, val) {
      this.editorSession.transaction(tx => {
        let table = this._getTable(tx);
        let cell = table.get(cellId);
        if (cell) {
          if (cell.shadowed) throw new Error('Can not change a shadowed cell')
          cell.textContent = val;
          let sel = this.createTableSelection({
            type: 'range',
            anchorCellId: cell.id,
            focusCellId: cell.id
          });
          tx.setSelection(sel);
        }
      }, { action: 'setCell' });
    }

    editCell (cellId, newVal) {
      if (substance.isString(newVal)) {
        this.editorSession.transaction(tx => {
          let cell = tx.get(cellId);
          let path = cell.getPath();
          cell.textContent = newVal;
          tx.setSelection({
            type: 'property',
            path,
            startOffset: newVal.length,
            surfaceId: this.surfaceId + '/' + path.join('.')
          });
        });
      } else {
        let doc = this.editorSession.getDocument();
        let cell = doc.get(cellId);
        let path = cell.getPath();
        this.editorSession.setSelection({
          type: 'property',
          path,
          startOffset: cell.getLength(),
          surfaceId: this.surfaceId + '/' + path.join('.')
        });
      }
    }

    setValues (anchorCellId, vals) {
      let n = vals.length;
      let m = vals[0].length;
      let table = this.getTable();
      let { startRow, startCol } = getCellRange(table, anchorCellId, anchorCellId);
      this.ensureSize(startRow + n, startCol + m);
      let lastCell = table.getCell(startRow + n - 1, startCol + m - 1);
      if (lastCell.shadowed) lastCell = lastCell.masterCell;
      this.editorSession.transaction(tx => {
        let table = this._getTable(tx);
        this._setValues(table, startRow, startCol, vals);
        let sel = this.createTableSelection({
          type: 'range',
          anchorCellId,
          focusCellId: lastCell.id
        });
        tx.setSelection(sel);
      }, { action: 'setValues' });
    }

    clearValues (anchorCellId, focusCellId) {
      let table = this.getTable();
      let { startRow, endRow, startCol, endCol } = getCellRange(table, anchorCellId, focusCellId);
      this.editorSession.transaction(tx => {
        // Note: the selection remains the same
        this._clearValues(this._getTable(tx), startRow, startCol, endRow, endCol);
      });
    }

    ensureSize (nrows, ncols) {
      let table = this._getTable(this.editorSession.getDocument());
      let [_nrows, _ncols] = table.getDimensions();
      if (_ncols < ncols) {
        this.insertCols(_ncols, ncols - _ncols);
      }
      if (_nrows < nrows) {
        this.insertRows(_nrows, nrows - _nrows);
      }
    }

    insertSoftBreak () {
      this.editorSession.transaction(tx => {
        tx.insertText('\n');
      }, 'insertSoftBreak');
    }

    setHeading (cellIds, heading) {
      let doc = this.editorSession.getDocument();
      cellIds = cellIds.filter(id => {
        let cell = doc.get(id);
        let val = cell.getAttribute('heading');
        return Boolean(val) !== heading
      });
      if (cellIds.length === 0) return
      this.editorSession.transaction(tx => {
        cellIds.forEach(id => {
          let cell = tx.get(id);
          if (heading) {
            cell.setAttribute('heading', true);
          } else {
            cell.removeAttribute('heading');
          }
        });
      }, { action: 'setHeading' });
    }

    merge () {
      let table = this.getTable();
      let { startRow, endRow, startCol, endCol } = this.getSelectedRange();
      let bigOne = table.getCell(startRow, startCol);
      // compute the span by walking all non-shadowed cells
      for (let i = startRow; i <= endRow; i++) {
        for (let j = startCol; j <= endCol; j++) {
          let cell = table.getCell(i, j);
          if (cell.shadowed) continue
          let rowspan = cell.rowspan;
          let colspan = cell.colspan;
          if (rowspan > 1) {
            endRow = Math.max(endRow, i + rowspan - 1);
          }
          if (colspan > 1) {
            endCol = Math.max(endCol, j + colspan - 1);
          }
        }
      }
      // Note: spans should be >= 1, i.e. rowspan=1 means no spanning
      let rowspan = endRow - startRow + 1;
      let colspan = endCol - startCol + 1;
      if (bigOne.rowspan !== rowspan || bigOne.colspan !== colspan) {
        this.editorSession.transaction(tx => {
          let cell = tx.get(bigOne.id);
          cell.setAttribute('rowspan', rowspan);
          cell.setAttribute('colspan', colspan);
        }, { action: 'mergeCells' });
      }
    }

    unmerge () {
      let table = this.getTable();
      let { startRow, endRow, startCol, endCol } = this.getSelectedRange();
      let cellIds = [];
      for (let i = startRow; i <= endRow; i++) {
        for (let j = startCol; j <= endCol; j++) {
          let cell = table.getCell(i, j);
          let rowspan = cell.rowspan;
          let colspan = cell.colspan;
          if (rowspan > 1 || colspan > 1) {
            cellIds.push(cell.id);
          }
        }
      }
      if (cellIds.length > 0) {
        this.editorSession.transaction(tx => {
          cellIds.forEach(id => {
            let cell = tx.get(id);
            cell.removeAttribute('rowspan');
            cell.removeAttribute('colspan');
          });
        }, { action: 'unmergeCells' });
      }
    }

    _getTable (tx) {
      return tx.get(this.tableId)
    }

    createTableSelection (data) {
      let sel = createTableSelection(data);
      sel.data.nodeId = this.tableId;
      sel.surfaceId = this.surfaceId;
      return sel
    }

    selectAll () {
      let table = this.getTable();
      let [N, M] = table.getDimensions();
      if (N === 0 || M === 0) return
      let anchorCell = table.getCell(0, 0);
      let focusCell = table.getCell(N - 1, M - 1);
      if (focusCell.shadowed) {
        focusCell = focusCell.masterCell;
      }
      this.editorSession.setSelection(this.createTableSelection({
        type: 'range',
        anchorCellId: anchorCell.id,
        focusCellId: focusCell.id
      }));
    }

    _setValues (table, startRow, startCol, vals) {
      for (let i = 0; i < vals.length; i++) {
        let row = vals[i];
        for (let j = 0; j < row.length; j++) {
          let val = row[j];
          let cell = table.getCell(startRow + i, startCol + j);
          cell.textContent = val;
          // HACK: for now we remove merge
          cell.removeAttribute('rowspan');
          cell.removeAttribute('colspan');
        }
      }
    }

    _clearValues (table, startRow, startCol, endRow, endCol) {
      for (let rowIdx = startRow; rowIdx <= endRow; rowIdx++) {
        for (let colIdx = startCol; colIdx <= endCol; colIdx++) {
          let cell = table.getCell(rowIdx, colIdx);
          cell.textContent = '';
        }
      }
    }

    _setCellTypesForRange (table, startRow, startCol, endRow, endCol, type) {
      for (let rowIdx = startRow; rowIdx <= endRow; rowIdx++) {
        for (let colIdx = startCol; colIdx <= endCol; colIdx++) {
          let cell = table.getCell(rowIdx, colIdx);
          cell.attr({type: type});
        }
      }
    }

    _getCreateElement (table) {
      const doc = table.getDocument();
      return doc.createElement.bind(doc)
    }

    _createRowsAt (table, rowIdx, n) {
      let $$ = this._getCreateElement(table);
      const M = table.getColumnCount();
      let rowAfter = table.getChildAt(rowIdx);
      for (let i = 0; i < n; i++) {
        let row = $$('table-row');
        for (let j = 0; j < M; j++) {
          let cell = $$('table-cell');
          row.append(cell);
        }
        table.insertBefore(row, rowAfter);
      }
    }

    _deleteRows (table, startRow, endRow) {
      for (let rowIdx = endRow; rowIdx >= startRow; rowIdx--) {
        let row = table.getChildAt(rowIdx);
        table.removeChild(row);
        substance.documentHelpers.deleteNode(table.getDocument(), row);
      }
    }

    _deleteCols (table, startCol, endCol) {
      let N = table.getRowCount();
      for (let rowIdx = N - 1; rowIdx >= 0; rowIdx--) {
        let row = table.getChildAt(rowIdx);
        for (let colIdx = endCol; colIdx >= startCol; colIdx--) {
          let cell = row.getChildAt(colIdx);
          row.removeAt(colIdx);
          substance.documentHelpers.deleteNode(table.getDocument(), cell);
        }
      }
    }

    _createColumnsAt (table, colIdx, n) {
      let $$ = this._getCreateElement(table);
      let rowIt = table.getChildNodeIterator();
      while (rowIt.hasNext()) {
        let row = rowIt.next();
        let cellAfter = row.getChildAt(colIdx);
        for (let j = 0; j < n; j++) {
          let cell = $$('table-cell');
          row.insertBefore(cell, cellAfter);
        }
      }
    }
  }

  class SwitchViewCommand extends substance.Command {
    getCommandState (params, context) {
      let state = context.appState;
      if (!state) {
        return substance.Command.DISABLED
      }
      let viewName = state.viewName;
      let active = (viewName === this.config.viewName);
      return {
        disabled: false,
        active
      }
    }

    execute (params, context) {
      let state = context.appState;
      if (state) {
        state.viewName = this.config.viewName;
        state.propagate();
      }
    }
  }

  class TextureConfigurator extends substance.Configurator {
    constructor () {
      super();

      this.config.configurations = {};
      this.config.availableLanguages = {};
      this.config.propertyEditors = [];
      this._compiledToolPanels = {};
    }

    static createFrom (parentConfig) {
      let ConfiguratorClass = this;
      let config = new ConfiguratorClass();
      substance.merge(config, parentConfig);
      return config
    }

    createScope (name) {
      let ConfiguratorClass = this.constructor;
      let scope = new ConfiguratorClass();
      this.setConfiguration(name, scope);
      return scope
    }

    setConfiguration (name, config) {
      this.config.configurations[name] = config;

      config._name = this._name ? this._name + '/' + name : name;
    }

    getConfiguration (name) {
      return this.config.configurations[name]
    }

    getComponentRegistry () {
      if (!this.componentRegistry) {
        this.componentRegistry = super.getComponentRegistry();
      }
      return this.componentRegistry
    }

    getComponent (name) {
      return this.getComponentRegistry().get(name, 'strict')
    }

    /*
      Map an XML node type to a model
    */
    addModel (modelType, ModelClass) {
      if (this.config.models[modelType]) {
        throw new Error(`model type ${modelType} already registered.`)
      }
      this.config.models[modelType] = ModelClass;
    }

    getModelRegistry () {
      return this.config.models
    }

    addPropertyEditor (PropertyEditorClass) {
      if (substance.includes(this.config.propertyEditors, PropertyEditorClass)) {
        throw new Error('Already registered')
      }
      this.config.propertyEditors.push(PropertyEditorClass);
    }

    getPropertyEditors () {
      return this.config.propertyEditors
    }

    addTool (name, ToolClass) {
      if (!substance.isString(name)) {
        throw new Error("Expecting 'name' to be a String")
      }
      if (!ToolClass) {
        throw new Error('Provided nil for tool ' + name)
      }
      if (!ToolClass || !ToolClass.prototype._isTool) {
        throw new Error("Expecting 'ToolClass' to be of type Tool. name:", name)
      }

      this.config.tools[name] = ToolClass;
    }

    getToolRegistry () {
      let result = new Map();
      substance.forEach(this.config.tools, (ToolClass, name) => {
        result.set(name, ToolClass);
      });
      return result
    }

    getToolClass (name) {
      return this.config.tools[name]
    }

    addToolPanel (name, spec) {
      this.config.toolPanels[name] = spec;
    }

    getToolPanel (name, strict) {
      let toolPanelSpec = this.config.toolPanels[name];
      if (toolPanelSpec) {
        // return cache compiled tool-panels
        if (this._compiledToolPanels[name]) return this._compiledToolPanels[name]
        let toolPanel = toolPanelSpec.map(itemSpec => this._compileToolPanelItem(itemSpec));
        this._compiledToolPanels[name] = toolPanel;
        return toolPanel
      } else if (strict) {
        throw new Error(`No toolpanel configured with name ${name}`)
      }
    }

    addViewMode (spec) {
      this.addCommand(spec.name, SwitchViewCommand, {
        viewName: spec.viewName,
        commandGroup: 'switch-view'
      });
      this.addIcon(spec.name, { 'fontawesome': spec.icon });
      this.addLabel(spec.name, spec.label);
      if (spec.accelerator) {
        this.addKeyboardShortcut(spec.accelerator, { command: spec.name });
      }
    }

    getCommands () {
      let commands = new Map();
      substance.forEach(this.config.commands, (item, name) => {
        const Command = item.CommandClass;
        let command = new Command(Object.assign({name: name}, item.options));
        commands.set(name, command);
      });
      return commands
    }

    getCommandGroup (name) {
      let commandGroup = this.config.commandGroups[name];
      if (!commandGroup) {
        console.warn('No command group registered by this name: ' + name);
        commandGroup = [];
      }
      return commandGroup
    }

    registerLanguage (code, name) {
      this.config.availableLanguages[code] = name;
    }

    getAvailableLanguages () {
      return this.config.availableLanguages
    }

    getConverters (type) {
      let registry = new substance.Registry();
      substance.forEach(this.config.converters[type], (Converter, type) => {
        registry.add(type, Converter);
      });
      return registry
    }

    _compileToolPanelItem (itemSpec) {
      let item = Object.assign({}, itemSpec);
      let type = itemSpec.type;
      switch (type) {
        case 'command-group':
          return this.getCommandGroup(itemSpec.name).map(commandName => {
            return { commandName }
          })
        case 'tool-prompt':
        case 'tool-group':
        case 'tool-dropdown':
          item.items = substance.flatten(itemSpec.items.map(itemSpec => this._compileToolPanelItem(itemSpec)));
          break
        case 'tool-separator':
          break
        default:
          throw new Error('Unsupported tool panel item type: ' + type)
      }
      return item
    }
  }

  class ArticleHTMLExporter extends substance.HTMLExporter {
    constructor (configurator) {
      super({
        converters: _getConverters(configurator),
        idAttribute: 'data-id',
        elementFactory: substance.DefaultDOMElement.createDocument('html')
      });
    }

    /*
      Customised annotatedText method, that takes a document and $$ to be
      compatible with other rendering contexts
    */
    annotatedText (path, doc, $$) {
      if (doc) {
        this.state.doc = doc;
      }
      if ($$) {
        this.$$ = $$;
      }
      return super.annotatedText(path)
    }
  }

  // TODO: we should improve the configurators internal format, e.g. use Map instead of {}
  function _getConverters (configurator) {
    return configurator.getConverters('html')
  }

  class ArticleHTMLImporter extends substance.HTMLImporter {
    constructor (configurator) {
      super({
        schema: InternalArticleSchema,
        // HACK: in contrast to DOMExporter, DOMImporter takes an array of converters, instead of a Registry
        converters: _getConverters$1(configurator),
        idAttribute: 'data-id'
      });
    }

    // TODO: it is necessary to set the document instance so that the importer is creating nodes for this document
    setDocument (doc) {
      this.reset();
      this.state.doc = doc;
    }

    _getConverterForElement (el, mode) {
      let converter = super._getConverterForElement(el, mode);
      // apply a fallback
      if (!converter) {
        if (mode !== 'inline') {
          return UnsupportedElementImporter
        }
      }
      return converter
    }
  }

  // TODO: we should improve the configurators internal format, e.g. use Map instead of {}
  function _getConverters$1 (configurator) {
    return configurator.getConverters('html').values()
  }

  const UnsupportedElementImporter = {
    type: 'p',
    import (el, node, converter) {
      node.content = converter.annotatedText(el, [node.id, 'content'], { preserveWhitespace: true });
    }
  };

  class ArticlePlainTextExporter {
    export (article) {
      console.error('TODO: implement full article to plain-text conversion');
    }

    exportNode (node) {
      if (node.isContainer()) {
        return this._exportContainer(node)
      } else if (node.isText()) {
        return this._exportText(node.getDocument(), node.getPath())
      } else {
        switch (node.type) {
          case 'figure':
            return this._exportFigure(node)
          case 'table':
            return this._exportTable(node)
          case 'table-figure':
            return this._exportTableFigure(node)
          default:
            //
        }
      }

      if (node._isXMLNode) {
        return node.toXML().textContent || ''
      } else {
        console.error('TODO: implement node -> plain-text conversion for node type', node.type);
        return ''
      }
    }

    _exportContainer (node) {
      if (!node) return ''
      return node.getNodes().map(node => {
        return this.exportNode(node)
      }).join('\n\n')
    }

    _exportText (doc, path) {
      return doc.get(path) || ''
    }

    _exportTable (node) {
      if (!node) return ''
      return node.getCellMatrix().map(row => {
        return row.map(cell => {
          if (cell.isShadowed()) {
            return ''
          } else {
            return cell.getText()
          }
        }).join('\t')
      }).join('\n')
    }

    _exportFigure (node) {
      if (!node) return ''
      let doc = node.getDocument();
      let result = [];
      result.push(getLabel(node) + ': ' + this._exportText(doc, [node.id, 'title']));
      result.push(this._exportContainer(node.getCaption()));
      return result.join('\n')
    }

    _exportTableFigure (node) {
      if (!node) return ''
      let doc = node.getDocument();
      let result = [];
      result.push(getLabel(node) + ': ' + this._exportText(doc, [node.id, 'title']));
      result.push(this._exportTable(node.getContent()));
      result.push(this._exportContainer(node.getCaption()));
      return result.join('\n')
    }
  }

  class ArticleConfigurator extends TextureConfigurator {
    constructor () {
      super();

      this.config.models = {};
      this.schema = InternalArticleSchema;
    }

    addNode () {
      throw new Error('Texture Article Schema is final and can no be extended.')
    }

    addAnnotationTool (spec) {
      let Command = spec.command || substance.AnnotationCommand;
      this.addCommand(spec.name, Command, {
        nodeType: spec.nodeType,
        commandGroup: spec.commandGroup
      });
      this.addIcon(spec.name, { 'fontawesome': spec.icon });
      this.addLabel(spec.name, spec.label);
      if (spec.accelerator) {
        this.addKeyboardShortcut(spec.accelerator, { command: spec.name });
      }
    }

    addTextTypeTool (spec) {
      this.addCommand(spec.name, substance.SwitchTextTypeCommand, {
        spec: spec.nodeSpec,
        commandGroup: 'text-types'
      });
      this.addIcon(spec.name, { 'fontawesome': spec.icon });
      this.addLabel(spec.name, spec.label);
      if (spec.accelerator) {
        this.addKeyboardShortcut(spec.accelerator, { command: spec.name });
      }
    }

    setPanelsSpec (panelsSpec) {
      this.config.panelsSpec = panelsSpec;
    }

    getPanelsSpec () {
      return this.config.panelsSpec
    }

    // see NumberedLabelGenerator
    setLabelGenerator (type, spec) {
      if (!this.config.labelGenerator) {
        this.config.labelGenerator = {};
      }
      this.config.labelGenerator[type] = spec;
    }

    getLabelGenerator (type) {
      let config;
      if (this.config.labelGenerator) {
        config = this.config.labelGenerator[type] || {};
      }
      return new NumberedLabelGenerator(config)
    }

    getKeyboardShortcuts () {
      return this.config.keyboardShortcuts
    }

    /*
      Allows lookup of a keyboard shortcut by command name
    */
    getKeyboardShortcutsByCommandName (commandName) {
      let keyboardShortcuts = {};
      this.config.keyboardShortcuts.forEach((entry) => {
        if (entry.spec.command) {
          let shortcut = entry.key.toUpperCase();

          if (substance.platform.isMac) {
            shortcut = shortcut.replace(/CommandOrControl/i, '');
            shortcut = shortcut.replace(/Ctrl/i, '^');
            shortcut = shortcut.replace(/Shift/i, '');
            shortcut = shortcut.replace(/Enter/i, '');
            shortcut = shortcut.replace(/Alt/i, '');
            shortcut = shortcut.replace(/\+/g, '');
          } else {
            shortcut = shortcut.replace(/CommandOrControl/i, 'Ctrl');
          }

          keyboardShortcuts[entry.spec.command] = shortcut;
        }
      });
      return keyboardShortcuts[commandName]
    }

    getExporter (type) {
      switch (type) {
        case 'text': {
          if (!this._textExporter) {
            this._textExporter = new ArticlePlainTextExporter(this);
          }
          return this._textExporter
        }
        case 'html': {
          if (!this._htmlExporter) {
            this._htmlExporter = new ArticleHTMLExporter(this);
          }
          return this._htmlExporter
        }
        case 'jats': {
          if (!this._jatsExporter) {
            this._jatsExporter = new JATSExporter(this);
          }
          return this._jatsExporter
        }
      }
    }

    getImporter (type) {
      switch (type) {
        case 'html': {
          if (!this._htmlImporter) {
            this._htmlImporter = new ArticleHTMLImporter(this);
          }
          return this._htmlImporter
        }
        case 'jats': {
          if (!this._jatsImporter) {
            this._jatsImporter = new JATSImporter(this);
          }
          return this._jatsImporter
        }
      }
    }
  }

  var BoldConverter = {
    type: 'bold',
    tagName: 'b',
    matchElement (el) {
      return (el.is('b')) ||
        (el.is('span') && el.getStyle('font-weight') === '700')
    }
  }

  var ExtLinkConverter = {
    type: 'ext-link',
    tagName: 'a',
    import (el, node) {
      let href = el.getAttribute('href');
      if (href) {
        node.attributes = {
          'xlink:href': href
        };
      }
    },
    export (node, el) {
      el.setAttribute('href', node.attributes['xlink:href']);
    }
  }

  var CodeblockConverter = {
    type: 'code',
    tagName: 'pre',
    import (el, node, converter) {
      let codeEl = el.find('code');
      if (codeEl) {
        node.content = converter.annotatedText(codeEl, [node.id, 'content'], { preserveWhitespace: true });
      }
    },
    export (node, el, converter) {
      let $$ = converter.$$;
      el.append(
        $$('code').append(
          converter.annotatedText([node.id, 'content'])
        )
      );
    }
  }

  var HeadingConverter = {
    type: 'heading',

    matchElement (el) {
      return /^h\d$/.exec(el.tagName)
    },

    import (el, node, converter) {
      node.content = converter.annotatedText(el, [node.id, 'content'], { preserveWhitespace: true });
    },

    export (node, el, converter) {
      el.tagName = `h${node.getLevel()}`;
      el.append(converter.annotatedText([node.id, 'content']));
    }
  }

  var ItalicConverter = {
    type: 'italic',
    tagName: 'i',
    matchElement (el) {
      return (el.is('i')) ||
        (el.is('span') && el.getStyle('font-style') === 'italic')
    }
  }

  class XMLListNodeHTMLConverter extends substance.ListPackage.ListHTMLConverter {
    _createItems (converter, node, items, listTypes) {
      node._childNodes = items.map(d => {
        let listItem = converter.convertElement(d.el);
        listItem.attributes.level = d.level;
        return listItem.id
      });
      node.attributes = node.attributes || {};
      node.attributes['list-type'] = listTypes.join(',');
    }
  }

  var ParagraphConverter = {
    type: 'p',
    tagName: 'p',
    import (el, node, converter) {
      node.content = converter.annotatedText(el, [node.id, 'content']);
    },
    export (node, el, converter) {
      el.append(converter.annotatedText([node.id, 'content']));
    }
  }

  var StrikeConverter = {
    type: 'strike',
    tagName: 'span',
    matchElement (el) {
      return el.getStyle('text-decoration') === 'line-through'
    },
    export (node, el) {
      el.setStyle('text-decoration', 'line-through');
    }
  }

  var SubConverter = {
    type: 'sub',
    tagName: 'sub',
    matchElement (el) {
      return (el.is('sub')) || (el.is('span') && el.getStyle('vertical-align') === 'sub')
    }
  }

  var SupConverter = {
    type: 'sup',
    tagName: 'sup',
    matchElement (el) {
      return (el.is('sup')) || (el.is('span') && el.getStyle('vertical-align') === 'super')
    }
  }

  var UnderlineConverter = {
    type: 'underline',
    tagName: 'span',
    matchElement (el) {
      return el.getStyle('text-decoration') === 'underline'
    },
    export (node, el) {
      el.setStyle('text-decoration', 'underline');
    }
  }

  var ArticleHTMLConverters = [
    BoldConverter,
    CodeblockConverter,
    ExtLinkConverter,
    HeadingConverter,
    ItalicConverter,
    XMLListNodeHTMLConverter,
    substance.ListPackage.ListItemHTMLConverter,
    ParagraphConverter,
    StrikeConverter,
    SubConverter,
    SupConverter,
    new TableConverter(),
    UnderlineConverter
  ]

  var LanguagesPackage = {
    name: 'Languages',
    configure (config) {
      config.registerLanguage('en', 'English');
      config.registerLanguage('es', 'Spanish');
      config.registerLanguage('pt', 'Portugese');
      config.registerLanguage('fr', 'French');
    }
  }

  class FigureModel extends NodeModel {
    constructor (api, node) {
      super(api, node);
      this._title = createValueModel(api, 'text', [node.id, 'title']);
    }

    get type () { return 'figure' }

    get id () { return this._node.id }

    getTitle () {
      return this._title
    }

    getContent () {
      return this._api.getModelById(this._node.content)
    }

    getPermission () {
      return this._api.getModelById(this._node.permission)
    }

    getLabel () {
      return getLabel(this._node)
    }

    getCaption () {
      return this._api.getModelById(this._node.caption)
    }
  }

  class DispQuoteModel extends NodeModel {
    constructor (api, node) {
      super(api, node);
      this._attrib = createValueModel(api, 'text', [node.id, 'attrib']);
      this._content = new FlowContentModel(this, node.getContentPath());
    }

    /*
      EXPERIMENTAL: Override properties with custom value models
    */
    getProperties () {
      return [
        new ModelProperty('content', this._content),
        new ModelProperty('attrib', this._attrib)
      ]
    }

    get type () { return 'disp-quote' }

    getAttrib () {
      return this._attrib
    }

    getContent () {
      return this._content
    }
  }

  class ArticleRecordModel extends NodeModel {
    get type () { return 'article-record' }

    get id () { return this._node.id }

    getPermission () {
      return this._api.getModelById(this._node.permission)
    }
  }

  class ContentNodeCollectionModel {
    constructor (api) {
      this._api = api;
    }

    get isCollection () {
      return true
    }

    getItems () {
      const api = this._api;
      let article = api.getArticle();
      let nodes = article.get('body').findAll(this._getSelector());
      return nodes.map(node => api.getModelById(node.id))
    }

    _getSelector () {
      throw new Error('This method is abstract.')
    }
  }

  class FigureCollectionModel extends ContentNodeCollectionModel {
    get id () {
      return 'figures'
    }

    get type () {
      return 'figures'
    }

    _getSelector () {
      return 'figure'
    }
  }

  class DefaultCollectionModel {
    constructor (api, node) {
      this._api = api;
      this._node = node;
    }

    get id () {
      return this._node.id
    }

    get type () {
      return this._node.type
    }

    get isCollection () {
      return true
    }

    get isRemovable () {
      return false
    }

    get isMovable () {
      return false
    }

    get length () {
      return this._node.children.length
    }

    getItems () {
      return this._node._childNodes.map(id => this._api.getModelById(id))
    }

    addItem (item = {}) {
      return this._api.addItemToCollection(this._prepareItem(item), this)
    }

    addItems (items) {
      return this._api.addItemsToCollection(items.map(item => this._prepareItem(item)), this)
    }

    removeItem (item) {
      this._api.removeItemFromCollection(item, this);
    }

    _prepareItem (item) {
      item.type = this._getItemType();
      return item
    }

    _getItemType () {
      throw new Error('This method is abstract.')
    }
  }

  class FootnoteCollectionModel extends DefaultCollectionModel {
    // Note: this is special because it provides a sorted list of footnotes
    getItems () {
      let fns = this._api.getFootnoteManager().getSortedCitables();
      let result = fns.map(fn => this._api.getModelById(fn.id));
      return result
    }

    addItem (item = {}) {
      return this._api._insertFootnote(this._prepareItem(item), this)
    }

    get isRemovable () {
      return true
    }

    _getItemType () {
      return 'fn'
    }
  }

  class AwardCollectionModel extends DefaultCollectionModel {
    _getItemType () {
      return 'award'
    }

    get isRemovable () {
      return true
    }
  }

  class DefaultMovableCollectionModel extends DefaultCollectionModel {
    get isMovable () {
      return true
    }

    moveDown (item) {
      const pos = this._getModelPosition(item);
      if (pos < this._node.getChildCount()) {
        this.moveItem(pos, pos + 1);
      }
    }

    moveUp (item) {
      const pos = this._getModelPosition(item);
      if (pos > 0) {
        this.moveItem(pos, pos - 1);
      }
    }

    moveItem (from, to) {
      return this._api.moveCollectionItem(this, from, to)
    }

    _getModelPosition (item) {
      return this._node.getChildPosition(item)
    }
  }

  class PersonCollectionModel extends DefaultMovableCollectionModel {
    _getItemType () {
      return 'person'
    }

    addItem (item = {}) {
      return this._api._insertPerson(this._prepareItem(item), this)
    }

    get isRemovable () {
      return true
    }
  }

  class GroupCollectionModel extends DefaultCollectionModel {
    _getItemType () {
      return 'group'
    }

    get isRemovable () {
      return true
    }
  }

  class OrganisationCollectionModel extends DefaultCollectionModel {
    _getItemType () {
      return 'organisation'
    }

    get isRemovable () {
      return true
    }
  }

  class KeywordCollectionModel extends DefaultMovableCollectionModel {
    _getItemType () {
      return 'keyword'
    }

    get isRemovable () {
      return true
    }
  }

  // TODO: is it possible to implement this collection more like the others?
  class ReferenceCollectionModel extends DefaultCollectionModel {
    // Note: this is special because it provides a sorted list of references
    getItems () {
      let refs = this._api.getReferenceManager().getBibliography();
      let result = refs.map(ref => this._api.getModelById(ref.id));
      return result
    }

    addItem (item = {}) {
      return this._api.addItemToCollection(item, this)
    }

    addItems (items) {
      return this._api.addReferences(items, this)
    }

    removeItem (item) {
      this._api.deleteReference(item, this);
    }

    get isRemovable () {
      return true
    }
  }

  class SubjectCollectionModel extends DefaultMovableCollectionModel {
    _getItemType () {
      return 'subject'
    }

    get isRemovable () {
      return true
    }
  }

  class TranslationCollectionModel {
    constructor (api) {
      this._api = api;
    }

    get id () {
      return 'translations'
    }

    get type () {
      return 'translations'
    }

    get isCollection () {
      return true
    }

    getItems () {
      return this._api.getTranslatables()
    }
  }

  class TranslationModel {
    /*
      @param {ArticleAPI} api
      @param {TextTranslation|ContainerTranslation} node
    */
    constructor (api, node) {
      this._api = api;
      this._node = node;
    }

    get id () {
      return this._node.id
    }

    get type () {
      return 'translation'
    }

    getLanguageCode () {
      return this._node.language
    }

    getModel () {
      let model;
      if (this._node.isText()) {
        model = new TextModel(this._api, this._node.getPath());
      } else {
        model = new FlowContentModel(this._api, this._node.getContentPath());
      }
      return model
    }
  }

  class XrefModel {
    constructor (api, node) {
      this._api = api;
      this._node = node;
    }

    get id () {
      return this._node.id
    }

    getTargets () {
      let targetIds = getXrefTargets(this._node);
      return targetIds.map(id => this._api.getModelById(id))
    }

    getAvailableTargets () {
      // ATTENTION: getAvailableXrefTargets() provides an internal entry of records
      let entries = getAvailableXrefTargets(this._node, { api: this._api });
      return entries.map(entry => {
        entry.model = this._api.getModelById(entry.id);
        return entry
      })
    }

    toggleTarget (nodeId) {
      this._api.toggleXrefTarget(nodeId, this);
      return this.getAvailableTargets()
    }
  }

  var ArticleModelPackage = {
    name: 'TextureArticle',
    configure (config) {
      config.import(EntityLabelsPackage);

      // enable rich-text support for clipboard
      ArticleHTMLConverters.forEach(converter => {
        config.addConverter('html', converter);
      });

      // Registry of available languages
      config.import(LanguagesPackage);

      // Collection Models
      config.addModel('authors', PersonCollectionModel);
      config.addModel('awards', AwardCollectionModel);
      config.addModel('editors', PersonCollectionModel);
      config.addModel('figures', FigureCollectionModel);
      config.addModel('footnotes', FootnoteCollectionModel);
      config.addModel('groups', GroupCollectionModel);
      config.addModel('keywords', KeywordCollectionModel);
      config.addModel('organisations', OrganisationCollectionModel);
      config.addModel('references', ReferenceCollectionModel);
      config.addModel('subjects', SubjectCollectionModel);
      config.addModel('translations', TranslationCollectionModel);

      // Other special models
      config.addModel('translatable', TranslateableModel);
      config.addModel('text-translation', TranslationModel);
      config.addModel('container-translation', TranslationModel);
      config.addModel('figure', FigureModel);
      config.addModel('disp-quote', DispQuoteModel);
      config.addModel('article-record', ArticleRecordModel);
      config.addModel('table-figure', FigureModel);
      config.addModel('xref', XrefModel);

      // Experimental
      config.setLabelGenerator('references', {
        template: '[$]',
        and: ',',
        to: '-'
      });
      config.setLabelGenerator('figures', {
        name: 'Figure',
        plural: 'Figures',
        and: ',',
        to: '-'
      });
      config.setLabelGenerator('tables', {
        name: 'Table',
        plural: 'Tables',
        and: ',',
        to: '-'
      });
      config.setLabelGenerator('footnotes', {
        template: '$',
        and: ',',
        to: '-'
      });
    }
  }

  var ArticleLoader = {
    load (xml) {
      let configurator = new ArticleConfigurator();
      configurator.import(ArticleModelPackage);
      let jatsImporter = new JATSImporter();
      // ATTENTION: the defailt policy is now to not support elements that
      // have not been implemented (UnsupportedNode)
      // For evaluation it is possible to provide a query parameter like so:
      // localhost:4000/?allowNotImplemented=true
      let importOptions = {
        allowNotImplemented: false
      };
      if (substance.platform.inBrowser) {
        importOptions.allowNotImplemented = substance.getQueryStringParam('allowNotImplemented') === 'true';
      }
      let result = jatsImporter.import(xml, importOptions);
      if (result.hasErrored) {
        let err = new Error('JATS import failed');
        err.type = 'jats-import-error';
        err.detail = new ImporterErrorReport(result.errors);
        throw err
      }
      let doc = result.doc;
      let editorSession = new ArticleSession(doc, configurator);
      return editorSession
    }
  }

  class ImporterErrorReport {
    constructor (jatsImporterErrors) {
      let failedStages = [];
      substance.forEach(jatsImporterErrors, (errors, stage) => {
        if (errors && errors.length > 0) {
          failedStages.push({ name: stage, errors });
        }
      });
      this._errors = failedStages;
    }

    toString () {
      let frags = this._errors.reduce((frags, stage) => {
        frags.push(`Errors during stage ${stage.name}:`);
        frags = frags.concat(stage.errors.map(err => {
          return _indentMsg(err.msg, '  ') + '\n'
        }));
        return frags
      }, []);
      return frags.join('\n')
    }
  }

  function _indentMsg (msg, indent) {
    return msg.split('\n').map(line => indent + line).join('\n')
  }

  class AddEntityCommand extends substance.Command {
    getCommandState () {
      return { disabled: false }
    }
    execute (params, context) {
      const workflow = this.config.workflow;
      if (workflow) {
        context.editor.send('startWorkflow', workflow);
      } else {
        const collectionName = this.config.collection;
        const collection = context.api.getModelById(collectionName);
        // adding an empty item
        collection.addItem({});

        context.editor.send('toggleOverlay');
      }
    }
  }

  class BasicCollectionCommand extends substance.Command {
    getCommandState (params, context) {
      return { disabled: this.isDisabled(params, context) }
    }

    isDisabled (params, context) {
      const sel = params.selection;
      return sel && sel.isCustomSelection() && sel.getCustomType() !== 'model'
    }

    _getModelForSelection (params, context) {
      const sel = params.selection;
      const api = context.api;
      const modelId = sel.data.modelId;
      return api.getModelById(modelId)
    }

    _getCollectionForModel (context, model) {
      const api = context.api;
      const node = model._node;
      const parent = node.getParent();
      return api.getModelById(parent.id)
    }
  }

  class RemoveCollectionItemCommand extends BasicCollectionCommand {
    execute (params, context) {
      const model = this._getModelForSelection(params, context);
      const collection = this._getCollectionForModel(context, model);
      collection.removeItem(model);
    }

    isDisabled (params, context) {
      const sel = params.selection;
      if (!sel || !sel.isCustomSelection() || sel.getCustomType() !== 'model') return true
      const model = this._getModelForSelection(params, context);
      const collection = this._getCollectionForModel(context, model);
      if (!collection || !collection.isRemovable) return true
      return false
    }
  }

  class MoveCollectionItemCommand extends BasicCollectionCommand {
    execute (params, context) {
      const direction = this.config.direction;
      const model = this._getModelForSelection(params, context);
      const collection = this._getCollectionForModel(context, model);
      if (direction === 'up') {
        collection.moveUp(model);
      } else if (direction === 'down') {
        collection.moveDown(model);
      }
    }

    isDisabled (params, context) {
      const sel = params.selection;
      if (!sel || !sel.isCustomSelection() || sel.getCustomType() !== 'model') return true
      const model = this._getModelForSelection(params, context);
      const collection = this._getCollectionForModel(context, model);
      if (!collection || !collection.isMovable) return true
      const direction = this.config.direction;
      const pos = collection._getModelPosition(model);
      if (direction === 'up' && pos === 0) return true
      if (direction === 'down' && pos === collection.length - 1) return true
      return false
    }
  }

  class ArticleRecordEditor extends NodeModelComponent {
    _getClassNames () {
      return `sc-article-record sc-node-model`
    }

    get isRemovable () {
      return false
    }

    _renderHeader () {
      // no header
    }

    _getPropertyEditorClass (property) {
      switch (property.name) {
        // don't provide an editor for 'authors' and 'editors'
        // these fields are managed in dedicated metadata sections
        case 'authors':
        case 'editors': {
          return null
        }
        case 'license': {
          return LicenseEditor
        }
        default:
          return super._getPropertyEditorClass(property)
      }
    }

    _getProperties () {
      let model = this.props.model;
      let permission = model.getPermission();
      let properties = model.getProperties();
      properties = properties.filter(p => p.name !== 'permission');
      properties = properties.concat(permission.getProperties());
      return properties
    }
  }

  class InplaceRefContribEditor extends ValueComponent {
    render ($$) {
      let el = $$('div').addClass('sc-inplace-ref-contrib-editor');
      el.append(this._renderChildren($$));
      el.append(
        $$('button').addClass('se-add-value')
          // TODO: use icon provider
          .append(
            $$(substance.FontAwesomeIcon, {icon: 'fa-plus'}).addClass('se-icon')
          )
          .on('click', this._addContrib)
      );
      return el
    }

    _renderChildren ($$) {
      const model = this.props.model;
      let children = model.getChildren();
      return children.map(child => this._renderChild($$, child))
    }

    _renderChild ($$, refContrib) {
      let id = refContrib.id;
      let givenNames = refContrib.getGivenNames();
      let name = refContrib.getName();
      return $$(FormRowComponent).append(
        // TODO: it would be good to have a default factory for property editors
        $$(StringComponent, {
          label: this.getLabel(name.name),
          model: name.model
        }),
        $$(StringComponent, {
          label: this.getLabel(givenNames.name),
          model: givenNames.model
        }),
        // TODO: use icon provider
        $$('button').addClass('se-remove-value')
          .append($$(substance.FontAwesomeIcon, {icon: 'fa-trash'}))
          .on('click', this._removeContrib.bind(this, refContrib))
      ).ref(id)
    }

    _addContrib () {
      const model = this.props.model;
      model.appendChild({type: 'ref-contrib'});
    }

    _removeContrib (contrib) {
      const model = this.props.model;
      model.removeChild(contrib);
    }
  }

  class BibliographicEntryEditor extends NodeModelComponent {
    // using a special inplace property editor for 'ref-contrib's
    _getPropertyEditorClass (property) {
      let targetTypes = property.targetTypes;
      if (targetTypes[0] === 'ref-contrib') {
        return InplaceRefContribEditor
      } else {
        return super._getPropertyEditorClass(property)
      }
    }
  }

  class LanguageEditor extends ValueComponent {
    render ($$) {
      const model = this.props.model;
      const value = model.getValue();
      const languages = this._getArticleLanguages();
      let el = $$('div').addClass('sc-language-editor');

      const languageSelector = $$('select').addClass('se-select')
        .ref('input')
        .on('change', this._setLanguage);

      languageSelector.append(
        $$('option').append(this.getLabel('select-language'))
      );

      Object.keys(languages).forEach(lang => {
        const option = $$('option').attr({value: lang}).append(languages[lang]);
        if (lang === value) option.attr({selected: 'selected'});
        languageSelector.append(option);
      });

      el.append(languageSelector);

      return el
    }

    _setLanguage () {
      const model = this.props.model;
      const input = this.refs.input;
      const value = input.getValue();
      model.setValue(value);
    }

    _getArticleLanguages () {
      const configurator = this.context.configurator;
      return configurator.getAvailableLanguages()
    }
  }

  class TranslatableEntryEditor extends NodeModelComponent {
    // using a special translatable property editor for entries with language picker
    _getPropertyEditorClass (property) {
      let propertyName = property.name;
      if (propertyName === 'language') {
        return LanguageEditor
      } else {
        return super._getPropertyEditorClass(property)
      }
    }
  }

  class TranslateableEditor extends ModelComponent {
    render ($$) {
      const model = this.props.model;
      const originalModel = model.getOriginalModel();
      const languages = this._getArticleLanguages();
      const availableLanguages = this._getAvailableLanguages();
      let ModelEditor = this.getComponent(originalModel.type);

      let el = $$('div')
        .addClass('sc-translatable-editor')
        .attr('data-id', model.id);

      el.append(
        $$('div').addClass('se-header').append(this.getLabel(model.id))
      );

      let originalRow = $$(FormRowComponent, {
        label: this.getLabel('original-translation')
      });
      originalRow.append(
        $$(ModelEditor, {
          model: originalModel,
          label: model.name
        })
      );
      el.append(originalRow);

      model.getTranslations().forEach(translation => {
        let lang = translation.getLanguageCode();
        let langName = languages[lang];
        let translationModel = translation.getModel();
        let translRow = $$(FormRowComponent, {
          label: langName
        });
        translRow.append(
          $$(ModelEditor, {
            model: translationModel,
            label: model.name,
            // TODO: use label here?
            placeholder: 'Enter ' + model.name
          })
        );
        el.append(
          translRow.append(
            $$('div').addClass('se-remove').append(
              $$(substance.FontAwesomeIcon, { icon: 'fa-remove' }).addClass('se-icon')
            ).on('click', this._removeTranslation.bind(this, translation))
          )
        );
      });

      if (availableLanguages.length > 0) {
        let footerEl = $$('div').addClass('se-footer');

        if (this.state.dropdown) {
          footerEl.append(this._renderLanguageDropdown($$));
        } else {
          footerEl.append(
            $$('div').addClass('se-control').append(
              this.getLabel('add-translation')
            ).on('click', this._toggleDropdown)
          );
        }

        el.append(footerEl);
      }

      return el
    }

    _renderLanguageDropdown ($$) {
      const languages = this._getArticleLanguages();
      const availableLanguages = this._getAvailableLanguages();

      const el = $$('select').addClass('se-select')
        .on('change', this._addTranslation)
        .on('click', stopEvent);

      el.append(
        $$('option').append(this.getLabel('select-language'))
      );

      availableLanguages.forEach(lang => {
        el.append(
          $$('option').attr({value: lang}).append(languages[lang])
        );
      });

      return el
    }

    _addTranslation (e) {
      const value = e.target.value;
      const model = this.props.model;
      model.addTranslation(value);
      this._toggleDropdown(e);
    }

    _removeTranslation (translationModel) {
      const model = this.props.model;
      model.removeTranslation(translationModel);
    }

    _toggleDropdown (e) {
      stopAndPreventEvent(e);
      const dropdown = this.state.dropdown;
      this.extendState({dropdown: !dropdown});
    }

    _getArticleLanguages () {
      const configurator = this.context.configurator;
      return configurator.getAvailableLanguages()
    }

    _getAvailableLanguages () {
      const model = this.props.model;
      const languages = this._getArticleLanguages();
      const languageCodes = Object.keys(languages);
      const alreadyTranslated = model.getTranslations().map(t => t.getLanguageCode());
      // HACK: english is hardcoded here as original language
      // we will need to use default lang setting from article level
      alreadyTranslated.push('en');
      return languageCodes.filter(l => !alreadyTranslated.find(t => t === l))
    }
  }

  var MetadataPackage = {
    name: 'ArticleMetadata',
    configure (config) {
      config.import(BasePackage);
      config.import(EditorBasePackage);
      config.import(ArticleNavPackage);
      config.import(PersistencePackage);
      config.import(ManuscriptContentPackage);
      config.import(ModelComponentPackage);
      config.import(EntityLabelsPackage);
      config.import(FindAndReplacePackage);

      // sections and editors
      config.addComponent('collection', CollectionEditor);
      config.addComponent('article-record', ArticleRecordEditor);
      config.addComponent('bibr', BibliographicEntryEditor, true);
      config.addComponent('subject', TranslatableEntryEditor);
      config.addComponent('translatable', TranslateableEditor);
      config.addComponent('keyword', TranslatableEntryEditor);
      // workflows
      config.addComponent('add-reference', AddReferenceWorkflow);

      config.addToolPanel('toolbar', [
        {
          name: 'undo-redo',
          type: 'tool-group',
          showDisabled: true,
          style: 'minimal',
          items: [
            { type: 'command-group', name: 'undo-redo' }
          ]
        },
        {
          name: 'persistence',
          type: 'tool-group',
          showDisabled: true,
          style: 'minimal',
          items: [
            { type: 'command-group', name: 'persistence' }
          ]
        },
        {
          name: 'add',
          type: 'tool-dropdown',
          showDisabled: true,
          style: 'descriptive',
          items: [
            { type: 'command-group', name: 'add-entity' }
          ]
        },
        {
          name: 'annotations',
          type: 'tool-group',
          showDisabled: true,
          style: 'minimal',
          items: [
            { type: 'command-group', name: 'formatting' }
          ]
        },
        {
          name: 'collection-tools',
          type: 'tool-group',
          showDisabled: true,
          style: 'minimal',
          items: [
            { type: 'command-group', name: 'collection' }
          ]
        },
        {
          name: 'mode',
          type: 'tool-dropdown',
          showDisabled: false,
          style: 'full',
          items: [
            { type: 'command-group', name: 'switch-view' }
          ]
        }
        // TODO: enable this when we have a first workflow
        // which does not belong to the add-entity group
        // {
        //   name: 'workflows',
        //   type: 'tool-dropdown',
        //   showDisabled: true,
        //   style: 'descriptive',
        //   items: [
        //     { type: 'command-group', name: 'workflows' }
        //   ]
        // }
      ]);
      config.addLabel('article-record', {
        en: 'Article Information'
      });

      config.addLabel('add', {
        en: 'Add'
      });
      config.addLabel('edit', {
        en: 'Edit'
      });
      config.addLabel('remove', {
        en: 'Remove'
      });
      config.addLabel('workflows', {
        en: 'Workflows'
      });

      config.addIcon('remove', {
        'fontawesome': 'fa-trash'
      });

      config.addCommand('add-author', AddEntityCommand, {
        type: 'author',
        collection: 'authors',
        commandGroup: 'add-entity'
      });
      config.addKeyboardShortcut('CommandOrControl+Alt+A', { command: 'add-author' });

      config.addCommand('add-editor', AddEntityCommand, {
        type: 'editor',
        collection: 'editors',
        commandGroup: 'add-entity'
      });
      config.addKeyboardShortcut('CommandOrControl+Alt+E', { command: 'add-editor' });

      config.addCommand('add-group', AddEntityCommand, {
        type: 'group',
        collection: 'groups',
        commandGroup: 'add-entity'
      });
      config.addKeyboardShortcut('CommandOrControl+Alt+G', { command: 'add-group' });

      config.addCommand('add-organisation', AddEntityCommand, {
        type: 'organisation',
        collection: 'organisations',
        commandGroup: 'add-entity'
      });
      config.addKeyboardShortcut('CommandOrControl+Alt+O', { command: 'add-organisation' });

      config.addCommand('add-award', AddEntityCommand, {
        type: 'award',
        collection: 'awards',
        commandGroup: 'add-entity'
      });
      config.addKeyboardShortcut('CommandOrControl+Alt+Y', { command: 'add-award' });

      config.addCommand('add-keyword', AddEntityCommand, {
        type: 'keyword',
        collection: 'keywords',
        commandGroup: 'add-entity'
      });
      config.addKeyboardShortcut('CommandOrControl+Alt+K', { command: 'add-keyword' });

      config.addCommand('add-subject', AddEntityCommand, {
        type: 'subject',
        collection: 'subjects',
        commandGroup: 'add-entity'
      });

      config.addCommand('add-footnote', AddEntityCommand, {
        type: 'fn',
        collection: 'footnotes',
        commandGroup: 'add-entity'
      });

      config.addLabel('add-reference', {
        en: 'Reference'
      });
      config.addLabel('add-author', {
        en: 'Author'
      });
      config.addLabel('add-editor', {
        en: 'Editor'
      });
      config.addLabel('add-group', {
        en: 'Group'
      });
      config.addLabel('add-organisation', {
        en: 'Affiliation'
      });
      config.addLabel('add-award', {
        en: 'Award'
      });
      config.addLabel('add-keyword', {
        en: 'Keyword'
      });
      config.addLabel('add-subject', {
        en: 'Subject'
      });
      config.addLabel('add-footnote', {
        en: 'Footnote'
      });
      config.addLabel('original-translation', {
        en: 'Original'
      });
      config.addLabel('add-translation', {
        en: 'Add Translation'
      });
      config.addLabel('select-language', {
        en: 'Select language'
      });

      config.addLabel('title-trans', {
        en: 'Title'
      });
      config.addLabel('abstract-trans', {
        en: 'Abstract'
      });

      config.addLabel('select-license', {
        en: 'Select license'
      });

      // TODO: we should try to extract these into a package and share with ManuscriptEditor
      config.addAnnotationTool({
        name: 'bold',
        nodeType: 'bold',
        commandGroup: 'formatting',
        icon: 'fa-bold',
        label: 'Strong',
        accelerator: 'CommandOrControl+B'
      });

      config.addAnnotationTool({
        name: 'italic',
        nodeType: 'italic',
        commandGroup: 'formatting',
        icon: 'fa-italic',
        label: 'Emphasize',
        accelerator: 'CommandOrControl+I'
      });

      config.addAnnotationTool({
        name: 'sub',
        nodeType: 'sub',
        commandGroup: 'formatting',
        icon: 'fa-subscript',
        label: 'Subscript'
      });

      config.addAnnotationTool({
        name: 'sup',
        nodeType: 'sup',
        commandGroup: 'formatting',
        icon: 'fa-superscript',
        label: 'Superscript'
      });

      config.addAnnotationTool({
        name: 'monospace',
        nodeType: 'monospace',
        commandGroup: 'formatting',
        icon: 'fa-code',
        label: 'Monospace'
      });

      // Section labels
      config.addLabel('article', {
        en: 'Article Information'
      });
      config.addLabel('authors', {
        en: 'Authors'
      });
      config.addLabel('figures', {
        en: 'Figures'
      });
      config.addLabel('footnotes', {
        en: 'Footnotes'
      });
      config.addLabel('groups', {
        en: 'Groups'
      });
      config.addLabel('keywords', {
        en: 'Keywords'
      });
      config.addLabel('subjects', {
        en: 'Subjects'
      });
      config.addLabel('organisations', {
        en: 'Affiliations'
      });
      config.addLabel('references', {
        en: 'References'
      });
      config.addLabel('tables', {
        en: 'Tables'
      });
      config.addLabel('translateables', {
        en: 'Translations'
      });
      config.addLabel('translations', {
        en: 'Translations'
      });
      config.addLabel('title-trans', {
        en: 'Title'
      });
      config.addLabel('abstract-trans', {
        en: 'Abstract'
      });

      // Workflows
      config.addCommand('add-reference', AddEntityCommand, {
        workflow: 'add-reference',
        commandGroup: 'add-entity',
        type: 'bibr',
        collection: 'references'
      });
      config.addKeyboardShortcut('CommandOrControl+Shift+L', { command: 'add-reference' });
      config.addLabel('add-reference', {
        en: 'Reference'
      });

      // Add reference workflow
      config.addLabel('add-reference-title', {
        en: 'Add Reference(s)'
      });
      config.addLabel('add-ref-manually', {
        en: 'Or create manually'
      });
      config.addLabel('fetch-datacite', {
        en: 'Fetch from DataCite'
      });
      config.addLabel('enter-doi-placeholder', {
        en: 'Enter one or more DOIs'
      });
      config.addLabel('doi-fetch-action', {
        en: 'Add'
      });
      config.addLabel('import-refs', {
        en: 'Import'
      });
      config.addLabel('supported-ref-formats', {
        en: 'Supported formats'
      });

      // Card tools
      config.addCommand('move-up-col-item', MoveCollectionItemCommand, {
        direction: 'up',
        commandGroup: 'collection'
      });
      config.addIcon('move-up-col-item', { 'fontawesome': 'fa-caret-square-o-up' });
      config.addLabel('move-up-col-item', {
        en: 'Move item up'
      });
      config.addKeyboardShortcut('CommandOrControl+Alt+Up', { command: 'move-up-col-item' });
      config.addCommand('move-down-col-item', MoveCollectionItemCommand, {
        direction: 'down',
        commandGroup: 'collection'
      });
      config.addIcon('move-down-col-item', { 'fontawesome': 'fa-caret-square-o-down' });
      config.addLabel('move-down-col-item', {
        en: 'Move item down'
      });
      config.addKeyboardShortcut('CommandOrControl+Alt+Down', { command: 'move-down-col-item' });
      config.addCommand('remove-col-item', RemoveCollectionItemCommand, {
        commandGroup: 'collection'
      });
      config.addIcon('remove-col-item', { 'fontawesome': 'fa-trash' });
      config.addLabel('remove-col-item', {
        en: 'Remove item'
      });
      config.addKeyboardShortcut('CommandOrControl+Alt+Delete', { command: 'remove-col-item' });

      config.addIcon('checked-item', { 'fontawesome': 'fa-check-square-o' });
      config.addIcon('unchecked-item', { 'fontawesome': 'fa-square-o' });
      config.addLabel('select-item', {
        en: 'Choose'
      });
    }
  }

  /* eslint-disable no-template-curly-in-string */

  var ReaderPackage = {
    name: 'ArticleReader',
    configure (config) {
      config.import(BasePackage);
      config.import(ModelComponentPackage);
      config.import(ManuscriptContentPackage);
      config.import(EntityLabelsPackage);
      config.import(ArticleNavPackage);

      config.addComponent('references', ReferenceListComponent);
      config.addComponent('footnotes', FootnoteGroupComponent);

      config.addToolPanel('toolbar', [
        {
          name: 'mode',
          type: 'tool-dropdown',
          showDisabled: false,
          style: 'full',
          items: [
            { type: 'command-group', name: 'switch-view' }
          ]
        }
      ]);
    }
  }

  const DEFAULT_VIEW = 'manuscript';

  class ArticlePanel extends substance.Component {
    constructor (...args) {
      super(...args);
      this._initialize(this.props, this.state);

      // Store the viewports, so we can restore scroll positions
      this._viewports = {};
      this.handleActions({
        'updateViewName': this._updateViewName
      });
    }

    _initialize (props) {
      const archive = props.archive;
      const config = props.config;

      this.context = Object.assign(createComponentContext(config), {
        urlResolver: archive,
        appState: this.state
      });
    }

    getInitialState () {
      // using AppState as Component state
      return this._createAppState(this.props.config)
    }

    willReceiveProps (props) {
      if (props.documentSession !== this.props.documentSession) {
        let state = this._createAppState(props.config);
        this._initialize(props, state);
        // wipe children and update state
        this.empty();
        this.setState(state);
      }
    }

    getChildContext () {
      return {
        appState: this.state
      }
    }

    shouldRerender (newProps, newState) {
      return (
        newProps.documentSession !== this.props.documentSession ||
        newProps.config !== this.props.config ||
        newState !== this.state
      )
    }

    render ($$) {
      let el = $$('div').addClass('sc-article-panel');
      el.append(
        this._renderContent($$)
      );
      return el
    }

    _renderContent ($$) {
      const props = this.props;
      const viewName = this.state.viewName;
      const api = this.api;
      const archive = props.archive;
      const articleSession = props.documentSession;
      const config = props.config.getConfiguration(viewName);
      const viewport = this._viewports[viewName];

      let ContentComponent;
      switch (viewName) {
        case 'manuscript': {
          ContentComponent = this.getComponent('manuscript-editor');
          break
        }
        case 'metadata': {
          ContentComponent = this.getComponent('metadata-editor');
          break
        }
        case 'reader': {
          ContentComponent = this.getComponent('article-reader');
          break
        }
        default:
          throw new Error('Unsupported view: ' + viewName)
      }
      return $$(ContentComponent, {
        viewport,
        viewName,
        api,
        archive,
        config,
        articleSession
      }).ref('content')
    }

    _createAppState (config) { // eslint-disable-line no-unused-vars
      const appState = new AppState({
        viewName: DEFAULT_VIEW
      });
      appState.addObserver(['view'], this.rerender, this, { stage: 'render' });
      return appState
    }

    _updateViewName (viewName) {
      let oldViewName = this.context.appState.viewName;
      this.context.appState.viewName = viewName;
      this._viewports[oldViewName] = this.refs.content.getViewport();
      this.rerender();
    }

    _handleKeydown (e) {
      // console.log('ArticlePanel._handleKeydown', e)
      // ATTENTION: asking the currently active content to handle the keydown event first
      let handled = this.refs.content._onKeydown(e);
      // Note: if we had a keyboardManager here we could ask it to handle the event
      // if (!handled) {
      //   handled = this.context.keyboardManager.onKeydown(e, this.context)
      // }
      if (handled) {
        e.stopPropagation();
        e.preventDefault();
      }
      return handled
    }
  }

  class TableCollectionModel extends ContentNodeCollectionModel {
    get id () {
      return 'tables'
    }

    get type () {
      return 'tables'
    }

    _getSelector () {
      return 'table-figure'
    }
  }

  class MetadataModel extends CompositeModel {
    constructor (api) {
      super(api);

      this.setProperties(
        { name: 'authors', model: api.getModelById('authors') },
        { name: 'editors', model: api.getModelById('editors') },
        { name: 'groups', model: api.getModelById('groups') },
        { name: 'organisations', model: api.getModelById('organisations') },
        { name: 'awards', model: api.getModelById('awards') },
        { name: 'references', model: api.getModelById('references') },
        { name: 'keywords', model: api.getModelById('keywords') },
        { name: 'subjects', model: api.getModelById('subjects') },
        { name: 'translations', model: new TranslationCollectionModel(api) },
        { name: 'article', model: api.getModelById('article-record') },
        { name: 'figures', model: new FigureCollectionModel(api) },
        { name: 'tables', model: new TableCollectionModel(api) },
        { name: 'footnotes', model: api.getModelById('footnotes') }
      );
    }

    get type () { return 'metadata-matter' }
  }

  class MetadataSection extends ModelComponent {
    render ($$) {
      const model = this.props.model;
      const label = this.getLabel(model.id);
      const isCollection = model.isCollection;

      let el = $$('div').addClass('sc-metadata-section');
      let ModelEditor = this.getComponent(model.type, true);
      if (!ModelEditor) ModelEditor = isCollection ? this.getComponent('collection') : this.getComponent('entity');
      let modelEl = $$(ModelEditor, { model }).ref('editor');
      // non-collection models are wrapped in a Card
      if (isCollection) {
        const items = model.getItems();
        if (items.length > 0) {
          el.append(
            $$('div').addClass('se-heading').append(
              $$('div').addClass('se-header').append(label)
            ),
            modelEl
          );
        }
      } else {
        el.append(
          $$('div').addClass('se-heading').append(
            $$('div').addClass('se-header').append(label)
          ),
          $$(CardComponent, {modelId: model.id}).append(modelEl)
        );
      }
      return el
    }
  }

  class MetaSectionTOCEntry extends ModelComponent {
    render ($$) {
      const id = this.props.id;
      const name = this.props.name;
      const model = this.props.model;
      let el = $$('a').addClass('sc-meta-section-toc-entry')
        .attr({ href: '#' + id })
        .on('click', this.handleClick);

      let label = this.getLabel(name);
      if (model.isCollection) {
        const items = model.getItems();
        if (items.length > 0) {
          label = label + ' (' + items.length + ')';
          el.setStyle('display', 'block').append(label);
        } else {
          el.setStyle('display', 'none');
        }
      } else {
        el.append(label);
      }

      return el
    }

    handleClick (e) {
      // NOTE: currently we are using link anchors for metadata panel navigation
      // this way we are preventing Electron from opening links in a new window
      // later we want to introduce different routing mechanism
      e.stopPropagation();
    }
  }

  /* eslint-disable no-use-before-define */

  /*
    EXPERIMENTAL: This should only be used as a prototype.
    After that must consolidate requirements and refactor.
  */

  class ExperimentalArticleValidator {
    constructor (articleSession, editorState) {
      this._articleSession = articleSession;
      this._editorState = editorState;
    }

    initialize () {
      let article = this._getArticle();
      substance.forEach(article.getNodes(), node => {
        CheckRequiredFields.onCreate(this, node);
      });
      // TODO: or should we bind to editorState updates?
      this._editorState.addObserver(['document'], this._onDocumentChange, this, { stage: 'update' });
    }

    dispose () {
      this._editorState.removeObserver(this);
    }

    /*
      Thought: potentially there are different kind of issues
    */
    clearIssues (path, type) {
      // Note: storing the issues grouped by propertyName in node['@issues']
      let nodeIssues = this._getNodeIssues(path[0]);
      nodeIssues.clear(path.slice(1).join('.'), type);
      this._markAsDirty(path);
    }

    /*
      Thoughts: adding issues one-by-one, and clearing by type
    */
    addIssue (path, issue) {
      // console.log('ArticleValidator: adding issue for %s', path.join('.'), issue)
      let nodeIssues = this._getNodeIssues(path[0]);
      nodeIssues.add(path.slice(1).join('.'), issue);
      this._markAsDirty(path);
    }

    _markAsDirty (path) {
      // Note: marking both the node and the property as dirty
      const documentObserver = this._editorState._getDocumentObserver();
      const nodeId = path[0];
      let issuesPath = [nodeId, '@issues'];
      documentObserver.setDirty(issuesPath);
      documentObserver.setDirty(issuesPath.concat(path.slice(1)));
    }

    _getNodeIssues (nodeId) {
      const article = this._getArticle();
      let node = article.get(nodeId);
      let issues = node['@issues'];
      if (!issues) {
        issues = new NodeIssues();
        node['@issues'] = issues;
      }
      return issues
    }

    /*
      Thoughts: the validator is triggered on document change, analyzing the change
      and triggering registered validators accordingly.
    */
    _onDocumentChange (change) {
      // ATTENTION: this is only a prototype implementation
      // This must be redesigned/rewritten when we move further
      const article = this._getArticle();
      // TODO: a DocumentChange could carry a lot more information
      // e.g. uodated[key] = { path, node, value }
      // It would also be better to separate explicit updates (~op.path) from derived updates (node id, annotation updates)
      Object.keys(change.created).forEach(id => {
        let node = article.get(id);
        if (node) {
          CheckRequiredFields.onCreate(this, node);
        }
      });
      Object.keys(change.updated).forEach(key => {
        let path = key.split(',');
        let node = article.get(path[0]);
        if (node) {
          CheckRequiredFields.onUpdate(this, node, path, article.get(path));
        }
      });
    }

    _getArticle () {
      return this._articleSession.getDocument()
    }
  }

  const FIELD_IS_REQUIRED = {
    type: 'required-fields',
    label: 'field-is-required',
    message: 'Field is required'
  };

  const CheckRequiredFields = {
    onCreate (validator, node) {
      if (REQUIRED_PROPERTIES.hasOwnProperty(node.type)) {
        let data = node.toJSON();
        Object.keys(data).forEach(name => {
          this.onUpdate(validator, node, [node.id, name], data[name]);
        });
      }
    },
    onUpdate (validator, node, path, value) {
      // ATTENTION / HACK: assuming that all registered requirements are of the form [type, propName]
      let requiredProps = REQUIRED_PROPERTIES[node.type];
      if (requiredProps && requiredProps.has(path[1])) {
        validator.clearIssues(path, FIELD_IS_REQUIRED.type);
        // TODO: we probably want to use smarter validators than this
        if (substance.isNil(value) || value === '') {
          validator.addIssue(path, FIELD_IS_REQUIRED);
        }
      }
    }
  };

  class NodeIssues {
    constructor () {
      this._issuesByProperty = new Map();
    }

    get (propName) {
      return this._issuesByProperty.get(propName)
    }

    add (propName, issue) {
      if (!this._issuesByProperty.has(propName)) {
        this._issuesByProperty.set(propName, []);
      }
      let issues = this._issuesByProperty.get(propName);
      issues.push(issue);
    }

    clear (propName, type) {
      if (this._issuesByProperty.has(propName)) {
        let issues = this._issuesByProperty.get(propName);
        for (let i = issues.length - 1; i >= 0; i--) {
          if (issues[i].type === type) {
            issues.splice(i, 1);
          }
        }
        if (issues.length === 0) {
          this._issuesByProperty.delete(propName);
        }
      }
    }

    get size () {
      let size = 0;
      this._issuesByProperty.forEach(issues => {
        size += issues.length;
      });
      return size
    }
  }

  class MetadataEditor extends EditorPanel {
    _initialize (props) {
      super._initialize(props);

      this.articleValidator = new ExperimentalArticleValidator(this.editorSession, this.editorSession.editorState);
      this.model = new MetadataModel(this.api);

      // ATTENTION/HACK: this is making all properties dirty, so we have to reset the appState after that
      this.articleValidator.initialize();
      this.appState._reset();
    }

    didMount () {
      super.didMount();
      this._showHideTOC();
      this._restoreViewport();
      substance.DefaultDOMElement.getBrowserWindow().on('resize', this._showHideTOC, this);
    }

    didUpdate () {
      super.didUpdate();
      this._restoreViewport();
    }

    dispose () {
      super.dispose();
      this.articleValidator.dispose();
      substance.DefaultDOMElement.getBrowserWindow().off(this);
    }

    getViewport () {
      return {
        x: this.refs.contentPanel.getScrollPosition()
      }
    }

    render ($$) {
      let el = $$('div').addClass('sc-metadata-editor');
      el.append(
        this._renderMainSection($$)
      );
      el.on('keydown', this._onKeydown);
      return el
    }

    _renderMainSection ($$) {
      const appState = this.context.appState;
      let mainSection = $$('div').addClass('se-main-section');
      mainSection.append(
        this._renderToolbar($$),
        $$('div').addClass('se-content-section').append(
          this._renderTOCPane($$),
          this._renderContentPanel($$)
        ).ref('contentSection'),
        this._renderFooterPane($$)
      );
      if (appState.workflowId) {
        let Modal = this.getComponent('modal');
        let WorkflowComponent = this.getComponent(appState.workflowId);
        let workflowModal = $$(Modal, {
          width: 'large'
        }).addClass('se-workflow-modal').append(
          $$(WorkflowComponent).ref('workflow')
        );
        mainSection.append(workflowModal);
      }
      return mainSection
    }

    _renderToolbar ($$) {
      const Toolbar = this.getComponent('toolbar');
      let config = this.props.config;
      return $$('div').addClass('se-toolbar-wrapper').append(
        $$(Managed(Toolbar), {
          toolPanel: config.getToolPanel('toolbar'),
          bindings: ['commandStates']
        }).ref('toolbar')
      )
    }

    _renderTOCPane ($$) {
      const model = this.model;
      const properties = model.getProperties();

      let el = $$('div').addClass('se-toc-pane').ref('tocPane');
      let tocEl = $$('div').addClass('se-toc');

      properties.forEach(property => {
        let valueModel = property.valueModel;
        let id = valueModel.id || property.type;
        tocEl.append(
          $$(MetaSectionTOCEntry, {
            id,
            name: property.name,
            model: valueModel
          })
        );
      });

      el.append(tocEl);
      return el
    }

    _renderContentPanel ($$) {
      const model = this.model;
      const properties = model.getProperties();
      const ScrollPane$$1 = this.getComponent('scroll-pane');

      let contentPanel = $$(ScrollPane$$1, {
        scrollbarPosition: 'right'
      }).ref('contentPanel');

      let sectionsEl = $$('div').addClass('se-sections');

      properties.forEach(property => {
        let valueModel = property.valueModel;
        let id = valueModel.id || property.type;
        let content = $$(MetadataSection, { model: valueModel }).attr({id}).ref(property.name);
        sectionsEl.append(content);
      });

      contentPanel.append(sectionsEl);

      return contentPanel
    }

    _renderFooterPane ($$) {
      const FindAndReplaceDialog = this.getComponent('find-and-replace-dialog');
      let el = $$('div').addClass('se-footer-pane');
      el.append(
        $$(FindAndReplaceDialog, {
          theme: this._getTheme(),
          viewName: 'metadata'
        }).ref('findAndReplace')
      );
      return el
    }

    _getContentPanel () {
      return this.refs.contentPanel
    }

    _showHideTOC () {
      let contentSectionWidth = this.refs.contentSection.el.width;
      if (contentSectionWidth < 960) {
        this.el.addClass('sm-compact');
      } else {
        this.el.removeClass('sm-compact');
      }
    }
  }

  class ArticleReader extends substance.Component {
    constructor (...args) {
      super(...args);

      this.handleActions({
        executeCommand: this._executeCommand,
        tocEntrySelected: this._tocEntrySelected,
        toggleOverlay: this._toggleOverlay
      });

      this._initialize(this.props);
    }

    _initialize (props) {
      const { articleSession, config, archive } = props;
      const editorSession = new ArticleEditorSession(articleSession, config, this, {
        viewName: this.props.viewName
      });
      const api = new ArticleAPI(articleSession, config, archive);
      this.api = api;
      this.model = new ManuscriptModel(api);
      this.tocProvider = this._getTOCProvider();
      this.context = Object.assign(createEditorContext(config, editorSession), {
        api,
        tocProvider: this.tocProvider,
        urlResolver: archive,
        editable: false
      });
      this.context.appState.addObserver(['viewName'], this._updateViewName, this, { stage: 'render' });

      this.editorSession = editorSession;
      // initial reduce etc.
      this.editorSession.initialize();
    }

    _updateViewName () {
      let appState = this.context.appState;
      this.send('updateViewName', appState.viewName);
    }

    didMount () {
      this.tocProvider.on('toc:updated', this._showHideTOC, this);
      this._showHideTOC();

      substance.DefaultDOMElement.getBrowserWindow().on('resize', this._showHideTOC, this);
    }

    didUpdate () {
      this._showHideTOC();
    }

    dispose () {
      const appState = this.context.appState;
      const articleSession = this.props.articleSession;
      const editorSession = this.editorSession;

      this.tocProvider.off(this);
      articleSession.off(this);
      editorSession.dispose();
      substance.DefaultDOMElement.getBrowserWindow().off(this);
      appState.removeObserver(this);
      this.empty();
    }

    getComponentRegistry () {
      return this.props.config.getComponentRegistry()
    }

    render ($$) {
      let el = $$('div').addClass('sc-article-reader')
        // sharing styles with sc-article-reader
        .addClass('sc-manuscript-view');
      el.append(
        this._renderMainSection($$),
        this._renderContextPane($$)
      );
      return el
    }

    _renderContextPane ($$) {
      // TODO: we need to revisit this
      // We have introduced this to be able to inject a shared context panel
      // in Stencila. However, ATM we try to keep the component
      // as modular as possible, and avoid these kind of things.
      if (this.props.contextComponent) {
        let el = $$('div').addClass('se-context-pane');
        el.append(
          $$('div').addClass('se-context-pane-content').append(
            this.props.contextComponent
          )
        );
        return el
      }
    }

    _renderMainSection ($$) {
      let mainSection = $$('div').addClass('se-main-section');
      mainSection.append(
        this._renderToolbar($$),
        $$('div').addClass('se-content-section').append(
          this._renderTOCPane($$),
          this._renderContentPanel($$)
        ).ref('contentSection')
      );
      return mainSection
    }

    _renderToolbar ($$) {
      const Toolbar = this.getComponent('toolbar');
      const configurator = this._getConfigurator();
      const toolPanel = configurator.getToolPanel('toolbar', true);
      return $$('div').addClass('se-toolbar-wrapper').append(
        $$(Managed(Toolbar), {
          toolPanel,
          bindings: ['commandStates']
        }).ref('toolbar')
      )
    }

    _renderTOCPane ($$) {
      let el = $$('div').addClass('se-toc-pane').ref('tocPane');
      el.append(
        $$('div').addClass('se-context-pane-content').append(
          $$(TOC)
        )
      );
      return el
    }

    _renderContentPanel ($$) {
      const ScrollPane$$1 = this.getComponent('scroll-pane');
      const ManuscriptComponent = this.getComponent('manuscript');

      let contentPanel = $$(ScrollPane$$1, {
        tocProvider: this.tocProvider
      }).ref('contentPanel');

      contentPanel.append(
        $$(ManuscriptComponent, {
          model: this.model,
          disabled: this.props.disabled
        }).ref('article')
      );
      return contentPanel
    }

    getViewport () {
      return {
        x: this.refs.contentPanel.getScrollPosition()
      }
    }

    _getConfigurator () {
      return this.props.config
    }

    _getEditorSession () {
      return this.editorSession
    }

    _getDocument () {
      return this.props.articleSession.getDocument()
    }

    _tocEntrySelected (nodeId) {
      const nodeComponent = this.refs.contentPanel.find(`[data-id="${nodeId}"]`);
      if (nodeComponent) {
        return this._scrollTo(nodeId)
      }
    }

    _scrollTo (nodeId) {
      this.refs.contentPanel.scrollTo(`[data-id="${nodeId}"]`);
    }

    _showHideTOC () {
      let contentSectionWidth = this.refs.contentSection.el.width;
      if (!this._isTOCVisible() || contentSectionWidth < 960) {
        this.el.addClass('sm-compact');
      } else {
        this.el.removeClass('sm-compact');
      }
    }

    _isTOCVisible () {
      let entries = this.tocProvider.getEntries();
      return entries.length >= 2
    }

    _getTOCProvider () {
      let containerId = this._getBodyContainerId();
      return new TOCProvider(this.props.articleSession, { containerId: containerId })
    }

    _getBodyContainerId () {
      return 'body'
    }

    _executeCommand (name) {
      this.editorSession.executeCommand(name);
    }

    _toggleOverlay (overlayId) {
      const appState = this.context.appState;
      if (appState.overlayId === overlayId) {
        appState.overlayId = null;
      } else {
        appState.overlayId = overlayId;
      }
      appState.propagateUpdates();
    }
  }

  var ArticlePackage = {
    name: 'Article',
    configure (parentConfig) {
      parentConfig.addComponent('article', ArticlePanel);
      // create a configuration scope
      let config = parentConfig.createScope('article');

      // used during import
      let modelConfig = new ArticleConfigurator().import(ArticleModelPackage);
      config.setConfiguration('model', modelConfig);
      // used for the manuscript editor view
      let manuscriptEditorConfig = ArticleConfigurator.createFrom(modelConfig).import(EditorPackage);
      config.setConfiguration('manuscript', manuscriptEditorConfig);
      // used for the metadata editor view
      let metadataEditorConfig = ArticleConfigurator.createFrom(modelConfig).import(MetadataPackage);
      config.setConfiguration('metadata', metadataEditorConfig);
      // used for the reader view
      let readerConfig = ArticleConfigurator.createFrom(modelConfig).import(ReaderPackage);
      config.setConfiguration('reader', readerConfig);

      config.import(BasePackage);
      // UI stuff for the ArticlePanel
      config.addComponent('manuscript-editor', ManuscriptEditor);
      config.addComponent('metadata-editor', MetadataEditor);
      config.addComponent('article-reader', ArticleReader);
    }
  }

  class TextureArticleExporter extends substance.XMLExporter {

  }

  class DocumentArchive {
    constructor (sessions, buffer) {
      this.sessions = sessions;
      this.buffer = buffer;

      if (!sessions.manifest) throw new Error("'manifest' session is required.")

      this.init();
    }

    init () {}

    getManifest () {
      return this.sessions.manifest.getDocument()
    }

    getDocumentEntries () {
      return this.getEditorSession('manifest').getDocument().getDocumentEntries()
    }

    getEditorSession (docId) {
      return this.sessions[docId]
    }
  }

  var ManifestSchemaData = {"start":"dar","elements":{"dar":{"name":"dar","type":"element","attributes":{},"elements":{"name":"dar","content":{"type":",","blocks":["documents","assets"]}}},"documents":{"name":"documents","type":"element","attributes":{},"elements":{"name":"documents","content":{"type":"*","block":"document"}}},"assets":{"name":"assets","type":"element","attributes":{},"elements":{"name":"assets","content":{"type":"*","block":"asset"}}},"document":{"name":"document","type":"element","attributes":{"id":{"name":"id"},"name":{"name":"name"},"type":{"name":"type"},"path":{"name":"path"}},"elements":{"name":"document","content":{"type":",","blocks":[]}}},"asset":{"name":"asset","type":"element","attributes":{"id":{"name":"id"},"name":{"name":"name"},"type":{"name":"type"},"path":{"name":"path"}},"elements":{"name":"asset","content":{"type":",","blocks":[]}}}}}

  const ManifestSchema = substance.XMLSchema.fromJSON(ManifestSchemaData);

  // TODO: this should come from compilation
  ManifestSchema.getName = function () {
    return 'RDC-Manifest'
  };

  ManifestSchema.getVersion = function () {
    return '1.0'
  };

  ManifestSchema.getDocTypeParams = function () {
    return ['manifest', 'RDC-Manifest 1.0', ManifestSchema.uri]
  };

  // TODO: this does not make sense
  ManifestSchema.getDefaultTextType = function () {
    return 'text'
  };

  ManifestSchema.uri = '//Manifest-1.0.dtd';

  class ManifestDocument extends substance.XMLDocument {
    getRootNode () {
      if (!this.root) {
        let nodes = this.getNodes();
        let ids = Object.keys(nodes);
        for (var i = 0; i < ids.length; i++) {
          let node = nodes[ids[i]];
          if (node.type === 'dar') {
            this.root = node;
          }
        }
      }
      return this.root
    }

    getDocTypeParams () {
      return ManifestSchema.getDocTypeParams()
    }

    getXMLSchema () {
      return ManifestSchema
    }

    getDocumentNodes () {
      return this.findAll('documents > document')
    }

    getAssetNodes () {
      return this.findAll('assets > asset')
    }

    getDocumentEntries () {
      let documents = this.findAll('documents > document');
      return documents.map(_getEntryFromDocumentNode)
    }

    getDocumentEntry (id) {
      let entryNode = this.get(id);
      if (entryNode && entryNode.type === 'document') {
        return _getEntryFromDocumentNode(entryNode)
      }
    }
  }

  function _getEntryFromDocumentNode (documentNode) {
    return Object.assign({ id: documentNode.id }, documentNode.getAttributes())
  }

  function loadManifest (xmlStr) {
    let configurator = new substance.Configurator();
    substance.registerSchema(configurator, ManifestSchema, ManifestDocument, {
      ImporterClass: substance.XMLDocumentImporter
    });
    let importer = configurator.createImporter(ManifestSchema.getName());
    let manifest = importer.importDocument(xmlStr);
    return new DocumentSession(manifest)
  }

  const path = {
    join (p1, p2) { return p1 + '/' + p2 }
  };

  class VfsLoader {
    constructor (vfs, loaders) {
      this.vfs = vfs;
      this.loaders = loaders;
    }

    load (rdcUri, cb) {
      const vfs = this.vfs;
      let manifestPath = path.join(rdcUri, 'manifest.xml');
      let manifestXml;
      try {
        manifestXml = vfs.readFileSync(manifestPath);
      } catch (err) {
        return cb(err)
      }
      let manifest, manifestEditorSession;
      try {
        let {editorSession} = loadManifest(manifestXml);
        manifest = editorSession.getDocument();
        manifestEditorSession = editorSession;
      } catch (err) {
        return cb(err)
      }
      let sessions = {};
      sessions['manifest'] = manifestEditorSession;
      manifest.findAll('container > documents > document').forEach((el) => {
        let session;
        session = this._loadDocument(rdcUri, el);
        sessions[el.id] = session;
      });
      let dc = new DocumentArchive(sessions);
      cb(null, dc);
    }

    _loadDocument (rdcUri, el) {
      const vfs = this.vfs;
      const type = el.attr('type');
      const relPath = el.attr('path');
      let uri = path.join(rdcUri, relPath);
      let content = vfs.readFileSync(uri);
      let loader = this.loaders[type];
      return loader.load(content)
    }
  }

  var ManifestLoader = {
    load (manifestXml) {
      return loadManifest(manifestXml)
    }
  }

  /*
    A PersistedDocumentArchive is a 3-tier stack representing a document archive
    at different application levels:

    1. Editor: an application such as Texture works on an in-memory data model,
       managed by EditorSessions. There may be multiple sessions for different parts of the
       document archive, e.g. the manuscript and an entity db.
    2. Buffer: a short-term storage for pending changes. Until the document archive
       is saved permanently, changes are recorded and can be persisted, e.g. to
       avoid loosing changes when the browser is closed inadvertently.
    3. Storage: a long-term storage where the document archive is persisted and versioned.

    PersistedDocumentArchive manages the communication between the three layers, e.g.
    when the user changes a document, it records the change and stores it into the buffer,
    and eventually saving a new version of the ardhive.
  */
  class PersistedDocumentArchive extends substance.EventEmitter {
    constructor (storage, buffer, context, config) {
      super();
      this.storage = storage;
      this.buffer = buffer;

      this._archiveId = null;
      this._upstreamArchive = null;
      this._sessions = null;
      this._pendingFiles = {};
      this._config = config;
    }

    hasPendingChanges () {
      return this.buffer.hasPendingChanges()
    }

    // TODO: this can not be used in NodeJS
    createFile (file) {
      let assetId = substance.uuid();
      let fileExtension = substance.last(file.name.split('.'));
      let filePath = `${assetId}.${fileExtension}`;
      this._sessions.manifest.transaction(tx => {
        let assets = tx.find('assets');
        let asset = tx.createElement('asset', { id: assetId }).attr({
          path: filePath,
          type: file.type
        });
        assets.appendChild(asset);
      });
      this.buffer.addBlob(assetId, {
        id: assetId,
        path: filePath,
        blob: file
      });
      // FIXME: what to do in NodeJS?
      if (substance.platform.inBrowser) {
        this._pendingFiles[filePath] = URL.createObjectURL(file);
      }
      return filePath
    }

    /*
      Adds a document record to the manifest file
    */
    _addDocumentRecord (documentId, type, name, path) {
      this._sessions.manifest.transaction(tx => {
        let documents = tx.find('documents');
        let docEntry = tx.createElement('document', { id: documentId }).attr({
          name: name,
          path: path,
          type: type
        });
        documents.appendChild(docEntry);
      });
    }

    addDocument (type, name, xml) {
      let documentId = substance.uuid();
      let sessions = this._sessions;
      let session = this._loadDocument(type, { data: xml }, sessions);
      sessions[documentId] = session;
      this._registerForSessionChanges(session, documentId);
      this._addDocumentRecord(documentId, type, name, documentId + '.xml');
      return documentId
    }

    removeDocument (documentId) {
      let session = this._sessions[documentId];
      this._unregisterFromSession(session);
      this._sessions.manifest.transaction(tx => {
        let documents = tx.find('documents');
        let docEntry = tx.find(`#${documentId}`);
        documents.removeChild(docEntry);
      });
    }

    renameDocument (documentId, name) {
      this._sessions.manifest.transaction(tx => {
        let docEntry = tx.find(`#${documentId}`);
        docEntry.attr({name});
      });
    }

    getDocumentEntries () {
      return this.getEditorSession('manifest').getDocument().getDocumentEntries()
    }

    resolveUrl (path) {
      let blobUrl = this._pendingFiles[path];
      if (blobUrl) {
        return blobUrl
      } else {
        let fileRecord = this._upstreamArchive.resources[path];
        if (fileRecord && fileRecord.encoding === 'url') {
          return fileRecord.data
        }
      }
    }

    load (archiveId, cb) {
      const storage = this.storage;
      const buffer = this.buffer;
      storage.read(archiveId, (err, upstreamArchive) => {
        if (err) return cb(err)
        buffer.load(archiveId, err => {
          if (err) return cb(err)
          // Ensure that the upstream version is compatible with the buffer.
          // The buffer may contain pending changes.
          // In this case the buffer should be based on the same version
          // as the latest version in the storage.
          if (!buffer.hasPendingChanges()) {
            let localVersion = buffer.getVersion();
            let upstreamVersion = upstreamArchive.version;
            if (localVersion && upstreamVersion && localVersion !== upstreamVersion) {
              // If the local version is out-of-date, it would be necessary to 'rebase' the
              // local changes.
              console.error('Upstream document has changed. Discarding local changes');
              this.buffer.reset(upstreamVersion);
            } else {
              buffer.reset(upstreamVersion);
            }
          }
          // convert raw archive into sessions (=ingestion)
          let sessions = this._ingest(upstreamArchive);
          // contract: there must be a manifest
          if (!sessions['manifest']) {
            throw new Error('There must be a manifest session.')
          }
          // apply pending changes
          if (!buffer.hasPendingChanges()) ; else {
            buffer.reset(upstreamArchive.version);
          }
          // register for any changes in each session
          this._registerForAllChanges(sessions);

          this._archiveId = archiveId;
          this._upstreamArchive = upstreamArchive;
          this._sessions = sessions;

          // Run through a repair step (e.g. remove missing files from archive)
          this._repair();
          cb(null, this);
        });
      });
    }

    _repair () {
      // no-op
    }

    save (cb) {
      // FIXME: buffer.hasPendingChanges() is not working
      this.buffer._isDirty['manuscript'] = true;
      this._save(this._archiveId, cb);
    }

    /*
      Save as is implemented as follows.

      1. clone: copy all files from original archive to new archive (backend)
      2. save: perform a regular save using user buffer (over new archive, including pending
         documents and blobs)
    */
    saveAs (newArchiveId, cb) {
      this.storage.clone(this._archiveId, newArchiveId, (err) => {
        if (err) return cb(err)
        this._save(newArchiveId, cb);
      });
    }

    getEditorSession (docId) {
      return this._sessions[docId]
    }

    _loadManifest (record) {
      if (!record) {
        throw new Error('manifest.xml is missing')
      }
      return ManifestLoader.load(record.data)
    }

    _registerForAllChanges (sessions) {
      substance.forEach(sessions, (session, docId) => {
        this._registerForSessionChanges(session, docId);
      });
    }

    _registerForSessionChanges (session, docId) {
      session.on('change', (change) => {
        this.buffer.addChange(docId, change);
        // Apps can subscribe to this (e.g. to show there's pending changes)
        this.emit('archive:changed');
      }, this);
    }

    _unregisterFromSession (session) {
      session.off(this);
    }

    /*
      Create a raw archive for upload from the changed resources.
    */
    _save (archiveId, cb) {
      const buffer = this.buffer;
      const storage = this.storage;
      const sessions = this._sessions;

      let rawArchive = this._exportChanges(sessions, buffer);

      // CHALLENGE: we either need to lock the buffer, so that
      // new changes are interfering with ongoing sync
      // or we need something pretty smart caching changes until the
      // sync has succeeded or failed, e.g. we could use a second buffer in the meantime
      // probably a fast first-level buffer (in-mem) is necessary anyways, even in conjunction with
      // a slower persisted buffer
      storage.write(archiveId, rawArchive, (err, res) => {
        if (err) return cb(err)

        // TODO: if successful we should receive the new version as response
        // and then we can reset the buffer
        let _res = { version: '0' };
        if (substance.isString(res)) {
          try {
            _res = JSON.parse(res);
          } catch (err) {
            console.error('Invalid response from storage.write()');
          }
        }
        // console.log('Saved. New version:', res.version)
        buffer.reset(_res.version);

        // After successful save the archiveId may have changed (save as use case)
        this._archiveId = archiveId;
        this.emit('archive:saved');
        cb();
      });
    }

    _exportAssets (sessions, buffer, rawArchive) {
      let manifest = sessions.manifest.getDocument();
      let assetNodes = manifest.getAssetNodes();
      assetNodes.forEach(node => {
        let id = node.attr('id');
        if (!buffer.hasBlob(id)) return
        let path = node.attr('path') || id;
        let blobRecord = buffer.getBlob(id);
        rawArchive.resources[path] = {
          id,
          data: blobRecord.blob,
          encoding: 'blob',
          createdAt: Date.now(),
          updatedAt: Date.now()
        };
      });
    }

    /*
      Uses the current state of the buffer to generate a rawArchive object
      containing all changed documents
    */
    _exportChanges (sessions, buffer) {
      let rawArchive = {
        version: buffer.getVersion(),
        diff: buffer.getChanges(),
        resources: {}
      };
      this._exportManifest(sessions, buffer, rawArchive);
      this._exportDocuments(sessions, buffer, rawArchive);
      this._exportAssets(sessions, buffer, rawArchive);
      return rawArchive
    }
  }

  /* global FormData */

  class HttpStorageClient {
    constructor (apiUrl) {
      this.apiUrl = apiUrl;
    }

    /*
      @returns a Promise for a raw archive, i.e. the data for a DocumentArchive.
    */
    read (archiveId, cb) {
      let url = this.apiUrl;
      if (archiveId) {
        url = url + '/' + archiveId;
      }
      return substance.sendRequest({
        method: 'GET',
        url
      }).then(response => {
        cb(null, JSON.parse(response));
      }).catch(err => {
        cb(err);
      })
    }

    write (archiveId, data, cb) {
      let form = new FormData();
      substance.forEach(data.resources, (record, filePath) => {
        if (record.encoding === 'blob') {
          // removing the blob from the record and submitting it as extra part
          form.append(record.id, record.data, filePath);
          delete record.data;
        }
      });
      form.append('_archive', JSON.stringify(data));
      let url = this.apiUrl;
      if (archiveId) {
        url = url + '/' + archiveId;
      }
      return substance.sendRequest({
        method: 'PUT',
        url,
        data: form
      }).then(response => {
        cb(null, response);
      }).catch(err => {
        cb(err);
      })
    }
  }

  class InMemoryDarBuffer {
    constructor () {
      this._version = null;
      this._changes = [];
      this._isDirty = {};
      this._blobs = {};
    }

    getVersion () {
      return this._version
    }

    load(archiveId, cb) { // eslint-disable-line
      cb();
    }

    addChange (docId, change) {
      // HACK: if there are no ops we skip
      if (change.ops.length === 0) return
      // console.log('RECORD CHANGE', docId, change)
      this._isDirty[docId] = true;
      this._changes.push({
        docId, change
      });
    }

    hasPendingChanges () {
      return this._changes.length > 0
    }

    getChanges () {
      return this._changes.slice()
    }

    hasResourceChanged (docId) {
      return this._isDirty[docId]
    }

    hasBlob (id) {
      return this._blobs[id]
    }

    addBlob (id, blob) {
      this._blobs[id] = blob;
    }

    getBlob (id) {
      return this._blobs[id]
    }

    reset (version) {
      this._version = version;
      this._changes = [];
      this._blobs = {};
      this._isDirty = {};
    }
  }

  class VfsStorageClient {
    constructor (vfs, baseUrl) {
      this.vfs = vfs;

      // an url rom where the assets are served statically
      this.baseUrl = baseUrl;
    }

    read (archiveId, cb) {
      let rawArchive = _readRawArchive(this.vfs, archiveId, this.baseUrl);
      cb(null, rawArchive);
    }

    write (archiveId, data, cb) { // eslint-disable-line
      _updateRawArchive(this.vfs, archiveId, data, this.baseUrl);
      cb(null, true);
    }
  }

  function _readRawArchive (fs, archiveId, baseUrl = '') {
    let manifestXML = fs.readFileSync(`${archiveId}/manifest.xml`);
    let manifestSession = ManifestLoader.load(manifestXML);
    let manifest = manifestSession.getDocument();
    let docs = manifest.findAll('documents > document');
    let assets = manifest.findAll('assets > asset');
    let rawArchive = {
      version: '0',
      resources: {
        'manifest.xml': {
          encoding: 'utf8',
          data: manifestXML
        }
      }
    };

    docs.forEach(entry => {
      let path = entry.attr('path');
      if (fs.existsSync(`${archiveId}/${entry.path}`)) {
        let content = fs.readFileSync(`${archiveId}/${entry.path}`);
        rawArchive.resources[path] = {
          encoding: 'utf8',
          data: content
        };
      } else {
        console.warn(`${archiveId}/${entry.path} not found in vfs`);
      }
    });
    assets.forEach(asset => {
      let path = asset.attr('path');
      // TODO: we could store other stats and maybe mime-types in VFS
      rawArchive.resources[path] = {
        encoding: 'url',
        data: baseUrl + archiveId + '/' + path
      };
    });
    return rawArchive
  }

  function _updateRawArchive (fs, archiveId, rawArchive, baseUrl = '') {
    let paths = Object.keys(rawArchive.resources);
    for (let path of paths) {
      let resource = rawArchive.resources[path];
      let data = resource.data;
      fs.writeFileSync(`${archiveId}/${path}`, data);
    }
  }

  function checkLoadArchive (ArchiveClass, rawArchive) {
    let testArchive = new ArchiveClass();
    try {
      testArchive._ingest(rawArchive);
    } catch (error) {
      return error
    }
  }

  function vfsSaveHook (storage, ArchiveClass) {
    // monkey patch VfsStorageClient so that we can check if the stored data
    // can be loaded
    storage.write = (archiveId, rawArchive, cb) => {
      console.info('Writing archive:', rawArchive); // eslint-disable-line
      storage.read(archiveId, (err, originalRawArchive) => {
        if (err) return cb(err)
        rawArchive.resources = Object.assign({}, originalRawArchive.resources, rawArchive.resources);
        err = checkLoadArchive(ArchiveClass, rawArchive);
        if (err) {
          if (substance.platform.inBrowser) {
            console.error(err);
            window.alert('Exported archive is corrupt!'); // eslint-disable-line no-alert
          }
          console.error(err.detail);
          return cb(err)
        } else {
          return cb(null, true)
        }
      });
    };
  }

  // TODO: this should incoporate the 'Project' stuff that we have in Stencila
  class Texture extends substance.Component {
    constructor (...args) {
      super(...args);

      this.config = this._getConfiguration();
    }

    render ($$) {
      const archive = this.props.archive;
      let el = $$('div').addClass('sc-texture');

      // TODO: switch by current document tab
      const currentDocumentName = 'manuscript';
      const ResourceComponent = this.config.getComponent('article');
      const config = this.config.getConfiguration('article');
      const documentSession = archive.getEditorSession(currentDocumentName);
      let props = {
        archive,
        config,
        documentSession
      };
      el.append(
        $$(ResourceComponent, props).ref('resource')
      );
      if (substance.platform.inBrowser && !substance.platform.isChromium && !substance.platform.inElectron) {
        el.append(
          $$(PinnedMessage, {icon: 'fa-warning', label: 'Attention! Current version of Texture supports only Chrome browser.'})
        );
      }
      return el
    }

    _getConfiguration () {
      let config = new TextureConfigurator();
      // TODO: in future we want to make this configurable (plugin framework)
      config.import(ArticlePackage);
      return config
    }

    _handleKeydown (event) {
      this.refs.resource._handleKeydown(event);
    }
  }

  class TextureAppChrome extends substance.Component {
    didMount () {
      // when the developer console is not open, display when there is an error
      if (!substance.platform.devtools) {
        this._init(err => {
          if (err) {
            console.error(err);
            this.setState({ error: err });
          }
        });
      } else {
        this._init();
      }
      // Note: adding global handlers causes problems in the test suite
      if (!substance.platform.test) {
        substance.DefaultDOMElement.getBrowserWindow().on('keydown', this._keyDown, this);
        substance.DefaultDOMElement.getBrowserWindow().on('drop', this._supressDnD, this);
        substance.DefaultDOMElement.getBrowserWindow().on('dragover', this._supressDnD, this);
      }
      this.handleActions({
        'save': this._handleSave
      });
    }

    _handleSave () {
      this._save((err) => {
        if (err) console.error(err);
      });
    }

    dispose () {
      substance.DefaultDOMElement.getBrowserWindow().off(this);
    }

    getChildContext () {
      return this._childContext || {}
    }

    getInitialState () {
      return {
        archive: undefined,
        error: undefined
      }
    }

    /*
      4 initialisation stages:
      - _setupChildContext
      - _initContext
      - _loadArchive
      - _initArchive
    */
    _init (cb) {
      if (!cb) cb = (err) => { if (err) throw err };
      this._setupChildContext((err, context) => {
        if (err) return cb(err)
        this._initContext(context, (err, context) => {
          if (err) return cb(err)
          this._loadArchive(this.props.archiveId, context, (err, archive) => {
            if (err) return cb(err)
            this._initArchive(archive, context, (err, archive) => {
              if (err) return cb(err)
              this._childContext = context;
              this._afterInit();
              this.setState({ archive });
              this.emit('archive:ready');
            });
          });
        });
      });
    }

    _setupChildContext (cb) {
      cb(null, {});
    }

    _initContext (context, cb) {
      cb(null, context);
    }

    _loadArchive () {
      throw new Error('_loadArchive not implemented')
    }

    _initArchive (archive, context, cb) {
      cb(null, archive);
    }

    _afterInit () {}

    _save (cb) {
      this.state.archive.save(err => {
        if (err) return cb(err)
        this._updateTitle(false);
        cb(null);
      });
    }

    _updateTitle () {}

    _keyDown (event) {
      // TODO: should this really be suppressed here?
      if (event.key === 'Dead') return
      if (this._handleKeydown) {
        this._handleKeydown(event);
      }
    }

    _supressDnD (event) {
      event.preventDefault();
    }
  }

  class TextureArchive extends PersistedDocumentArchive {
    /*
      Creates EditorSessions from a raw archive.
      This might involve some consolidation and ingestion.
    */
    _ingest (rawArchive) {
      let sessions = {};
      let manifestXML = _importManifest(rawArchive);
      let manifestSession = this._loadManifest({ data: manifestXML });
      sessions['manifest'] = manifestSession;
      let entries = manifestSession.getDocument().getDocumentEntries();

      entries.forEach(entry => {
        let record = rawArchive.resources[entry.path];
        // Note: this happens when a resource is referenced in the manifest
        // but is not there actually
        // we skip loading here and will fix the manuscript later on
        if (!record) {
          return
        }
        // Load any document except pub-meta (which we prepared manually)
        if (entry.type !== 'pub-meta') {
          // TODO: we need better concept for handling errors
          let session;
          // Passing down 'sessions' so that we can add to the pub-meta session
          session = this._loadDocument(entry.type, record, sessions);
          sessions[entry.id] = session;
        }
      });
      return sessions
    }

    _repair () {
      let manifestSession = this.getEditorSession('manifest');
      let entries = manifestSession.getDocument().getDocumentEntries();
      let missingEntries = [];

      entries.forEach(entry => {
        let session = this.getEditorSession(entry.id);
        if (!session) {
          missingEntries.push(entry.id);
          console.warn(`${entry.path} could not be found in archive and will be deleted...`);
        }
      });

      // Cleanup missing entries
      manifestSession.transaction(tx => {
        let documentsEl = tx.find('documents');
        missingEntries.forEach(missingEntry => {
          let entryEl = tx.get(missingEntry);
          documentsEl.removeChild(entryEl);
        });
      });
    }

    _exportManifest (sessions, buffer, rawArchive) {
      let manifest = sessions.manifest.getDocument();
      if (buffer.hasResourceChanged('manifest')) {
        let manifestDom = manifest.toXML();
        let manifestXmlStr = substance.prettyPrintXML(manifestDom);
        rawArchive.resources['manifest.xml'] = {
          id: 'manifest',
          data: manifestXmlStr,
          encoding: 'utf8',
          updatedAt: Date.now()
        };
      }
    }

    _exportDocuments (sessions, buffer, rawArchive) {
      // Note: we are only adding resources that have changed
      // and only those which are registered in the manifest
      let entries = this.getDocumentEntries();
      let hasPubMetaChanged = buffer.hasResourceChanged('pub-meta');
      entries.forEach(entry => {
        let { id, type, path } = entry;
        let hasChanged = buffer.hasResourceChanged(id);

        // We will never persist pub-meta
        if (type === 'pub-meta') return

        // We mark a resource dirty when it has changes, or if it is an article
        // and pub-meta has changed
        if (hasChanged || (type === 'article' && hasPubMetaChanged)) {
          let session = sessions[id];
          // TODO: how should we communicate file renamings?
          rawArchive.resources[path] = {
            id,
            // HACK: same as when loading we pass down all sessions so that we can do some hacking there
            data: this._exportDocument(type, session, sessions),
            encoding: 'utf8',
            updatedAt: Date.now()
          };
        }
      });
    }

    _loadDocument (type, record, sessions) {
      switch (type) {
        case 'article': {
          return ArticleLoader.load(record.data, {}, this._config)
        }
        default:
          throw new Error('Unsupported document type')
      }
    }

    _exportDocument (type, session, sessions) { // eslint-disable-line no-unused-vars
      switch (type) {
        case 'article': {
          let exporter = new JATSExporter();
          let doc = session.getDocument();
          let res = exporter.export(doc);
          // TODO: we need a way to report this problem, i.e. make us at least aware of it
          // if (!res.ok) {
          //   throw new Error('FIXME: generated XML is not JATS compliant!')
          // }
          let jats = res.jats;
          console.info('saving jats', jats.getNativeElement());
          let xmlStr = substance.prettyPrintXML(jats);
          return xmlStr
        }
        default:
          throw new Error('Unsupported document type')
      }
    }

    getTitle () {
      let editorSession = this.getEditorSession('manuscript');
      let title = 'Untitled';
      if (editorSession) {
        let doc = editorSession.getDocument();
        let articleTitle = doc.getTitle();
        if (articleTitle) {
          title = articleTitle;
        }
      }
      return title
    }
  }

  /*
    Create an explicit entry for pub-meta.json, which does not
    exist in the serialisation format
  */
  function _importManifest (rawArchive) {
    let manifestXML = rawArchive.resources['manifest.xml'].data;
    let dom = substance.DefaultDOMElement.parseXML(manifestXML);
    return dom.serialize()
  }

  function TextureAppMixin (ParentAppChrome) {
    return class TextureApp extends ParentAppChrome {
      render ($$) {
        let el = $$('div').addClass('sc-app');
        let { archive, error } = this.state;
        if (archive) {
          const Texture$$1 = this._getAppClass();
          el.append(
            $$(Texture$$1, { archive }).ref('texture')
          );
        } else if (error) {
          if (error.type === 'jats-import-error') {
            el.append(
              $$(JATSImportDialog, { errors: error.detail._errors })
            );
          } else {
            el.append('ERROR:', error.message);
          }
        }
        return el
      }

      _getAppClass () {
        return Texture
      }

      _getArchiveClass () {
        return TextureArchive
      }
    }
  }

  class TextureDesktopAppChrome extends TextureAppChrome {
    didMount () {
      super.didMount();

      substance.DefaultDOMElement.getBrowserWindow().on('click', this._click, this);
    }

    // overridding the default to emit an event up and let the Electron bridge (app.js) handle it
    _handleSave () {
      this.el.emit('save');
    }

    // TODO: try to share implementation with TextureDesktopAppChrome
    // move as much as possible into TextureAppChrome
    // and only add browser specific overrides here
    _handleKeydown (event) {
      // let key = parseKeyEvent(event)
      // console.log('Texture received keydown for combo', key)
      let handled = false;
      // CommandOrControl+S
      // if (key === 'META+83' || key === 'CTRL+83') {
      //   this._save(err => {
      //     if (err) console.error(err)
      //   })
      //   handled = true
      // }
      if (!handled) {
        handled = this.refs.texture._handleKeydown(event);
      }
      if (handled) {
        event.preventDefault();
        event.stopPropagation();
      }
    }

    _loadArchive (archiveId, context, cb) {
      const ArchiveClass = this._getArchiveClass();
      let storage = this.props.storage;
      let buffer = new InMemoryDarBuffer();
      let archive = new ArchiveClass(storage, buffer, context);
      // HACK: this should be done earlier in the lifecycle (after first didMount)
      // and later disposed properly. However we can accept this for now as
      // the app lives as a singleton atm.
      // NOTE: _archiveChanged is implemented by DesktopAppChrome
      archive.on('archive:changed', this._archiveChanged, this);
      // ATTENTION: we want to treat new archives as 'read-only' in the
      // sense that a new archive is essentially one of several dar templates.
      archive.load(archiveId, (err, archive) => {
        if (err) return cb(err)
        if (this.props.isReadOnly) {
          archive.isReadOnly = true;
        }
        cb(null, archive);
      });
    }

    _saveAs (newDarPath, cb) {
      console.info('saving as', newDarPath);
      let archive = this.state.archive;
      archive.saveAs(newDarPath, err => {
        if (err) {
          console.error(err);
          return cb(err)
        }
        // HACK: this is kind of an optimization but formally it is not
        // 100% correct to continue with the same archive instance
        // Instead one would expect that cloning an archive returns
        // a new archive instance
        // Though, this would have other undesired implications
        // such as loosing the scroll position or undo history
        // Thus we move on with this solution, but we need to clear
        // the isReadOnly flag now.
        archive.isReadOnly = false;
        this._updateTitle();
        cb();
      });
    }

    _archiveChanged () {
      this._updateTitle();
    }

    _updateTitle () {
      const archive = this.state.archive;
      if (!archive) return
      let newTitle = archive.getTitle();
      if (archive.hasPendingChanges()) {
        newTitle += ' *';
      }
      document.title = newTitle;
    }

    _click (event) {
      const target = substance.DefaultDOMElement.wrapNativeElement(event.target);
      let url = target.getAttribute('href');
      if (target.is('a') && url !== '#') {
        event.preventDefault();
        this.emit('openExternal', url);
      }
    }
  }

  class TextureDesktopApp extends TextureAppMixin(TextureDesktopAppChrome) {}

  /* global vfs */

  class TextureWebAppChrome extends TextureAppChrome {
    _loadArchive (archiveId, context, cb) {
      let storage = this._getStorage(this.props.storageType);
      let buffer = new InMemoryDarBuffer();
      let ArchiveClass = this._getArchiveClass();
      let archive = new ArchiveClass(storage, buffer, context);
      try {
        archive.load(archiveId, cb);
      } catch (err) {
        this.setState({
          error: err
        });
        console.error(err);
      }
    }

    _getStorage (storageType) {
      if (storageType === 'vfs') {
        return new VfsStorageClient(vfs, this._getDefaultDataFolder())
      } else {
        return new HttpStorageClient(this.props.storageUrl)
      }
    }

    // TODO: try to share implementation with TextureDesktopAppChrome
    // move as much as possible into TextureAppChrome
    // and only add browser specific overrides here
    _handleKeydown (event) {
      let key = substance.parseKeyEvent(event);
      // console.log('Texture received keydown for combo', key)
      let handled = false;
      // CommandOrControl+S
      if (key === 'META+83' || key === 'CTRL+83') {
        this._save(err => {
          if (err) console.error(err);
        });
        handled = true;
      }
      if (!handled) {
        handled = this.refs.texture._handleKeydown(event);
      }
      if (handled) {
        event.preventDefault();
        event.stopPropagation();
      }
    }

    _getArchiveClass () { throw new Error('This method is abstract') }

    _getDefaultDataFolder () { throw new Error('This method  is abstract') }
  }

  class TextureWebApp extends TextureAppMixin(TextureWebAppChrome) {
    _getDefaultDataFolder () {
      return './data/'
    }
  }

  const _global = (typeof global !== 'undefined') ? global : window;
  const textureGlobals = _global.hasOwnProperty('Texture') ? _global.Texture : _global.Texture = {
    DEBUG: false
  };

  exports.Texture = Texture;
  exports.TextureAppChrome = TextureAppChrome;
  exports.TextureArchive = TextureArchive;
  exports.TextureConfigurator = TextureConfigurator;
  exports.TextureDesktopApp = TextureDesktopApp;
  exports.TextureDesktopAppChrome = TextureDesktopAppChrome;
  exports.TextureWebApp = TextureWebApp;
  exports.TextureWebAppChrome = TextureWebAppChrome;
  exports.textureGlobals = textureGlobals;
  exports.ArticleAPI = ArticleAPI;
  exports.ArticleEditorSession = ArticleEditorSession;
  exports.ArticleLoader = ArticleLoader;
  exports.ArticlePackage = ArticlePackage;
  exports.ArticleModelPackage = ArticleModelPackage;
  exports.ArticleSession = ArticleSession;
  exports.JATS = JATS;
  exports.TextureArticle = TextureArticle;
  exports.InternalArticleSchema = InternalArticleSchema;
  exports.InternalArticleDocument = InternalArticleDocument;
  exports.TextureArticleExporter = TextureArticleExporter;
  exports.XrefIndex = XrefIndex;
  exports.JATSImportDialog = JATSImportDialog;
  exports.JATSImporter = JATSImporter;
  exports.JATSExporter = JATSExporter;
  exports.createEmptyJATS = createEmptyJATS;
  exports.jats2internal = jats2internal;
  exports.internal2jats = internal2jats;
  exports.createJatsImporter = createJatsImporter;
  exports.createJatsExporter = createJatsExporter;
  exports.jats2restrictedJats = jats2restrictedJats;
  exports.EditorPackage = EditorPackage;
  exports.InsertNodeCommand = InsertNodeCommand;
  exports.SaveHandler = SaveHandler;
  exports.tableHelpers = tableHelpers;
  exports.NumberedLabelGenerator = NumberedLabelGenerator;
  exports.ReferenceManager = ReferenceManager;
  exports.FigureManager = FigureManager;
  exports.TableManager = TableManager;
  exports.FootnoteManager = FootnoteManager;
  exports.removeElementAndXrefs = removeElementAndXrefs;
  exports.updateEntityChildArray = updateEntityChildArray;
  exports.TableComponent = TableComponent;
  exports.TableEditing = TableEditing;
  exports.getLabel = getLabel;
  exports.getPos = getPos;
  exports.REF_TYPES = REF_TYPES;
  exports.XREF_TARGET_TYPES = XREF_TARGET_TYPES;
  exports.getXrefTargets = getXrefTargets;
  exports.getXrefLabel = getXrefLabel;
  exports.hasAvailableXrefTargets = hasAvailableXrefTargets;
  exports.getAvailableXrefTargets = getAvailableXrefTargets;
  exports.MANUSCRIPT_MODE = MANUSCRIPT_MODE;
  exports.PREVIEW_MODE = PREVIEW_MODE;
  exports.METADATA_MODE = METADATA_MODE;
  exports.JOURNAL_ARTICLE_REF = JOURNAL_ARTICLE_REF;
  exports.BOOK_REF = BOOK_REF;
  exports.CHAPTER_REF = CHAPTER_REF;
  exports.CONFERENCE_PAPER_REF = CONFERENCE_PAPER_REF;
  exports.DATA_PUBLICATION_REF = DATA_PUBLICATION_REF;
  exports.PATENT_REF = PATENT_REF;
  exports.ARTICLE_REF = ARTICLE_REF;
  exports.NEWSPAPER_ARTICLE_REF = NEWSPAPER_ARTICLE_REF;
  exports.MAGAZINE_ARTICLE_REF = MAGAZINE_ARTICLE_REF;
  exports.REPORT_REF = REPORT_REF;
  exports.SOFTWARE_REF = SOFTWARE_REF;
  exports.THESIS_REF = THESIS_REF;
  exports.WEBPAGE_REF = WEBPAGE_REF;
  exports.JATS_BIBR_TYPES_TO_INTERNAL = JATS_BIBR_TYPES_TO_INTERNAL;
  exports.INTERNAL_BIBR_TYPES_TO_JATS = INTERNAL_BIBR_TYPES_TO_JATS;
  exports.JATS_BIBR_TYPES = JATS_BIBR_TYPES;
  exports.INTERNAL_BIBR_TYPES = INTERNAL_BIBR_TYPES;
  exports.REQUIRED_PROPERTIES = REQUIRED_PROPERTIES;
  exports.LICENSES = LICENSES;
  exports.CARD_MINIMUM_FIELDS = CARD_MINIMUM_FIELDS;
  exports.DocumentArchive = DocumentArchive;
  exports.VfsLoader = VfsLoader;
  exports.ManifestLoader = ManifestLoader;
  exports.PersistedDocumentArchive = PersistedDocumentArchive;
  exports.HttpStorageClient = HttpStorageClient;
  exports.InMemoryDarBuffer = InMemoryDarBuffer;
  exports.VfsStorageClient = VfsStorageClient;
  exports.checkArchive = checkLoadArchive;
  exports.vfsSaveHook = vfsSaveHook;
  exports.BasePackage = BasePackage;
  exports.EditorBasePackage = EditorBasePackage;
  exports.AppState = AppState;
  exports.createComponentContext = createComponentContext;
  exports.createEditorContext = createEditorContext;
  exports.DocumentObserver = DocumentObserver;
  exports.DocumentSession = DocumentSession;
  exports.EditorSessionMixin = EditorSessionMixin;
  exports.EditorState = EditorState;
  exports.FindAndReplacePackage = FindAndReplacePackage;
  exports.AbstractAPI = AbstractAPI;
  exports.addModelObserver = addModelObserver;
  exports.BooleanModel = BooleanModel;
  exports.BooleanComponent = BooleanComponent;
  exports.ChildModel = ChildModel;
  exports.ChildComponent = ChildComponent;
  exports.ChildrenModel = ChildrenModel;
  exports.ChildrenComponent = ChildrenModelComponent;
  exports.ClipboardNew = ClipboardNew;
  exports.CompositeModel = CompositeModel;
  exports.CompositeComponent = CompositeComponent;
  exports.createValueModel = createValueModel;
  exports.DynamicCollection = DynamicCollection;
  exports.EditorAPI = EditorAPI;
  exports.FlowContentModel = FlowContentModel;
  exports.FlowContentComponent = FlowContentComponent;
  exports.getComponentForModel = getComponentForModel;
  exports.InternalEditingAPI = InternalEditingAPI;
  exports.JSONConverterNew = JSONConverterNew;
  exports.ManyRelationshipModel = ManyRelationshipModel;
  exports.ManyRelationshipComponent = ManyRelationshipComponent;
  exports.ModelComponent = ModelComponent;
  exports.ModelComponentPackage = ModelComponentPackage;
  exports.ModelProperty = ModelProperty;
  exports.NodeComponent = NodeComponent;
  exports.NodeComponentMixin = NodeComponentMixin;
  exports.NodeModel = NodeModel;
  exports.NodeModelFactory = NodeModelFactory;
  exports.NodeModelProperty = NodeModelProperty;
  exports.ObjectModel = ObjectModel;
  exports.ObjectComponent = ObjectComponent;
  exports.removeModelObserver = removeModelObserver;
  exports.SingleRelationshipModel = SingleRelationshipModel;
  exports.SingleRelationshipComponent = SingleRelationshipComponent;
  exports.StringModel = StringModel;
  exports.StringComponent = StringComponent;
  exports.TextModel = TextModel;
  exports.TextComponent = TextComponent;
  exports.TextNodeComponent = TextNodeComponent;
  exports.ValueComponent = ValueComponent;
  exports.ValueModel = ValueModel;
  exports.ContainerEditor = ContainerEditorNew;
  exports.IsolatedInlineNodeComponent = IsolatedInlineNodeComponentNew;
  exports.IsolatedNodeComponent = IsolatedNodeComponentNew;
  exports.TextPropertyComponent = TextPropertyComponentNew;
  exports.TextPropertyEditor = TextPropertyEditorNew;
  exports.STRING = STRING;
  exports.TEXT = TEXT;
  exports.STRING_ARRAY = STRING_ARRAY;
  exports.BOOLEAN = BOOLEAN;
  exports.MANY = MANY$1;
  exports.ONE = ONE$1;
  exports.CHILDREN = CHILDREN;
  exports.CHILD = CHILD$1;
  exports.AbstractScrollPane = AbstractScrollPane;
  exports.BodyScrollPane = BodyScrollPane;
  exports.Button = Button;
  exports.CheckboxInput = CheckboxInput;
  exports.ContextMenu = ContextMenu;
  exports.FormRowComponent = FormRowComponent;
  exports.Managed = Managed;
  exports.Menu = Menu;
  exports.MenuGroup = MenuGroup;
  exports.MenuItem = MenuItem;
  exports.ModalDialog = ModalDialog;
  exports.MultiSelectInput = MultiSelectInput;
  exports.Overlay = Overlay;
  exports.OverlayMixin = OverlayMixin;
  exports.PinnedMessage = PinnedMessage;
  exports.ScrollPane = ScrollPane;
  exports.ToggleTool = ToggleTool;
  exports.Toolbar = ToolbarV2;
  exports.ToolDropdown = ToolDropdown;
  exports.ToolGroup = ToolGroup;
  exports.ToolPanel = ToolPanel;
  exports.ToolPrompt = ToolPromptV2;
  exports.Tooltip = Tooltip;
  exports.stopEvent = stopEvent;
  exports.stopAndPreventEvent = stopAndPreventEvent;

  Object.defineProperty(exports, '__esModule', { value: true });

})));

//# sourceMappingURL=./texture.js.map